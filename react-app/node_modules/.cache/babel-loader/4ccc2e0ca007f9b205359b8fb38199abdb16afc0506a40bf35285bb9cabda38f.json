{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from '../viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n  constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n    this.editorId = editorId;\n    this.model = model;\n    this.configuration = configuration;\n    this._linesCollection = linesCollection;\n    this._coordinatesConverter = coordinatesConverter;\n    this._decorationsCache = Object.create(null);\n    this._cachedModelDecorationsResolver = null;\n    this._cachedModelDecorationsResolverViewRange = null;\n  }\n  _clearCachedModelDecorationsResolver() {\n    this._cachedModelDecorationsResolver = null;\n    this._cachedModelDecorationsResolverViewRange = null;\n  }\n  dispose() {\n    this._decorationsCache = Object.create(null);\n    this._clearCachedModelDecorationsResolver();\n  }\n  reset() {\n    this._decorationsCache = Object.create(null);\n    this._clearCachedModelDecorationsResolver();\n  }\n  onModelDecorationsChanged() {\n    this._decorationsCache = Object.create(null);\n    this._clearCachedModelDecorationsResolver();\n  }\n  onLineMappingChanged() {\n    this._decorationsCache = Object.create(null);\n    this._clearCachedModelDecorationsResolver();\n  }\n  _getOrCreateViewModelDecoration(modelDecoration) {\n    const id = modelDecoration.id;\n    let r = this._decorationsCache[id];\n    if (!r) {\n      const modelRange = modelDecoration.range;\n      const options = modelDecoration.options;\n      let viewRange;\n      if (options.isWholeLine) {\n        const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* PositionAffinity.Left */);\n        const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* PositionAffinity.Right */);\n        viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n      } else {\n        // For backwards compatibility reasons, we want injected text before any decoration.\n        // Thus, move decorations to the right.\n        viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* PositionAffinity.Right */);\n      }\n\n      r = new ViewModelDecoration(viewRange, options);\n      this._decorationsCache[id] = r;\n    }\n    return r;\n  }\n  getDecorationsViewportData(viewRange) {\n    let cacheIsValid = this._cachedModelDecorationsResolver !== null;\n    cacheIsValid = cacheIsValid && viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange);\n    if (!cacheIsValid) {\n      this._cachedModelDecorationsResolver = this._getDecorationsInRange(viewRange);\n      this._cachedModelDecorationsResolverViewRange = viewRange;\n    }\n    return this._cachedModelDecorationsResolver;\n  }\n  getInlineDecorationsOnLine(lineNumber) {\n    const range = new Range(lineNumber, this._linesCollection.getViewLineMinColumn(lineNumber), lineNumber, this._linesCollection.getViewLineMaxColumn(lineNumber));\n    return this._getDecorationsInRange(range).inlineDecorations[0];\n  }\n  _getDecorationsInRange(viewRange) {\n    const modelDecorations = this._linesCollection.getDecorationsInRange(viewRange, this.editorId, filterValidationDecorations(this.configuration.options));\n    const startLineNumber = viewRange.startLineNumber;\n    const endLineNumber = viewRange.endLineNumber;\n    const decorationsInViewport = [];\n    let decorationsInViewportLen = 0;\n    const inlineDecorations = [];\n    for (let j = startLineNumber; j <= endLineNumber; j++) {\n      inlineDecorations[j - startLineNumber] = [];\n    }\n    for (let i = 0, len = modelDecorations.length; i < len; i++) {\n      const modelDecoration = modelDecorations[i];\n      const decorationOptions = modelDecoration.options;\n      if (!isModelDecorationVisible(this.model, modelDecoration)) {\n        continue;\n      }\n      const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n      const viewRange = viewModelDecoration.range;\n      decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n      if (decorationOptions.inlineClassName) {\n        const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n        const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n        const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n        for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n          inlineDecorations[j - startLineNumber].push(inlineDecoration);\n        }\n      }\n      if (decorationOptions.beforeContentClassName) {\n        if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n          const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* InlineDecorationType.Before */);\n          inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n        }\n      }\n      if (decorationOptions.afterContentClassName) {\n        if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n          const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* InlineDecorationType.After */);\n          inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n        }\n      }\n    }\n    return {\n      decorations: decorationsInViewport,\n      inlineDecorations: inlineDecorations\n    };\n  }\n}\nexport function isModelDecorationVisible(model, decoration) {\n  if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n    return false;\n  }\n  if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n    return false;\n  }\n  return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n  return testTokensInRange(model, decoration.range, tokenType => tokenType === 1 /* StandardTokenType.Comment */);\n}\n\nexport function isModelDecorationInString(model, decoration) {\n  return testTokensInRange(model, decoration.range, tokenType => tokenType === 2 /* StandardTokenType.String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n  for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const isFirstLine = lineNumber === range.startLineNumber;\n    const isEndLine = lineNumber === range.endLineNumber;\n    let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n    while (tokenIdx < lineTokens.getCount()) {\n      if (isEndLine) {\n        const startOffset = lineTokens.getStartOffset(tokenIdx);\n        if (startOffset > range.endColumn - 1) {\n          break;\n        }\n      }\n      const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n      if (!callbackResult) {\n        return false;\n      }\n      tokenIdx++;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["Position","Range","InlineDecoration","ViewModelDecoration","filterValidationDecorations","ViewModelDecorations","constructor","editorId","model","configuration","linesCollection","coordinatesConverter","_linesCollection","_coordinatesConverter","_decorationsCache","Object","create","_cachedModelDecorationsResolver","_cachedModelDecorationsResolverViewRange","_clearCachedModelDecorationsResolver","dispose","reset","onModelDecorationsChanged","onLineMappingChanged","_getOrCreateViewModelDecoration","modelDecoration","id","r","modelRange","range","options","viewRange","isWholeLine","start","convertModelPositionToViewPosition","startLineNumber","end","endLineNumber","getLineMaxColumn","lineNumber","column","convertModelRangeToViewRange","getDecorationsViewportData","cacheIsValid","equalsRange","_getDecorationsInRange","getInlineDecorationsOnLine","getViewLineMinColumn","getViewLineMaxColumn","inlineDecorations","modelDecorations","getDecorationsInRange","decorationsInViewport","decorationsInViewportLen","j","i","len","length","decorationOptions","isModelDecorationVisible","viewModelDecoration","inlineClassName","inlineDecoration","inlineClassNameAffectsLetterSpacing","intersectedStartLineNumber","Math","max","intersectedEndLineNumber","min","push","beforeContentClassName","startColumn","afterContentClassName","endColumn","decorations","decoration","hideInCommentTokens","isModelDecorationInComment","hideInStringTokens","isModelDecorationInString","testTokensInRange","tokenType","callback","lineTokens","tokenization","getLineTokens","isFirstLine","isEndLine","tokenIdx","findTokenIndexAtOffset","getCount","startOffset","getStartOffset","callbackResult","getStandardTokenType"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from '../viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* PositionAffinity.Left */);\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* PositionAffinity.Right */);\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                // For backwards compatibility reasons, we want injected text before any decoration.\n                // Thus, move decorations to the right.\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* PositionAffinity.Right */);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsInRange(viewRange);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    getInlineDecorationsOnLine(lineNumber) {\n        const range = new Range(lineNumber, this._linesCollection.getViewLineMinColumn(lineNumber), lineNumber, this._linesCollection.getViewLineMaxColumn(lineNumber));\n        return this._getDecorationsInRange(range).inlineDecorations[0];\n    }\n    _getDecorationsInRange(viewRange) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewRange, this.editorId, filterValidationDecorations(this.configuration.options));\n        const startLineNumber = viewRange.startLineNumber;\n        const endLineNumber = viewRange.endLineNumber;\n        const decorationsInViewport = [];\n        let decorationsInViewportLen = 0;\n        const inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            const modelDecoration = modelDecorations[i];\n            const decorationOptions = modelDecoration.options;\n            if (!isModelDecorationVisible(this.model, modelDecoration)) {\n                continue;\n            }\n            const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            const viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n                const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* InlineDecorationType.Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* InlineDecorationType.After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\nexport function isModelDecorationVisible(model, decoration) {\n    if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n        return false;\n    }\n    if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n        return false;\n    }\n    return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 1 /* StandardTokenType.Comment */);\n}\nexport function isModelDecorationInString(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 2 /* StandardTokenType.String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        const lineTokens = model.tokenization.getLineTokens(lineNumber);\n        const isFirstLine = lineNumber === range.startLineNumber;\n        const isEndLine = lineNumber === range.endLineNumber;\n        let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n        while (tokenIdx < lineTokens.getCount()) {\n            if (isEndLine) {\n                const startOffset = lineTokens.getStartOffset(tokenIdx);\n                if (startOffset > range.endColumn - 1) {\n                    break;\n                }\n            }\n            const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n            if (!callbackResult) {\n                return false;\n            }\n            tokenIdx++;\n        }\n    }\n    return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}