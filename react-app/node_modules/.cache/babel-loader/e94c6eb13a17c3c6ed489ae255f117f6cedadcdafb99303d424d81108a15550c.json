{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */;\n}\n\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254 /* Constants.ColorMaskInverse */ | color << 0 /* Constants.ColorOffset */;\n}\n\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */ === 1;\n}\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253 /* Constants.IsVisitedMaskInverse */ | (value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */;\n}\n\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */ === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251 /* Constants.IsForValidationMaskInverse */ | (value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */;\n}\n\nfunction getNodeStickiness(node) {\n  return (node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */;\n}\n\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 231 /* Constants.StickinessMaskInverse */ | stickiness << 3 /* Constants.StickinessOffset */;\n}\n\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */ === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */ | (value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */;\n}\n\nexport class IntervalNode {\n  constructor(id, start, end) {\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1 /* NodeColor.Red */);\n    this.start = start;\n    this.end = end;\n    // FORCE_OVERFLOWING_TEST: this.delta = start;\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n    _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n  reset(versionId, start, end, range) {\n    this.start = start;\n    this.end = end;\n    this.maxEnd = end;\n    this.cachedVersionId = versionId;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = range;\n  }\n  setOptions(options) {\n    this.options = options;\n    const className = this.options.className;\n    setNodeIsForValidation(this, className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */ || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */ || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */);\n    _setNodeStickiness(this, this.options.stickiness);\n    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n  }\n  setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n    if (this.cachedVersionId !== cachedVersionId) {\n      this.range = null;\n    }\n    this.cachedVersionId = cachedVersionId;\n    this.cachedAbsoluteStart = absoluteStart;\n    this.cachedAbsoluteEnd = absoluteEnd;\n  }\n  detach() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n  constructor() {\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n  intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n  }\n  search(filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n    return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n  }\n  /**\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n   */\n  collectNodesFromOwner(ownerId) {\n    return collectNodesFromOwner(this, ownerId);\n  }\n  /**\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n   */\n  collectNodesPostOrder() {\n    return collectNodesPostOrder(this);\n  }\n  insert(node) {\n    rbTreeInsert(this, node);\n    this._normalizeDeltaIfNecessary();\n  }\n  delete(node) {\n    rbTreeDelete(this, node);\n    this._normalizeDeltaIfNecessary();\n  }\n  resolveNode(node, cachedVersionId) {\n    const initialNode = node;\n    let delta = 0;\n    while (node !== this.root) {\n      if (node === node.parent.right) {\n        delta += node.parent.delta;\n      }\n      node = node.parent;\n    }\n    const nodeStart = initialNode.start + delta;\n    const nodeEnd = initialNode.end + delta;\n    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n  }\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n    // (1) collect all nodes that are intersecting this edit as nodes of interest\n    const nodesOfInterest = searchForEditing(this, offset, offset + length);\n    // (2) remove all nodes that are intersecting this edit\n    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n      const node = nodesOfInterest[i];\n      rbTreeDelete(this, node);\n    }\n    this._normalizeDeltaIfNecessary();\n    // (3) edit all tree nodes except the nodes of interest\n    noOverlapReplace(this, offset, offset + length, textLength);\n    this._normalizeDeltaIfNecessary();\n    // (4) edit the nodes of interest and insert them back in the tree\n    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n      const node = nodesOfInterest[i];\n      node.start = node.cachedAbsoluteStart;\n      node.end = node.cachedAbsoluteEnd;\n      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);\n      node.maxEnd = node.end;\n      rbTreeInsert(this, node);\n    }\n    this._normalizeDeltaIfNecessary();\n  }\n  _normalizeDeltaIfNecessary() {\n    if (!this.requestNormalizeDelta) {\n      return;\n    }\n    this.requestNormalizeDelta = false;\n    normalizeDelta(this);\n  }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n  let node = T.root;\n  let delta = 0;\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true);\n    // going up from this node\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n    node = node.parent;\n  }\n  setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n  if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n    return false;\n  }\n  if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n    return true;\n  }\n  return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  const nodeStickiness = getNodeStickiness(node);\n  const startStickToPreviousCharacter = nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n  const endStickToPreviousCharacter = nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n  const deletingCnt = end - start;\n  const insertingCnt = textLength;\n  const commonLength = Math.min(deletingCnt, insertingCnt);\n  const nodeStart = node.start;\n  let startDone = false;\n  const nodeEnd = node.end;\n  let endDone = false;\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n  {\n    const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  if (commonLength > 0 && !forceMoveMarkers) {\n    const moveSemantics = deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  {\n    const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  }\n  // Finish\n  const deltaColumn = insertingCnt - deletingCnt;\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  const editDelta = textLength - (end - start);\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n      if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n      }\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n  let node = T.root;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction collectNodesPostOrder(T) {\n  let node = T.root;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n  let node = T.root;\n  let delta = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    let include = true;\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n    if (include) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      let include = true;\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0 /* NodeColor.Black */);\n    T.root = newNode;\n    return T.root;\n  }\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent);\n  // repair tree\n  let x = newNode;\n  while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n    if (x.parent === x.parent.parent.left) {\n      const y = x.parent.parent.right;\n      if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(y, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      const y = x.parent.parent.left;\n      if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(y, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n  setNodeColor(T.root, 0 /* NodeColor.Black */);\n  return newNode;\n}\nfunction treeInsert(T, z) {\n  let delta = 0;\n  let x = T.root;\n  const zAbsoluteStart = z.start;\n  const zAbsoluteEnd = z.end;\n  while (true) {\n    const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n  let x;\n  let y;\n  // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z;\n    // x's delta is no longer influenced by z's delta\n    x.delta += z.delta;\n    if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right;\n    // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n    if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n  }\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n  const yWasRed = getNodeColor(y) === 1 /* NodeColor.Red */;\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n  z.detach();\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n    resetSentinel();\n    return;\n  }\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  }\n  // RB-DELETE-FIXUP\n  let w;\n  while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n      if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n        setNodeColor(w, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent, 1 /* NodeColor.Red */);\n        leftRotate(T, x.parent);\n        w = x.parent.right;\n      }\n      if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n        setNodeColor(w, 1 /* NodeColor.Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n          setNodeColor(w.left, 0 /* NodeColor.Black */);\n          setNodeColor(w, 1 /* NodeColor.Red */);\n          rightRotate(T, w);\n          w = x.parent.right;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(w.right, 0 /* NodeColor.Black */);\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n      if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n        setNodeColor(w, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent, 1 /* NodeColor.Red */);\n        rightRotate(T, x.parent);\n        w = x.parent.left;\n      }\n      if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n        setNodeColor(w, 1 /* NodeColor.Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n          setNodeColor(w.right, 0 /* NodeColor.Black */);\n          setNodeColor(w, 1 /* NodeColor.Red */);\n          leftRotate(T, w);\n          w = x.parent.left;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(w.left, 0 /* NodeColor.Black */);\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n  setNodeColor(x, 0 /* NodeColor.Black */);\n  resetSentinel();\n}\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n  return node;\n}\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n  SENTINEL.start = 0; // optional\n  SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n  const y = x.right; // set y.\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n  if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n  y.parent = x.parent; // link x's parent to y.\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n  y.left = x; // put x on y's left.\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n  const x = y.left;\n  y.delta -= x.delta;\n  if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n  x.parent = y.parent;\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n  let maxEnd = node.end;\n  if (node.left !== SENTINEL) {\n    const leftMaxEnd = node.left.maxEnd;\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n  if (node.right !== SENTINEL) {\n    const rightMaxEnd = node.right.maxEnd + node.delta;\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n  return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    const maxEnd = computeMaxEnd(node);\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n  return aStart - bStart;\n}\n//#endregion","map":{"version":3,"names":["getNodeColor","node","metadata","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeIsForValidation","setNodeIsForValidation","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","constructor","id","start","end","parent","left","right","delta","maxEnd","ownerId","options","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","range","reset","versionId","setOptions","className","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","filterOutValidation","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","delete","rbTreeDelete","resolveNode","initialNode","nodeStart","nodeEnd","acceptReplace","offset","length","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","i","len","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","Math","min","startDone","endDone","deltaColumn","max","nodeMaxEnd","result","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","cmp","intervalCompare","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}