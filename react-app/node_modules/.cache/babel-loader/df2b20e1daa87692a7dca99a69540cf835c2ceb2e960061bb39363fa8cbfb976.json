{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete)/;\nexport class AbstractKeybindingService extends Disposable {\n  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n    super();\n    this._contextKeyService = _contextKeyService;\n    this._commandService = _commandService;\n    this._telemetryService = _telemetryService;\n    this._notificationService = _notificationService;\n    this._logService = _logService;\n    this._onDidUpdateKeybindings = this._register(new Emitter());\n    this._currentChord = null;\n    this._currentChordChecker = new IntervalTimer();\n    this._currentChordStatusMessage = null;\n    this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n    this._currentSingleModifier = null;\n    this._currentSingleModifierClearTimeout = new TimeoutTimer();\n    this._logging = false;\n  }\n  get onDidUpdateKeybindings() {\n    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n  }\n\n  dispose() {\n    super.dispose();\n  }\n  _log(str) {\n    if (this._logging) {\n      this._logService.info(`[KeybindingService]: ${str}`);\n    }\n  }\n  getKeybindings() {\n    return this._getResolver().getKeybindings();\n  }\n  lookupKeybinding(commandId, context) {\n    const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n    if (!result) {\n      return undefined;\n    }\n    return result.resolvedKeybinding;\n  }\n  dispatchEvent(e, target) {\n    return this._dispatch(e, target);\n  }\n  softDispatch(e, target) {\n    this._log(`/ Soft dispatching keyboard event`);\n    const keybinding = this.resolveKeyboardEvent(e);\n    if (keybinding.isChord()) {\n      console.warn('Unexpected keyboard event mapped to a chord');\n      return null;\n    }\n    const [firstPart] = keybinding.getDispatchParts();\n    if (firstPart === null) {\n      // cannot be dispatched, probably only modifier keys\n      this._log(`\\\\ Keyboard event cannot be dispatched`);\n      return null;\n    }\n    const contextValue = this._contextKeyService.getContext(target);\n    const currentChord = this._currentChord ? this._currentChord.keypress : null;\n    return this._getResolver().resolve(contextValue, currentChord, firstPart);\n  }\n  _enterChordMode(firstPart, keypressLabel) {\n    this._currentChord = {\n      keypress: firstPart,\n      label: keypressLabel\n    };\n    this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n    const chordEnterTime = Date.now();\n    this._currentChordChecker.cancelAndSet(() => {\n      if (!this._documentHasFocus()) {\n        // Focus has been lost => leave chord mode\n        this._leaveChordMode();\n        return;\n      }\n      if (Date.now() - chordEnterTime > 5000) {\n        // 5 seconds elapsed => leave chord mode\n        this._leaveChordMode();\n      }\n    }, 500);\n  }\n  _leaveChordMode() {\n    if (this._currentChordStatusMessage) {\n      this._currentChordStatusMessage.dispose();\n      this._currentChordStatusMessage = null;\n    }\n    this._currentChordChecker.cancel();\n    this._currentChord = null;\n  }\n  _dispatch(e, target) {\n    return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/false);\n  }\n  _singleModifierDispatch(e, target) {\n    const keybinding = this.resolveKeyboardEvent(e);\n    const [singleModifier] = keybinding.getSingleModifierDispatchParts();\n    if (singleModifier) {\n      if (this._ignoreSingleModifiers.has(singleModifier)) {\n        this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n      }\n      this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n      if (this._currentSingleModifier === null) {\n        // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n        this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n        this._currentSingleModifier = singleModifier;\n        this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n          this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n          this._currentSingleModifier = null;\n        }, 300);\n        return false;\n      }\n      if (singleModifier === this._currentSingleModifier) {\n        // bingo!\n        this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return this._doDispatch(keybinding, target, /*isSingleModiferChord*/true);\n      }\n      this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n      this._currentSingleModifierClearTimeout.cancel();\n      this._currentSingleModifier = null;\n      return false;\n    }\n    // When pressing a modifier and holding it pressed with any other modifier or key combination,\n    // the pressed modifiers should no longer be considered for single modifier dispatch.\n    const [firstPart] = keybinding.getParts();\n    this._ignoreSingleModifiers = new KeybindingModifierSet(firstPart);\n    if (this._currentSingleModifier !== null) {\n      this._log(`+ Clearing single modifier due to other key up.`);\n    }\n    this._currentSingleModifierClearTimeout.cancel();\n    this._currentSingleModifier = null;\n    return false;\n  }\n  _doDispatch(keybinding, target) {\n    let isSingleModiferChord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let shouldPreventDefault = false;\n    if (keybinding.isChord()) {\n      console.warn('Unexpected keyboard event mapped to a chord');\n      return false;\n    }\n    let firstPart = null; // the first keybinding i.e. Ctrl+K\n    let currentChord = null; // the \"second\" keybinding i.e. Ctrl+K \"Ctrl+D\"\n    if (isSingleModiferChord) {\n      const [dispatchKeyname] = keybinding.getSingleModifierDispatchParts();\n      firstPart = dispatchKeyname;\n      currentChord = dispatchKeyname;\n    } else {\n      [firstPart] = keybinding.getDispatchParts();\n      currentChord = this._currentChord ? this._currentChord.keypress : null;\n    }\n    if (firstPart === null) {\n      this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`);\n      // cannot be dispatched, probably only modifier keys\n      return shouldPreventDefault;\n    }\n    const contextValue = this._contextKeyService.getContext(target);\n    const keypressLabel = keybinding.getLabel();\n    const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n    this._logService.trace('KeybindingService#dispatch', keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);\n    if (resolveResult && resolveResult.enterChord) {\n      shouldPreventDefault = true;\n      this._enterChordMode(firstPart, keypressLabel);\n      this._log(`+ Entering chord mode...`);\n      return shouldPreventDefault;\n    }\n    if (this._currentChord) {\n      if (!resolveResult || !resolveResult.commandId) {\n        this._log(`+ Leaving chord mode: Nothing bound to \"${this._currentChord.label} ${keypressLabel}\".`);\n        this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), {\n          hideAfter: 10 * 1000 /* 10s */\n        });\n        shouldPreventDefault = true;\n      }\n    }\n    this._leaveChordMode();\n    if (resolveResult && resolveResult.commandId) {\n      if (!resolveResult.bubble) {\n        shouldPreventDefault = true;\n      }\n      this._log(`+ Invoking command ${resolveResult.commandId}.`);\n      if (typeof resolveResult.commandArgs === 'undefined') {\n        this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n      } else {\n        this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n      }\n      if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n        this._telemetryService.publicLog2('workbenchActionExecuted', {\n          id: resolveResult.commandId,\n          from: 'keybinding'\n        });\n      }\n    }\n    return shouldPreventDefault;\n  }\n  mightProducePrintableCharacter(event) {\n    if (event.ctrlKey || event.metaKey) {\n      // ignore ctrl/cmd-combination but not shift/alt-combinatios\n      return false;\n    }\n    // weak check for certain ranges. this is properly implemented in a subclass\n    // with access to the KeyboardMapperFactory.\n    if (event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */ || event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */) {\n      return true;\n    }\n    return false;\n  }\n}\nclass KeybindingModifierSet {\n  constructor(source) {\n    this._ctrlKey = source ? source.ctrlKey : false;\n    this._shiftKey = source ? source.shiftKey : false;\n    this._altKey = source ? source.altKey : false;\n    this._metaKey = source ? source.metaKey : false;\n  }\n  has(modifier) {\n    switch (modifier) {\n      case 'ctrl':\n        return this._ctrlKey;\n      case 'shift':\n        return this._shiftKey;\n      case 'alt':\n        return this._altKey;\n      case 'meta':\n        return this._metaKey;\n    }\n  }\n}\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);","map":{"version":3,"names":["IntervalTimer","TimeoutTimer","Emitter","Event","Disposable","nls","HIGH_FREQ_COMMANDS","AbstractKeybindingService","constructor","_contextKeyService","_commandService","_telemetryService","_notificationService","_logService","_onDidUpdateKeybindings","_register","_currentChord","_currentChordChecker","_currentChordStatusMessage","_ignoreSingleModifiers","KeybindingModifierSet","EMPTY","_currentSingleModifier","_currentSingleModifierClearTimeout","_logging","onDidUpdateKeybindings","event","None","dispose","_log","str","info","getKeybindings","_getResolver","lookupKeybinding","commandId","context","result","lookupPrimaryKeybinding","undefined","resolvedKeybinding","dispatchEvent","e","target","_dispatch","softDispatch","keybinding","resolveKeyboardEvent","isChord","console","warn","firstPart","getDispatchParts","contextValue","getContext","currentChord","keypress","resolve","_enterChordMode","keypressLabel","label","status","localize","chordEnterTime","Date","now","cancelAndSet","_documentHasFocus","_leaveChordMode","cancel","_doDispatch","_singleModifierDispatch","singleModifier","getSingleModifierDispatchParts","has","getParts","isSingleModiferChord","shouldPreventDefault","dispatchKeyname","getLabel","resolveResult","trace","enterChord","hideAfter","bubble","commandArgs","executeCommand","then","err","test","publicLog2","id","from","mightProducePrintableCharacter","ctrlKey","metaKey","keyCode","source","_ctrlKey","_shiftKey","shiftKey","_altKey","altKey","_metaKey","modifier"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete)/;\nexport class AbstractKeybindingService extends Disposable {\n    constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._commandService = _commandService;\n        this._telemetryService = _telemetryService;\n        this._notificationService = _notificationService;\n        this._logService = _logService;\n        this._onDidUpdateKeybindings = this._register(new Emitter());\n        this._currentChord = null;\n        this._currentChordChecker = new IntervalTimer();\n        this._currentChordStatusMessage = null;\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        this._currentSingleModifier = null;\n        this._currentSingleModifierClearTimeout = new TimeoutTimer();\n        this._logging = false;\n    }\n    get onDidUpdateKeybindings() {\n        return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n    }\n    dispose() {\n        super.dispose();\n    }\n    _log(str) {\n        if (this._logging) {\n            this._logService.info(`[KeybindingService]: ${str}`);\n        }\n    }\n    getKeybindings() {\n        return this._getResolver().getKeybindings();\n    }\n    lookupKeybinding(commandId, context) {\n        const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n        if (!result) {\n            return undefined;\n        }\n        return result.resolvedKeybinding;\n    }\n    dispatchEvent(e, target) {\n        return this._dispatch(e, target);\n    }\n    softDispatch(e, target) {\n        this._log(`/ Soft dispatching keyboard event`);\n        const keybinding = this.resolveKeyboardEvent(e);\n        if (keybinding.isChord()) {\n            console.warn('Unexpected keyboard event mapped to a chord');\n            return null;\n        }\n        const [firstPart,] = keybinding.getDispatchParts();\n        if (firstPart === null) {\n            // cannot be dispatched, probably only modifier keys\n            this._log(`\\\\ Keyboard event cannot be dispatched`);\n            return null;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const currentChord = this._currentChord ? this._currentChord.keypress : null;\n        return this._getResolver().resolve(contextValue, currentChord, firstPart);\n    }\n    _enterChordMode(firstPart, keypressLabel) {\n        this._currentChord = {\n            keypress: firstPart,\n            label: keypressLabel\n        };\n        this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n        const chordEnterTime = Date.now();\n        this._currentChordChecker.cancelAndSet(() => {\n            if (!this._documentHasFocus()) {\n                // Focus has been lost => leave chord mode\n                this._leaveChordMode();\n                return;\n            }\n            if (Date.now() - chordEnterTime > 5000) {\n                // 5 seconds elapsed => leave chord mode\n                this._leaveChordMode();\n            }\n        }, 500);\n    }\n    _leaveChordMode() {\n        if (this._currentChordStatusMessage) {\n            this._currentChordStatusMessage.dispose();\n            this._currentChordStatusMessage = null;\n        }\n        this._currentChordChecker.cancel();\n        this._currentChord = null;\n    }\n    _dispatch(e, target) {\n        return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/ false);\n    }\n    _singleModifierDispatch(e, target) {\n        const keybinding = this.resolveKeyboardEvent(e);\n        const [singleModifier,] = keybinding.getSingleModifierDispatchParts();\n        if (singleModifier) {\n            if (this._ignoreSingleModifiers.has(singleModifier)) {\n                this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n                this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return false;\n            }\n            this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n            if (this._currentSingleModifier === null) {\n                // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n                this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n                this._currentSingleModifier = singleModifier;\n                this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n                    this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n                    this._currentSingleModifier = null;\n                }, 300);\n                return false;\n            }\n            if (singleModifier === this._currentSingleModifier) {\n                // bingo!\n                this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return this._doDispatch(keybinding, target, /*isSingleModiferChord*/ true);\n            }\n            this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n            this._currentSingleModifierClearTimeout.cancel();\n            this._currentSingleModifier = null;\n            return false;\n        }\n        // When pressing a modifier and holding it pressed with any other modifier or key combination,\n        // the pressed modifiers should no longer be considered for single modifier dispatch.\n        const [firstPart,] = keybinding.getParts();\n        this._ignoreSingleModifiers = new KeybindingModifierSet(firstPart);\n        if (this._currentSingleModifier !== null) {\n            this._log(`+ Clearing single modifier due to other key up.`);\n        }\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n    }\n    _doDispatch(keybinding, target, isSingleModiferChord = false) {\n        let shouldPreventDefault = false;\n        if (keybinding.isChord()) {\n            console.warn('Unexpected keyboard event mapped to a chord');\n            return false;\n        }\n        let firstPart = null; // the first keybinding i.e. Ctrl+K\n        let currentChord = null; // the \"second\" keybinding i.e. Ctrl+K \"Ctrl+D\"\n        if (isSingleModiferChord) {\n            const [dispatchKeyname,] = keybinding.getSingleModifierDispatchParts();\n            firstPart = dispatchKeyname;\n            currentChord = dispatchKeyname;\n        }\n        else {\n            [firstPart,] = keybinding.getDispatchParts();\n            currentChord = this._currentChord ? this._currentChord.keypress : null;\n        }\n        if (firstPart === null) {\n            this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`);\n            // cannot be dispatched, probably only modifier keys\n            return shouldPreventDefault;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const keypressLabel = keybinding.getLabel();\n        const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n        this._logService.trace('KeybindingService#dispatch', keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);\n        if (resolveResult && resolveResult.enterChord) {\n            shouldPreventDefault = true;\n            this._enterChordMode(firstPart, keypressLabel);\n            this._log(`+ Entering chord mode...`);\n            return shouldPreventDefault;\n        }\n        if (this._currentChord) {\n            if (!resolveResult || !resolveResult.commandId) {\n                this._log(`+ Leaving chord mode: Nothing bound to \"${this._currentChord.label} ${keypressLabel}\".`);\n                this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\n                shouldPreventDefault = true;\n            }\n        }\n        this._leaveChordMode();\n        if (resolveResult && resolveResult.commandId) {\n            if (!resolveResult.bubble) {\n                shouldPreventDefault = true;\n            }\n            this._log(`+ Invoking command ${resolveResult.commandId}.`);\n            if (typeof resolveResult.commandArgs === 'undefined') {\n                this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n            }\n            else {\n                this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n            }\n            if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n                this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding' });\n            }\n        }\n        return shouldPreventDefault;\n    }\n    mightProducePrintableCharacter(event) {\n        if (event.ctrlKey || event.metaKey) {\n            // ignore ctrl/cmd-combination but not shift/alt-combinatios\n            return false;\n        }\n        // weak check for certain ranges. this is properly implemented in a subclass\n        // with access to the KeyboardMapperFactory.\n        if ((event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */)\n            || (event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */)) {\n            return true;\n        }\n        return false;\n    }\n}\nclass KeybindingModifierSet {\n    constructor(source) {\n        this._ctrlKey = source ? source.ctrlKey : false;\n        this._shiftKey = source ? source.shiftKey : false;\n        this._altKey = source ? source.altKey : false;\n        this._metaKey = source ? source.metaKey : false;\n    }\n    has(modifier) {\n        switch (modifier) {\n            case 'ctrl': return this._ctrlKey;\n            case 'shift': return this._shiftKey;\n            case 'alt': return this._altKey;\n            case 'meta': return this._metaKey;\n        }\n    }\n}\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}