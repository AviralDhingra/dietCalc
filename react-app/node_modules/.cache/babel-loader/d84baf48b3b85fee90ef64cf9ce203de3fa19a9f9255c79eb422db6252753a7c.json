{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\n// TRACING\nconst _enableTracing = false;\nclass CyclicDependencyError extends Error {\n  constructor(graph) {\n    var _a;\n    super('cyclic dependency between services');\n    this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n  }\n}\nexport class InstantiationService {\n  constructor() {\n    let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ServiceCollection();\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let parent = arguments.length > 2 ? arguments[2] : undefined;\n    this._activeInstantiations = new Set();\n    this._services = services;\n    this._strict = strict;\n    this._parent = parent;\n    this._services.set(IInstantiationService, this);\n  }\n  createChild(services) {\n    return new InstantiationService(services, this._strict, this);\n  }\n  invokeFunction(fn) {\n    const _trace = Trace.traceInvocation(fn);\n    let _done = false;\n    try {\n      const accessor = {\n        get: id => {\n          if (_done) {\n            throw illegalState('service accessor is only valid during the invocation of its target method');\n          }\n          const result = this._getOrCreateServiceInstance(id, _trace);\n          if (!result) {\n            throw new Error(`[invokeFunction] unknown service '${id}'`);\n          }\n          return result;\n        }\n      };\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return fn(accessor, ...args);\n    } finally {\n      _done = true;\n      _trace.stop();\n    }\n  }\n  createInstance(ctorOrDescriptor) {\n    let _trace;\n    let result;\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      rest[_key2 - 1] = arguments[_key2];\n    }\n    if (ctorOrDescriptor instanceof SyncDescriptor) {\n      _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n    } else {\n      _trace = Trace.traceCreation(ctorOrDescriptor);\n      result = this._createInstance(ctorOrDescriptor, rest, _trace);\n    }\n    _trace.stop();\n    return result;\n  }\n  _createInstance(ctor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let _trace = arguments.length > 2 ? arguments[2] : undefined;\n    // arguments defined by service decorators\n    const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n    const serviceArgs = [];\n    for (const dependency of serviceDependencies) {\n      const service = this._getOrCreateServiceInstance(dependency.id, _trace);\n      if (!service) {\n        this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n      }\n      serviceArgs.push(service);\n    }\n    const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n    // check for argument mismatches, adjust static args if needed\n    if (args.length !== firstServiceArgPos) {\n      console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n      const delta = firstServiceArgPos - args.length;\n      if (delta > 0) {\n        args = args.concat(new Array(delta));\n      } else {\n        args = args.slice(0, firstServiceArgPos);\n      }\n    }\n    // now create the instance\n    return new ctor(...[...args, ...serviceArgs]);\n  }\n  _setServiceInstance(id, instance) {\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      this._services.set(id, instance);\n    } else if (this._parent) {\n      this._parent._setServiceInstance(id, instance);\n    } else {\n      throw new Error('illegalState - setting UNKNOWN service instance');\n    }\n  }\n  _getServiceInstanceOrDescriptor(id) {\n    const instanceOrDesc = this._services.get(id);\n    if (!instanceOrDesc && this._parent) {\n      return this._parent._getServiceInstanceOrDescriptor(id);\n    } else {\n      return instanceOrDesc;\n    }\n  }\n  _getOrCreateServiceInstance(id, _trace) {\n    const thing = this._getServiceInstanceOrDescriptor(id);\n    if (thing instanceof SyncDescriptor) {\n      return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n    } else {\n      _trace.branch(id, false);\n      return thing;\n    }\n  }\n  _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n    if (this._activeInstantiations.has(id)) {\n      throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n    }\n    this._activeInstantiations.add(id);\n    try {\n      return this._createAndCacheServiceInstance(id, desc, _trace);\n    } finally {\n      this._activeInstantiations.delete(id);\n    }\n  }\n  _createAndCacheServiceInstance(id, desc, _trace) {\n    const graph = new Graph(data => data.id.toString());\n    let cycleCount = 0;\n    const stack = [{\n      id,\n      desc,\n      _trace\n    }];\n    while (stack.length) {\n      const item = stack.pop();\n      graph.lookupOrInsertNode(item);\n      // a weak but working heuristic for cycle checks\n      if (cycleCount++ > 1000) {\n        throw new CyclicDependencyError(graph);\n      }\n      // check all dependencies for existence and if they need to be created first\n      for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n        const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n        if (!instanceOrDesc) {\n          this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n        }\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          const d = {\n            id: dependency.id,\n            desc: instanceOrDesc,\n            _trace: item._trace.branch(dependency.id, true)\n          };\n          graph.insertEdge(item, d);\n          stack.push(d);\n        }\n      }\n    }\n    while (true) {\n      const roots = graph.roots();\n      // if there is no more roots but still\n      // nodes in the graph we have a cycle\n      if (roots.length === 0) {\n        if (!graph.isEmpty()) {\n          throw new CyclicDependencyError(graph);\n        }\n        break;\n      }\n      for (const {\n        data\n      } of roots) {\n        // Repeat the check for this still being a service sync descriptor. That's because\n        // instantiating a dependency might have side-effect and recursively trigger instantiation\n        // so that some dependencies are now fullfilled already.\n        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          // create instance and overwrite the service collections\n          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n          this._setServiceInstance(data.id, instance);\n        }\n        graph.removeNode(data);\n      }\n    }\n    return this._getServiceInstanceOrDescriptor(id);\n  }\n  _createServiceInstanceWithOwner(id, ctor) {\n    let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let supportsDelayedInstantiation = arguments.length > 3 ? arguments[3] : undefined;\n    let _trace = arguments.length > 4 ? arguments[4] : undefined;\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n    } else if (this._parent) {\n      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n    } else {\n      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n    }\n  }\n  _createServiceInstance(ctor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let _supportsDelayedInstantiation = arguments.length > 2 ? arguments[2] : undefined;\n    let _trace = arguments.length > 3 ? arguments[3] : undefined;\n    if (!_supportsDelayedInstantiation) {\n      // eager instantiation\n      return this._createInstance(ctor, args, _trace);\n    } else {\n      // Return a proxy object that's backed by an idle value. That\n      // strategy is to instantiate services in our idle time or when actually\n      // needed but not when injected into a consumer\n      const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n      return new Proxy(Object.create(null), {\n        get(target, key) {\n          if (key in target) {\n            return target[key];\n          }\n          const obj = idle.value;\n          let prop = obj[key];\n          if (typeof prop !== 'function') {\n            return prop;\n          }\n          prop = prop.bind(obj);\n          target[key] = prop;\n          return prop;\n        },\n        set(_target, p, value) {\n          idle.value[p] = value;\n          return true;\n        }\n      });\n    }\n  }\n  _throwIfStrict(msg, printWarning) {\n    if (printWarning) {\n      console.warn(msg);\n    }\n    if (this._strict) {\n      throw new Error(msg);\n    }\n  }\n}\nexport class Trace {\n  constructor(type, name) {\n    this.type = type;\n    this.name = name;\n    this._start = Date.now();\n    this._dep = [];\n  }\n  static traceInvocation(ctor) {\n    return !_enableTracing ? Trace._None : new Trace(1 /* TraceType.Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n  }\n  static traceCreation(ctor) {\n    return !_enableTracing ? Trace._None : new Trace(0 /* TraceType.Creation */, ctor.name);\n  }\n  branch(id, first) {\n    const child = new Trace(2 /* TraceType.Branch */, id.toString());\n    this._dep.push([id, first, child]);\n    return child;\n  }\n  stop() {\n    const dur = Date.now() - this._start;\n    Trace._totals += dur;\n    let causedCreation = false;\n    function printChild(n, trace) {\n      const res = [];\n      const prefix = new Array(n + 1).join('\\t');\n      for (const [id, first, child] of trace._dep) {\n        if (first && child) {\n          causedCreation = true;\n          res.push(`${prefix}CREATES -> ${id}`);\n          const nested = printChild(n + 1, child);\n          if (nested) {\n            res.push(nested);\n          }\n        } else {\n          res.push(`${prefix}uses -> ${id}`);\n        }\n      }\n      return res.join('\\n');\n    }\n    const lines = [`${this.type === 0 /* TraceType.Creation */ ? 'CREATE' : 'CALL'} ${this.name}`, `${printChild(1, this)}`, `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`];\n    if (dur > 2 || causedCreation) {\n      console.log(lines.join('\\n'));\n    }\n  }\n}\nTrace._None = new class extends Trace {\n  constructor() {\n    super(-1, null);\n  }\n  stop() {}\n  branch() {\n    return this;\n  }\n}();\nTrace._totals = 0;\n//#endregion","map":{"version":3,"names":["IdleValue","illegalState","SyncDescriptor","Graph","IInstantiationService","_util","ServiceCollection","_enableTracing","CyclicDependencyError","Error","constructor","graph","_a","message","findCycleSlow","toString","InstantiationService","services","strict","parent","_activeInstantiations","Set","_services","_strict","_parent","set","createChild","invokeFunction","fn","_trace","Trace","traceInvocation","_done","accessor","get","id","result","_getOrCreateServiceInstance","args","stop","createInstance","ctorOrDescriptor","rest","traceCreation","ctor","_createInstance","staticArguments","concat","serviceDependencies","getServiceDependencies","sort","a","b","index","serviceArgs","dependency","service","_throwIfStrict","name","push","firstServiceArgPos","length","console","trace","delta","Array","slice","_setServiceInstance","instance","_getServiceInstanceOrDescriptor","instanceOrDesc","thing","_safeCreateAndCacheServiceInstance","branch","desc","has","add","_createAndCacheServiceInstance","delete","data","cycleCount","stack","item","pop","lookupOrInsertNode","d","insertEdge","roots","isEmpty","_createServiceInstanceWithOwner","supportsDelayedInstantiation","removeNode","_createServiceInstance","_supportsDelayedInstantiation","idle","Proxy","Object","create","target","key","obj","value","prop","bind","_target","p","msg","printWarning","warn","type","_start","Date","now","_dep","_None","substring","replace","first","child","dur","_totals","causedCreation","printChild","n","res","prefix","join","nested","lines","toFixed","log"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\n// TRACING\nconst _enableTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        var _a;\n        super('cyclic dependency between services');\n        this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n    }\n}\nexport class InstantiationService {\n    constructor(services = new ServiceCollection(), strict = false, parent) {\n        this._activeInstantiations = new Set();\n        this._services = services;\n        this._strict = strict;\n        this._parent = parent;\n        this._services.set(IInstantiationService, this);\n    }\n    createChild(services) {\n        return new InstantiationService(services, this._strict, this);\n    }\n    invokeFunction(fn, ...args) {\n        const _trace = Trace.traceInvocation(fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result) {\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        // arguments defined by service decorators\n        const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        const serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            const service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service) {\n                this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n            }\n            serviceArgs.push(service);\n        }\n        const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            const delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return new ctor(...[...args, ...serviceArgs]);\n    }\n    _setServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        const instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        const thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (this._activeInstantiations.has(id)) {\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        const graph = new Graph(data => data.id.toString());\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        while (stack.length) {\n            const item = stack.pop();\n            graph.lookupOrInsertNode(item);\n            // a weak but working heuristic for cycle checks\n            if (cycleCount++ > 1000) {\n                throw new CyclicDependencyError(graph);\n            }\n            // check all dependencies for existence and if they need to be created first\n            for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc) {\n                    this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n                }\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw new CyclicDependencyError(graph);\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                // Repeat the check for this still being a service sync descriptor. That's because\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\n                // so that some dependencies are now fullfilled already.\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n        }\n    }\n    _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\n        if (!_supportsDelayedInstantiation) {\n            // eager instantiation\n            return this._createInstance(ctor, args, _trace);\n        }\n        else {\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n            return new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (key in target) {\n                        return target[key];\n                    }\n                    const obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                }\n            });\n        }\n    }\n    _throwIfStrict(msg, printWarning) {\n        if (printWarning) {\n            console.warn(msg);\n        }\n        if (this._strict) {\n            throw new Error(msg);\n        }\n    }\n}\nexport class Trace {\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    static traceInvocation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(1 /* TraceType.Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n    }\n    static traceCreation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(0 /* TraceType.Creation */, ctor.name);\n    }\n    branch(id, first) {\n        const child = new Trace(2 /* TraceType.Branch */, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        const dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            const res = [];\n            const prefix = new Array(n + 1).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    const nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        const lines = [\n            `${this.type === 0 /* TraceType.Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            console.log(lines.join('\\n'));\n        }\n    }\n}\nTrace._None = new class extends Trace {\n    constructor() { super(-1, null); }\n    stop() { }\n    branch() { return this; }\n};\nTrace._totals = 0;\n//#endregion\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}