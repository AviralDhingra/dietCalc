{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n  if (!_utf16LE_TextDecoder) {\n    _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n  }\n  return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n  if (!_utf16BE_TextDecoder) {\n    _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n  }\n  return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n  if (!_platformTextDecoder) {\n    _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n  }\n  return _platformTextDecoder;\n}\nexport const hasTextDecoder = typeof TextDecoder !== 'undefined';\nexport let createStringBuilder;\nexport let decodeUTF16LE;\nif (hasTextDecoder) {\n  createStringBuilder = capacity => new StringBuilder(capacity);\n  decodeUTF16LE = standardDecodeUTF16LE;\n} else {\n  createStringBuilder = capacity => new CompatStringBuilder();\n  decodeUTF16LE = compatDecodeUTF16LE;\n}\nfunction standardDecodeUTF16LE(source, offset, len) {\n  const view = new Uint16Array(source.buffer, offset, len);\n  if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n    // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n    // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n    // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n    // So we use the manual decoder\n    return compatDecodeUTF16LE(source, offset, len);\n  }\n  return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n  const result = [];\n  let resultLen = 0;\n  for (let i = 0; i < len; i++) {\n    const charCode = buffer.readUInt16LE(source, offset);\n    offset += 2;\n    result[resultLen++] = String.fromCharCode(charCode);\n  }\n  return result.join('');\n}\nclass StringBuilder {\n  constructor(capacity) {\n    this._capacity = capacity | 0;\n    this._buffer = new Uint16Array(this._capacity);\n    this._completedStrings = null;\n    this._bufferLength = 0;\n  }\n  reset() {\n    this._completedStrings = null;\n    this._bufferLength = 0;\n  }\n  build() {\n    if (this._completedStrings !== null) {\n      this._flushBuffer();\n      return this._completedStrings.join('');\n    }\n    return this._buildBuffer();\n  }\n  _buildBuffer() {\n    if (this._bufferLength === 0) {\n      return '';\n    }\n    const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n    return getPlatformTextDecoder().decode(view);\n  }\n  _flushBuffer() {\n    const bufferString = this._buildBuffer();\n    this._bufferLength = 0;\n    if (this._completedStrings === null) {\n      this._completedStrings = [bufferString];\n    } else {\n      this._completedStrings[this._completedStrings.length] = bufferString;\n    }\n  }\n  write1(charCode) {\n    const remainingSpace = this._capacity - this._bufferLength;\n    if (remainingSpace <= 1) {\n      if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n        this._flushBuffer();\n      }\n    }\n    this._buffer[this._bufferLength++] = charCode;\n  }\n  appendASCII(charCode) {\n    if (this._bufferLength === this._capacity) {\n      // buffer is full\n      this._flushBuffer();\n    }\n    this._buffer[this._bufferLength++] = charCode;\n  }\n  appendASCIIString(str) {\n    const strLen = str.length;\n    if (this._bufferLength + strLen >= this._capacity) {\n      // This string does not fit in the remaining buffer space\n      this._flushBuffer();\n      this._completedStrings[this._completedStrings.length] = str;\n      return;\n    }\n    for (let i = 0; i < strLen; i++) {\n      this._buffer[this._bufferLength++] = str.charCodeAt(i);\n    }\n  }\n}\nclass CompatStringBuilder {\n  constructor() {\n    this._pieces = [];\n    this._piecesLen = 0;\n  }\n  reset() {\n    this._pieces = [];\n    this._piecesLen = 0;\n  }\n  build() {\n    return this._pieces.join('');\n  }\n  write1(charCode) {\n    this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n  }\n  appendASCII(charCode) {\n    this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n  }\n  appendASCIIString(str) {\n    this._pieces[this._piecesLen++] = str;\n  }\n}","map":{"version":3,"names":["strings","platform","buffer","_utf16LE_TextDecoder","getUTF16LE_TextDecoder","TextDecoder","_utf16BE_TextDecoder","getUTF16BE_TextDecoder","_platformTextDecoder","getPlatformTextDecoder","isLittleEndian","hasTextDecoder","createStringBuilder","decodeUTF16LE","capacity","StringBuilder","standardDecodeUTF16LE","CompatStringBuilder","compatDecodeUTF16LE","source","offset","len","view","Uint16Array","decode","result","resultLen","i","charCode","readUInt16LE","String","fromCharCode","join","constructor","_capacity","_buffer","_completedStrings","_bufferLength","reset","build","_flushBuffer","_buildBuffer","bufferString","length","write1","remainingSpace","isHighSurrogate","appendASCII","appendASCIIString","str","strLen","charCodeAt","_pieces","_piecesLen"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport const hasTextDecoder = (typeof TextDecoder !== 'undefined');\nexport let createStringBuilder;\nexport let decodeUTF16LE;\nif (hasTextDecoder) {\n    createStringBuilder = (capacity) => new StringBuilder(capacity);\n    decodeUTF16LE = standardDecodeUTF16LE;\n}\nelse {\n    createStringBuilder = (capacity) => new CompatStringBuilder();\n    decodeUTF16LE = compatDecodeUTF16LE;\n}\nfunction standardDecodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nclass StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    write1(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCII(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCIIString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\nclass CompatStringBuilder {\n    constructor() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    reset() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    build() {\n        return this._pieces.join('');\n    }\n    write1(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCII(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCIIString(str) {\n        this._pieces[this._piecesLen++] = str;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}