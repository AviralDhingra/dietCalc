{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { combinedDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n  const builder = new PieceTreeTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n  const builder = new PieceTreeTextBufferBuilder();\n  let chunk;\n  while (typeof (chunk = snapshot.read()) === 'string') {\n    builder.acceptChunk(chunk);\n  }\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  let factory;\n  if (typeof value === 'string') {\n    factory = createTextBufferFactory(value);\n  } else if (model.isITextSnapshot(value)) {\n    factory = createTextBufferFactoryFromSnapshot(value);\n  } else {\n    factory = value;\n  }\n  return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n  constructor(source) {\n    this._source = source;\n    this._eos = false;\n  }\n  read() {\n    if (this._eos) {\n      return null;\n    }\n    const result = [];\n    let resultCnt = 0;\n    let resultLength = 0;\n    do {\n      const tmp = this._source.read();\n      if (tmp === null) {\n        // end-of-stream\n        this._eos = true;\n        if (resultCnt === 0) {\n          return null;\n        } else {\n          return result.join('');\n        }\n      }\n      if (tmp.length > 0) {\n        result[resultCnt++] = tmp;\n        resultLength += tmp.length;\n      }\n      if (resultLength >= 64 * 1024) {\n        return result.join('');\n      }\n    } while (true);\n  }\n}\nconst invalidFunc = () => {\n  throw new Error(`Invalid change accessor`);\n};\nlet TextModel = class TextModel extends Disposable {\n  constructor(source, languageId, creationOptions) {\n    let associatedResource = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let _undoRedoService = arguments.length > 4 ? arguments[4] : undefined;\n    let _languageService = arguments.length > 5 ? arguments[5] : undefined;\n    let _languageConfigurationService = arguments.length > 6 ? arguments[6] : undefined;\n    super();\n    this._undoRedoService = _undoRedoService;\n    this._languageService = _languageService;\n    this._languageConfigurationService = _languageConfigurationService;\n    //#region Events\n    this._onWillDispose = this._register(new Emitter());\n    this.onWillDispose = this._onWillDispose.event;\n    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n    this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n    this._onDidChangeOptions = this._register(new Emitter());\n    this.onDidChangeOptions = this._onDidChangeOptions.event;\n    this._onDidChangeAttached = this._register(new Emitter());\n    this.onDidChangeAttached = this._onDidChangeAttached.event;\n    this._onDidChangeInjectedText = this._register(new Emitter());\n    this._eventEmitter = this._register(new DidChangeContentEmitter());\n    this._deltaDecorationCallCnt = 0;\n    // Generate a new unique model id\n    MODEL_ID++;\n    this.id = '$model' + MODEL_ID;\n    this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      this._associatedResource = associatedResource;\n    }\n    this._attachedEditorCount = 0;\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(source, creationOptions.defaultEOL);\n    this._buffer = textBuffer;\n    this._bufferDisposable = disposable;\n    this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n    this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n    this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n    this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n    this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId);\n    const bufferLineCount = this._buffer.getLineCount();\n    const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n    // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n    if (creationOptions.largeFileOptimizations) {\n      this._isTooLargeForTokenization = bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD;\n    } else {\n      this._isTooLargeForTokenization = false;\n    }\n    this._isTooLargeForSyncing = bufferTextLength > TextModel.MODEL_SYNC_LIMIT;\n    this._versionId = 1;\n    this._alternativeVersionId = 1;\n    this._initialUndoRedoSnapshot = null;\n    this._isDisposed = false;\n    this.__isDisposing = false;\n    this._instanceId = strings.singleLetterHash(MODEL_ID);\n    this._lastDecorationId = 0;\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    this._commandManager = new EditStack(this, this._undoRedoService);\n    this._isUndoing = false;\n    this._isRedoing = false;\n    this._trimAutoWhitespaceLines = null;\n    this._register(this._decorationProvider.onDidChange(() => {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._onDidChangeDecorations.fire();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }));\n  }\n  static resolveOptions(textBuffer, options) {\n    if (options.detectIndentation) {\n      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n      return new model.TextModelResolvedOptions({\n        tabSize: guessedIndentation.tabSize,\n        indentSize: guessedIndentation.tabSize,\n        insertSpaces: guessedIndentation.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL,\n        bracketPairColorizationOptions: options.bracketPairColorizationOptions\n      });\n    }\n    return new model.TextModelResolvedOptions({\n      tabSize: options.tabSize,\n      indentSize: options.indentSize,\n      insertSpaces: options.insertSpaces,\n      trimAutoWhitespace: options.trimAutoWhitespace,\n      defaultEOL: options.defaultEOL,\n      bracketPairColorizationOptions: options.bracketPairColorizationOptions\n    });\n  }\n  get onDidChangeLanguage() {\n    return this._tokenizationTextModelPart.onDidChangeLanguage;\n  }\n  get onDidChangeLanguageConfiguration() {\n    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;\n  }\n  get onDidChangeTokens() {\n    return this._tokenizationTextModelPart.onDidChangeTokens;\n  }\n  onDidChangeContent(listener) {\n    return this._eventEmitter.slowEvent(e => listener(e.contentChangedEvent));\n  }\n  onDidChangeContentOrInjectedText(listener) {\n    return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n  }\n  _isDisposing() {\n    return this.__isDisposing;\n  }\n  get tokenization() {\n    return this._tokenizationTextModelPart;\n  }\n  get bracketPairs() {\n    return this._bracketPairs;\n  }\n  get guides() {\n    return this._guidesTextModelPart;\n  }\n  dispose() {\n    this.__isDisposing = true;\n    this._onWillDispose.fire();\n    this._tokenizationTextModelPart.dispose();\n    this._isDisposed = true;\n    super.dispose();\n    this._bufferDisposable.dispose();\n    this.__isDisposing = false;\n    // Manually release reference to previous text buffer to avoid large leaks\n    // in case someone leaks a TextModel reference\n    const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n    emptyDisposedTextBuffer.dispose();\n    this._buffer = emptyDisposedTextBuffer;\n    this._bufferDisposable = Disposable.None;\n  }\n  _assertNotDisposed() {\n    if (this._isDisposed) {\n      throw new Error('Model is disposed!');\n    }\n  }\n  _emitContentChangedEvent(rawChange, change) {\n    if (this.__isDisposing) {\n      // Do not confuse listeners by emitting any event after disposing\n      return;\n    }\n    this._tokenizationTextModelPart.handleDidChangeContent(change);\n    this._bracketPairs.handleDidChangeContent(change);\n    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n  }\n  setValue(value) {\n    this._assertNotDisposed();\n    if (value === null) {\n      // There's nothing to do\n      return;\n    }\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(value, this._options.defaultEOL);\n    this._setValueFromTextBuffer(textBuffer, disposable);\n  }\n  _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n    return {\n      changes: [{\n        range: range,\n        rangeOffset: rangeOffset,\n        rangeLength: rangeLength,\n        text: text\n      }],\n      eol: this._buffer.getEOL(),\n      versionId: this.getVersionId(),\n      isUndoing: isUndoing,\n      isRedoing: isRedoing,\n      isFlush: isFlush\n    };\n  }\n  _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n    this._assertNotDisposed();\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._buffer = textBuffer;\n    this._bufferDisposable.dispose();\n    this._bufferDisposable = textBufferDisposable;\n    this._increaseVersionId();\n    // Flush all tokens\n    this._tokenizationTextModelPart.flush();\n    // Destroy all my decorations\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    // Destroy my edit history and settings\n    this._commandManager.clear();\n    this._trimAutoWhitespaceLines = null;\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n  }\n  setEOL(eol) {\n    this._assertNotDisposed();\n    const newEOL = eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n';\n    if (this._buffer.getEOL() === newEOL) {\n      // Nothing to do\n      return;\n    }\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._onBeforeEOLChange();\n    this._buffer.setEOL(newEOL);\n    this._increaseVersionId();\n    this._onAfterEOLChange();\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n  }\n  _onBeforeEOLChange() {\n    // Ensure all decorations get their `range` set.\n    this._decorationsTree.ensureAllNodesHaveRanges(this);\n  }\n  _onAfterEOLChange() {\n    // Transform back `range` to offsets\n    const versionId = this.getVersionId();\n    const allDecorations = this._decorationsTree.collectNodesPostOrder();\n    for (let i = 0, len = allDecorations.length; i < len; i++) {\n      const node = allDecorations[i];\n      const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n      const delta = node.cachedAbsoluteStart - node.start;\n      const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n      const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n      node.cachedAbsoluteStart = startOffset;\n      node.cachedAbsoluteEnd = endOffset;\n      node.cachedVersionId = versionId;\n      node.start = startOffset - delta;\n      node.end = endOffset - delta;\n      recomputeMaxEnd(node);\n    }\n  }\n  onBeforeAttached() {\n    this._attachedEditorCount++;\n    if (this._attachedEditorCount === 1) {\n      this._tokenizationTextModelPart.handleDidChangeAttached();\n      this._onDidChangeAttached.fire(undefined);\n    }\n  }\n  onBeforeDetached() {\n    this._attachedEditorCount--;\n    if (this._attachedEditorCount === 0) {\n      this._tokenizationTextModelPart.handleDidChangeAttached();\n      this._onDidChangeAttached.fire(undefined);\n    }\n  }\n  isAttachedToEditor() {\n    return this._attachedEditorCount > 0;\n  }\n  getAttachedEditorCount() {\n    return this._attachedEditorCount;\n  }\n  isTooLargeForSyncing() {\n    return this._isTooLargeForSyncing;\n  }\n  isTooLargeForTokenization() {\n    return this._isTooLargeForTokenization;\n  }\n  isDisposed() {\n    return this._isDisposed;\n  }\n  isDominatedByLongLines() {\n    this._assertNotDisposed();\n    if (this.isTooLargeForTokenization()) {\n      // Cannot word wrap huge files anyways, so it doesn't really matter\n      return false;\n    }\n    let smallLineCharCount = 0;\n    let longLineCharCount = 0;\n    const lineCount = this._buffer.getLineCount();\n    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n      const lineLength = this._buffer.getLineLength(lineNumber);\n      if (lineLength >= LONG_LINE_BOUNDARY) {\n        longLineCharCount += lineLength;\n      } else {\n        smallLineCharCount += lineLength;\n      }\n    }\n    return longLineCharCount > smallLineCharCount;\n  }\n  get uri() {\n    return this._associatedResource;\n  }\n  //#region Options\n  getOptions() {\n    this._assertNotDisposed();\n    return this._options;\n  }\n  getFormattingOptions() {\n    return {\n      tabSize: this._options.indentSize,\n      insertSpaces: this._options.insertSpaces\n    };\n  }\n  updateOptions(_newOpts) {\n    this._assertNotDisposed();\n    const tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n    const indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.indentSize;\n    const insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n    const trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n    const bracketPairColorizationOptions = typeof _newOpts.bracketColorizationOptions !== 'undefined' ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n    const newOpts = new model.TextModelResolvedOptions({\n      tabSize: tabSize,\n      indentSize: indentSize,\n      insertSpaces: insertSpaces,\n      defaultEOL: this._options.defaultEOL,\n      trimAutoWhitespace: trimAutoWhitespace,\n      bracketPairColorizationOptions\n    });\n    if (this._options.equals(newOpts)) {\n      return;\n    }\n    const e = this._options.createChangeEvent(newOpts);\n    this._options = newOpts;\n    this._bracketPairs.handleDidChangeOptions(e);\n    this._decorationProvider.handleDidChangeOptions(e);\n    this._onDidChangeOptions.fire(e);\n  }\n  detectIndentation(defaultInsertSpaces, defaultTabSize) {\n    this._assertNotDisposed();\n    const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n    this.updateOptions({\n      insertSpaces: guessedIndentation.insertSpaces,\n      tabSize: guessedIndentation.tabSize,\n      indentSize: guessedIndentation.tabSize // TODO@Alex: guess indentSize independent of tabSize\n    });\n  }\n\n  normalizeIndentation(str) {\n    this._assertNotDisposed();\n    return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n  }\n  //#endregion\n  //#region Reading\n  getVersionId() {\n    this._assertNotDisposed();\n    return this._versionId;\n  }\n  mightContainRTL() {\n    return this._buffer.mightContainRTL();\n  }\n  mightContainUnusualLineTerminators() {\n    return this._buffer.mightContainUnusualLineTerminators();\n  }\n  removeUnusualLineTerminators() {\n    let selections = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n    this._buffer.resetMightContainUnusualLineTerminators();\n    this.pushEditOperations(selections, matches.map(m => ({\n      range: m.range,\n      text: null\n    })), () => null);\n  }\n  mightContainNonBasicASCII() {\n    return this._buffer.mightContainNonBasicASCII();\n  }\n  getAlternativeVersionId() {\n    this._assertNotDisposed();\n    return this._alternativeVersionId;\n  }\n  getInitialUndoRedoSnapshot() {\n    this._assertNotDisposed();\n    return this._initialUndoRedoSnapshot;\n  }\n  getOffsetAt(rawPosition) {\n    this._assertNotDisposed();\n    const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n    return this._buffer.getOffsetAt(position.lineNumber, position.column);\n  }\n  getPositionAt(rawOffset) {\n    this._assertNotDisposed();\n    const offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n    return this._buffer.getPositionAt(offset);\n  }\n  _increaseVersionId() {\n    this._versionId = this._versionId + 1;\n    this._alternativeVersionId = this._versionId;\n  }\n  _overwriteVersionId(versionId) {\n    this._versionId = versionId;\n  }\n  _overwriteAlternativeVersionId(newAlternativeVersionId) {\n    this._alternativeVersionId = newAlternativeVersionId;\n  }\n  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n  }\n  getValue(eol) {\n    let preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._assertNotDisposed();\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM() + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  createSnapshot() {\n    let preserveBOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n  }\n  getValueLength(eol) {\n    let preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._assertNotDisposed();\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM().length + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  getValueInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n  }\n  getValueLengthInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n  }\n  getCharacterCountInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n  }\n  getLineCount() {\n    this._assertNotDisposed();\n    return this._buffer.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineContent(lineNumber);\n  }\n  getLineLength(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber);\n  }\n  getLinesContent() {\n    this._assertNotDisposed();\n    return this._buffer.getLinesContent();\n  }\n  getEOL() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL();\n  }\n  getEndOfLineSequence() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */;\n  }\n\n  getLineMinColumn(lineNumber) {\n    this._assertNotDisposed();\n    return 1;\n  }\n  getLineMaxColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber) + 1;\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n  }\n  /**\n   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n   * Will try to not allocate if possible.\n   */\n  _validateRangeRelaxedNoAllocations(range) {\n    const linesCount = this._buffer.getLineCount();\n    const initialStartLineNumber = range.startLineNumber;\n    const initialStartColumn = range.startColumn;\n    let startLineNumber = Math.floor(typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber) ? initialStartLineNumber : 1);\n    let startColumn = Math.floor(typeof initialStartColumn === 'number' && !isNaN(initialStartColumn) ? initialStartColumn : 1);\n    if (startLineNumber < 1) {\n      startLineNumber = 1;\n      startColumn = 1;\n    } else if (startLineNumber > linesCount) {\n      startLineNumber = linesCount;\n      startColumn = this.getLineMaxColumn(startLineNumber);\n    } else {\n      if (startColumn <= 1) {\n        startColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(startLineNumber);\n        if (startColumn >= maxColumn) {\n          startColumn = maxColumn;\n        }\n      }\n    }\n    const initialEndLineNumber = range.endLineNumber;\n    const initialEndColumn = range.endColumn;\n    let endLineNumber = Math.floor(typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber) ? initialEndLineNumber : 1);\n    let endColumn = Math.floor(typeof initialEndColumn === 'number' && !isNaN(initialEndColumn) ? initialEndColumn : 1);\n    if (endLineNumber < 1) {\n      endLineNumber = 1;\n      endColumn = 1;\n    } else if (endLineNumber > linesCount) {\n      endLineNumber = linesCount;\n      endColumn = this.getLineMaxColumn(endLineNumber);\n    } else {\n      if (endColumn <= 1) {\n        endColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(endLineNumber);\n        if (endColumn >= maxColumn) {\n          endColumn = maxColumn;\n        }\n      }\n    }\n    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n      return range;\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  _isValidPosition(lineNumber, column, validationType) {\n    if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n      return false;\n    }\n    if (isNaN(lineNumber) || isNaN(column)) {\n      return false;\n    }\n    if (lineNumber < 1 || column < 1) {\n      return false;\n    }\n    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n      return false;\n    }\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber > lineCount) {\n      return false;\n    }\n    if (column === 1) {\n      return true;\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column > maxColumn) {\n      return false;\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _validatePosition(_lineNumber, _column, validationType) {\n    const lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n    const column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber < 1) {\n      return new Position(1, 1);\n    }\n    if (lineNumber > lineCount) {\n      return new Position(lineCount, this.getLineMaxColumn(lineCount));\n    }\n    if (column <= 1) {\n      return new Position(lineNumber, 1);\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column >= maxColumn) {\n      return new Position(lineNumber, maxColumn);\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      // If the position would end up in the middle of a high-low surrogate pair,\n      // we move it to before the pair\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return new Position(lineNumber, column - 1);\n      }\n    }\n    return new Position(lineNumber, column);\n  }\n  validatePosition(position) {\n    const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (position instanceof Position) {\n      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n        return position;\n      }\n    }\n    return this._validatePosition(position.lineNumber, position.column, validationType);\n  }\n  _isValidRange(range, validationType) {\n    const startLineNumber = range.startLineNumber;\n    const startColumn = range.startColumn;\n    const endLineNumber = range.endLineNumber;\n    const endColumn = range.endColumn;\n    if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n      return false;\n    }\n    if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n      return false;\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return true;\n      }\n      return false;\n    }\n    return true;\n  }\n  validateRange(_range) {\n    const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (_range instanceof Range && !(_range instanceof Selection)) {\n      if (this._isValidRange(_range, validationType)) {\n        return _range;\n      }\n    }\n    const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n    const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n    const startLineNumber = start.lineNumber;\n    const startColumn = start.column;\n    const endLineNumber = end.lineNumber;\n    const endColumn = end.column;\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      }\n      if (startLineNumber === endLineNumber && startColumn === endColumn) {\n        // do not expand a collapsed range, simply move it to a valid location\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n      }\n      if (startInsideSurrogatePair && endInsideSurrogatePair) {\n        // expand range at both ends\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n      }\n      if (startInsideSurrogatePair) {\n        // only expand range at the start\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n      }\n      // only expand range at the end\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  modifyPosition(rawPosition, offset) {\n    this._assertNotDisposed();\n    const candidate = this.getOffsetAt(rawPosition) + offset;\n    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n  }\n  getFullModelRange() {\n    this._assertNotDisposed();\n    const lineCount = this.getLineCount();\n    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n  }\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches) {\n    let limitResultCount = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : LIMIT_FIND_COUNT;\n    this._assertNotDisposed();\n    let searchRanges = null;\n    if (rawSearchScope !== null) {\n      if (!Array.isArray(rawSearchScope)) {\n        rawSearchScope = [rawSearchScope];\n      }\n      if (rawSearchScope.every(searchScope => Range.isIRange(searchScope))) {\n        searchRanges = rawSearchScope.map(searchScope => this.validateRange(searchScope));\n      }\n    }\n    if (searchRanges === null) {\n      searchRanges = [this.getFullModelRange()];\n    }\n    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n    const uniqueSearchRanges = [];\n    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n      if (Range.areIntersecting(prev, curr)) {\n        return prev.plusRange(curr);\n      }\n      uniqueSearchRanges.push(prev);\n      return curr;\n    }));\n    let matchMapper;\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      // not regex, not multi line\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return [];\n      }\n      matchMapper = searchRange => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    } else {\n      matchMapper = searchRange => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n    }\n    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n  }\n  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return null;\n      }\n      const lineCount = this.getLineCount();\n      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      return null;\n    }\n    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  //#endregion\n  //#region Editing\n  pushStackElement() {\n    this._commandManager.pushStackElement();\n  }\n  popStackElement() {\n    this._commandManager.popStackElement();\n  }\n  pushEOL(eol) {\n    const currentEOL = this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */;\n    if (currentEOL === eol) {\n      return;\n    }\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      if (this._initialUndoRedoSnapshot === null) {\n        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n      }\n      this._commandManager.pushEOL(eol);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _validateEditOperation(rawOperation) {\n    if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n      return rawOperation;\n    }\n    return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n  }\n  _validateEditOperations(rawOperations) {\n    const result = [];\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      result[i] = this._validateEditOperation(rawOperations[i]);\n    }\n    return result;\n  }\n  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n      // Go through each saved line number and insert a trim whitespace edit\n      // if it is safe to do so (no conflicts with other edits).\n      const incomingEdits = editOperations.map(op => {\n        return {\n          range: this.validateRange(op.range),\n          text: op.text\n        };\n      });\n      // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n      // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n      let editsAreNearCursors = true;\n      if (beforeCursorState) {\n        for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n          const sel = beforeCursorState[i];\n          let foundEditNearSel = false;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n            const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n            if (!selIsAbove && !selIsBelow) {\n              foundEditNearSel = true;\n              break;\n            }\n          }\n          if (!foundEditNearSel) {\n            editsAreNearCursors = false;\n            break;\n          }\n        }\n      }\n      if (editsAreNearCursors) {\n        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n          const trimLineNumber = this._trimAutoWhitespaceLines[i];\n          const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n          let allowTrimLine = true;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const editText = incomingEdits[j].text;\n            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n              // `trimLine` is completely outside this edit\n              continue;\n            }\n            // At this point:\n            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n              // This edit inserts a new line (and maybe other text) after `trimLine`\n              continue;\n            }\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n              // This edit inserts a new line (and maybe other text) before `trimLine`\n              continue;\n            }\n            // Looks like we can't trim this line as it would interfere with an incoming edit\n            allowTrimLine = false;\n            break;\n          }\n          if (allowTrimLine) {\n            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n            editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n          }\n        }\n      }\n      this._trimAutoWhitespaceLines = null;\n    }\n    if (this._initialUndoRedoSnapshot === null) {\n      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n    }\n    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n  }\n  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.newPosition);\n      const rangeEnd = this.getPositionAt(change.newEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.oldText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.oldPosition);\n      const rangeEnd = this.getPositionAt(change.oldEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.newText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      this._isUndoing = isUndoing;\n      this._isRedoing = isRedoing;\n      this.applyEdits(edits, false);\n      this.setEOL(eol);\n      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n    } finally {\n      this._isUndoing = false;\n      this._isRedoing = false;\n      this._eventEmitter.endDeferredEmit(resultingSelection);\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  applyEdits(rawOperations) {\n    let computeUndoEdits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      const operations = this._validateEditOperations(rawOperations);\n      return this._doApplyEdits(operations, computeUndoEdits);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _doApplyEdits(rawOperations, computeUndoEdits) {\n    const oldLineCount = this._buffer.getLineCount();\n    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n    const newLineCount = this._buffer.getLineCount();\n    const contentChanges = result.changes;\n    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n    if (contentChanges.length !== 0) {\n      // We do a first pass to update tokens and decorations\n      // because we want to read decorations in the second pass\n      // where we will emit content change events\n      // and we want to read the final decorations\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n        this._tokenizationTextModelPart.acceptEdit(change.range, change.text, eolCount, firstLineLength, lastLineLength);\n        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n      }\n      const rawContentChanges = [];\n      this._increaseVersionId();\n      let lineCount = oldLineCount;\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount] = countEOL(change.text);\n        this._onDidChangeDecorations.fire();\n        const startLineNumber = change.range.startLineNumber;\n        const endLineNumber = change.range.endLineNumber;\n        const deletingLinesCnt = endLineNumber - startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n        const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n        const firstEditLineNumber = currentEditStartLineNumber;\n        const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n        const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n        const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n        const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n        for (let j = editingLinesCnt; j >= 0; j--) {\n          const editLineNumber = startLineNumber + j;\n          const currentEditLineNumber = currentEditStartLineNumber + j;\n          injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n          const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n        }\n        if (editingLinesCnt < deletingLinesCnt) {\n          // Must delete some lines\n          const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n        }\n        if (editingLinesCnt < insertingLinesCnt) {\n          const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n          // Must insert some lines\n          const spliceLineNumber = startLineNumber + editingLinesCnt;\n          const cnt = insertingLinesCnt - editingLinesCnt;\n          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n          const injectedTexts = [];\n          const newLines = [];\n          for (let i = 0; i < cnt; i++) {\n            const lineNumber = fromLineNumber + i;\n            newLines[i] = this.getLineContent(lineNumber);\n            injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n            injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n          }\n          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n        }\n        lineCount += changeLineCountDelta;\n      }\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n        changes: contentChanges,\n        eol: this._buffer.getEOL(),\n        versionId: this.getVersionId(),\n        isUndoing: this._isUndoing,\n        isRedoing: this._isRedoing,\n        isFlush: false\n      });\n    }\n    return result.reverseEdits === null ? undefined : result.reverseEdits;\n  }\n  undo() {\n    return this._undoRedoService.undo(this.uri);\n  }\n  canUndo() {\n    return this._undoRedoService.canUndo(this.uri);\n  }\n  redo() {\n    return this._undoRedoService.redo(this.uri);\n  }\n  canRedo() {\n    return this._undoRedoService.canRedo(this.uri);\n  }\n  //#endregion\n  //#region Decorations\n  handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n    // This is called before the decoration changed event is fired.\n    if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n      return;\n    }\n    const affectedLines = Array.from(affectedInjectedTextLines);\n    const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n    this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n  }\n  changeDecorations(callback) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._changeDecorations(ownerId, callback);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _changeDecorations(ownerId, callback) {\n    const changeAccessor = {\n      addDecoration: (range, options) => {\n        return this._deltaDecorationsImpl(ownerId, [], [{\n          range: range,\n          options: options\n        }])[0];\n      },\n      changeDecoration: (id, newRange) => {\n        this._changeDecorationImpl(id, newRange);\n      },\n      changeDecorationOptions: (id, options) => {\n        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n      },\n      removeDecoration: id => {\n        this._deltaDecorationsImpl(ownerId, [id], []);\n      },\n      deltaDecorations: (oldDecorations, newDecorations) => {\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n          // nothing to do\n          return [];\n        }\n        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      }\n    };\n    let result = null;\n    try {\n      result = callback(changeAccessor);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n    // Invalidate change accessor\n    changeAccessor.addDecoration = invalidFunc;\n    changeAccessor.changeDecoration = invalidFunc;\n    changeAccessor.changeDecorationOptions = invalidFunc;\n    changeAccessor.removeDecoration = invalidFunc;\n    changeAccessor.deltaDecorations = invalidFunc;\n    return result;\n  }\n  deltaDecorations(oldDecorations, newDecorations) {\n    let ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._assertNotDisposed();\n    if (!oldDecorations) {\n      oldDecorations = [];\n    }\n    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n      // nothing to do\n      return [];\n    }\n    try {\n      this._deltaDecorationCallCnt++;\n      if (this._deltaDecorationCallCnt > 1) {\n        console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n        onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n      }\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n      this._deltaDecorationCallCnt--;\n    }\n  }\n  _getTrackedRange(id) {\n    return this.getDecorationRange(id);\n  }\n  _setTrackedRange(id, newRange, newStickiness) {\n    const node = id ? this._decorations[id] : null;\n    if (!node) {\n      if (!newRange) {\n        // node doesn't exist, the request is to delete => nothing to do\n        return null;\n      }\n      // node doesn't exist, the request is to set => add the tracked range\n      return this._deltaDecorationsImpl(0, [], [{\n        range: newRange,\n        options: TRACKED_RANGE_OPTIONS[newStickiness]\n      }])[0];\n    }\n    if (!newRange) {\n      // node exists, the request is to delete => delete node\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n      return null;\n    }\n    // node exists, the request is to set => change the tracked range and its options\n    const range = this._validateRangeRelaxedNoAllocations(newRange);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n    this._decorationsTree.insert(node);\n    return node.id;\n  }\n  removeAllDecorationsWithOwnerId(ownerId) {\n    if (this._isDisposed) {\n      return;\n    }\n    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      const node = nodes[i];\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n    }\n  }\n  getDecorationOptions(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return node.options;\n  }\n  getDecorationRange(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return this._decorationsTree.getNodeRange(this, node);\n  }\n  getLineDecorations(lineNumber) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      return [];\n    }\n    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n  }\n  getLinesDecorations(_startLineNumber, _endLineNumber) {\n    let ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let filterOutValidation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const lineCount = this.getLineCount();\n    const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n    const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n    const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n    pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n    return decorations;\n  }\n  getDecorationsInRange(range) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const validatedRange = this.validateRange(range);\n    const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n    pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n    return decorations;\n  }\n  getOverviewRulerDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n  }\n  getInjectedTextDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this._decorationsTree.getAllInjectedText(this, ownerId);\n  }\n  _getInjectedTextInLine(lineNumber) {\n    const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n    const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n    const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n    return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n  }\n  getAllDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n    result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n    return result;\n  }\n  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n    return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n  }\n  getRangeAt(start, end) {\n    return this._buffer.getRangeAt(start, end - start);\n  }\n  _changeDecorationImpl(decorationId, _range) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    if (node.options.after) {\n      const oldRange = this.getDecorationRange(decorationId);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n    }\n    if (node.options.before) {\n      const oldRange = this.getDecorationRange(decorationId);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n    }\n    const range = this._validateRangeRelaxedNoAllocations(_range);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    this._decorationsTree.insert(node);\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    if (node.options.after) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n    }\n    if (node.options.before) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n    }\n  }\n  _changeDecorationOptionsImpl(decorationId, options) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    this._onDidChangeDecorations.checkAffectedAndFire(options);\n    if (node.options.after || options.after) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n    }\n    if (node.options.before || options.before) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n    }\n    if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n      // Delete + Insert due to an overview ruler status change\n      this._decorationsTree.delete(node);\n      node.setOptions(options);\n      this._decorationsTree.insert(node);\n    } else {\n      node.setOptions(options);\n    }\n  }\n  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n    const versionId = this.getVersionId();\n    const oldDecorationsLen = oldDecorationsIds.length;\n    let oldDecorationIndex = 0;\n    const newDecorationsLen = newDecorations.length;\n    let newDecorationIndex = 0;\n    const result = new Array(newDecorationsLen);\n    while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n      let node = null;\n      if (oldDecorationIndex < oldDecorationsLen) {\n        // (1) get ourselves an old node\n        do {\n          node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n        } while (!node && oldDecorationIndex < oldDecorationsLen);\n        // (2) remove the node from the tree (if it exists)\n        if (node) {\n          if (node.options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n          }\n          if (node.options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n          }\n          this._decorationsTree.delete(node);\n          this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        }\n      }\n      if (newDecorationIndex < newDecorationsLen) {\n        // (3) create a new node if necessary\n        if (!node) {\n          const internalDecorationId = ++this._lastDecorationId;\n          const decorationId = `${this._instanceId};${internalDecorationId}`;\n          node = new IntervalNode(decorationId, 0, 0);\n          this._decorations[decorationId] = node;\n        }\n        // (4) initialize node\n        const newDecoration = newDecorations[newDecorationIndex];\n        const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n        const options = _normalizeOptions(newDecoration.options);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        node.ownerId = ownerId;\n        node.reset(versionId, startOffset, endOffset, range);\n        node.setOptions(options);\n        if (node.options.after) {\n          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        this._decorationsTree.insert(node);\n        result[newDecorationIndex] = node.id;\n        newDecorationIndex++;\n      } else {\n        if (node) {\n          delete this._decorations[node.id];\n        }\n      }\n    }\n    return result;\n  }\n  //#endregion\n  //#region Tokenization\n  // TODO move them to the tokenization part.\n  getLanguageId() {\n    return this.tokenization.getLanguageId();\n  }\n  setMode(languageId) {\n    this.tokenization.setLanguageId(languageId);\n  }\n  getLanguageIdAtPosition(lineNumber, column) {\n    return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n  }\n  getWordAtPosition(position) {\n    return this._tokenizationTextModelPart.getWordAtPosition(position);\n  }\n  getWordUntilPosition(position) {\n    return this._tokenizationTextModelPart.getWordUntilPosition(position);\n  }\n  //#endregion\n  normalizePosition(position, affinity) {\n    return position;\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n  getLineIndentColumn(lineNumber) {\n    // Columns start with 1.\n    return indentOfLine(this.getLineContent(lineNumber)) + 1;\n  }\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n  isForSimpleWidget: false,\n  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n  detectIndentation: false,\n  defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n  bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions\n};\nTextModel = __decorate([__param(4, IUndoRedoService), __param(5, ILanguageService), __param(6, ILanguageConfigurationService)], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n  let indent = 0;\n  for (const c of line) {\n    if (c === ' ' || c === '\\t') {\n      indent++;\n    } else {\n      break;\n    }\n  }\n  return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n  return node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n}\nfunction isNodeInjectedText(node) {\n  return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n  constructor() {\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n    this._injectedTextDecorationsTree = new IntervalTree();\n  }\n  ensureAllNodesHaveRanges(host) {\n    this.getAll(host, 0, false, false);\n  }\n  _ensureNodesHaveRanges(host, nodes) {\n    for (const node of nodes) {\n      if (node.range === null) {\n        node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n    }\n    return nodes;\n  }\n  getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n    const versionId = host.getVersionId();\n    const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n    return this._ensureNodesHaveRanges(host, result);\n  }\n  _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    return r0.concat(r1).concat(r2);\n  }\n  getInjectedTextInInterval(host, start, end, filterOwnerId) {\n    const versionId = host.getVersionId();\n    const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n  getAllInjectedText(host, filterOwnerId) {\n    const versionId = host.getVersionId();\n    const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n  getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n    const versionId = host.getVersionId();\n    const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n    return this._ensureNodesHaveRanges(host, result);\n  }\n  _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n    if (overviewRulerOnly) {\n      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n    } else {\n      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n      const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n      return r0.concat(r1).concat(r2);\n    }\n  }\n  collectNodesFromOwner(ownerId) {\n    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n    const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n    return r0.concat(r1).concat(r2);\n  }\n  collectNodesPostOrder() {\n    const r0 = this._decorationsTree0.collectNodesPostOrder();\n    const r1 = this._decorationsTree1.collectNodesPostOrder();\n    const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n    return r0.concat(r1).concat(r2);\n  }\n  insert(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.insert(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.insert(node);\n    } else {\n      this._decorationsTree0.insert(node);\n    }\n  }\n  delete(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.delete(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.delete(node);\n    } else {\n      this._decorationsTree0.delete(node);\n    }\n  }\n  getNodeRange(host, node) {\n    const versionId = host.getVersionId();\n    if (node.cachedVersionId !== versionId) {\n      this._resolveNode(node, versionId);\n    }\n    if (node.range === null) {\n      node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n    }\n    return node.range;\n  }\n  _resolveNode(node, cachedVersionId) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.resolveNode(node, cachedVersionId);\n    } else {\n      this._decorationsTree0.resolveNode(node, cachedVersionId);\n    }\n  }\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n  }\n}\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n  constructor(options) {\n    this.color = options.color || '';\n    this.darkColor = options.darkColor || '';\n  }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this._resolvedColor = null;\n    this.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = null;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return color;\n    }\n    const c = color ? theme.getColor(color.id) : null;\n    if (!c) {\n      return '';\n    }\n    return c.toString();\n  }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this.position = options.position;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = undefined;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return Color.fromHex(color);\n    }\n    return theme.getColor(color.id);\n  }\n}\nexport class ModelDecorationInjectedTextOptions {\n  constructor(options) {\n    this.content = options.content || '';\n    this.inlineClassName = options.inlineClassName || null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.attachedData = options.attachedData || null;\n    this.cursorStops = options.cursorStops || null;\n  }\n  static from(options) {\n    if (options instanceof ModelDecorationInjectedTextOptions) {\n      return options;\n    }\n    return new ModelDecorationInjectedTextOptions(options);\n  }\n}\nexport class ModelDecorationOptions {\n  constructor(options) {\n    var _a, _b;\n    this.description = options.description;\n    this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n    this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.hoverMessage = options.hoverMessage || null;\n    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n    this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n    this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n    this.hideInCommentTokens = (_a = options.hideInCommentTokens) !== null && _a !== void 0 ? _a : false;\n    this.hideInStringTokens = (_b = options.hideInStringTokens) !== null && _b !== void 0 ? _b : false;\n  }\n  static register(options) {\n    return new ModelDecorationOptions(options);\n  }\n  static createDynamic(options) {\n    return new ModelDecorationOptions(options);\n  }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({\n  description: 'empty'\n});\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  description: 'tracked-range-always-grows-when-typing-at-edges',\n  stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-never-grows-when-typing-at-edges',\n  stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-before',\n  stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-after',\n  stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */\n})];\n\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n  return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n  constructor(handleBeforeFire) {\n    super();\n    this.handleBeforeFire = handleBeforeFire;\n    this._actual = this._register(new Emitter());\n    this.event = this._actual.event;\n    this._affectedInjectedTextLines = null;\n    this._deferredCnt = 0;\n    this._shouldFire = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit() {\n    var _a;\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._shouldFire) {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n          affectsMinimap: this._affectsMinimap,\n          affectsOverviewRuler: this._affectsOverviewRuler\n        };\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._actual.fire(event);\n      }\n      (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n      this._affectedInjectedTextLines = null;\n    }\n  }\n  recordLineAffectedByInjectedText(lineNumber) {\n    if (!this._affectedInjectedTextLines) {\n      this._affectedInjectedTextLines = new Set();\n    }\n    this._affectedInjectedTextLines.add(lineNumber);\n  }\n  checkAffectedAndFire(options) {\n    if (!this._affectsMinimap) {\n      this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n    }\n    if (!this._affectsOverviewRuler) {\n      this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    }\n    this._shouldFire = true;\n  }\n  fire() {\n    this._affectsMinimap = true;\n    this._affectsOverviewRuler = true;\n    this._shouldFire = true;\n  }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n  constructor() {\n    super();\n    /**\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n     */\n    this._fastEmitter = this._register(new Emitter());\n    this.fastEvent = this._fastEmitter.event;\n    this._slowEmitter = this._register(new Emitter());\n    this.slowEvent = this._slowEmitter.event;\n    this._deferredCnt = 0;\n    this._deferredEvent = null;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit() {\n    let resultingSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._deferredEvent !== null) {\n        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n        const e = this._deferredEvent;\n        this._deferredEvent = null;\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n      }\n    }\n  }\n  fire(e) {\n    if (this._deferredCnt > 0) {\n      if (this._deferredEvent) {\n        this._deferredEvent = this._deferredEvent.merge(e);\n      } else {\n        this._deferredEvent = e;\n      }\n      return;\n    }\n    this._fastEmitter.fire(e);\n    this._slowEmitter.fire(e);\n  }\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ArrayQueue","pushMany","Color","onUnexpectedError","Emitter","combinedDisposable","Disposable","strings","URI","countEOL","normalizeIndentation","Position","Range","Selection","EDITOR_MODEL_DEFAULTS","ILanguageService","ILanguageConfigurationService","model","BracketPairsTextModelPart","ColorizedBracketPairsDecorationProvider","EditStack","GuidesTextModelPart","guessIndentation","IntervalNode","IntervalTree","recomputeMaxEnd","PieceTreeTextBuffer","PieceTreeTextBufferBuilder","SearchParams","TextModelSearch","TokenizationTextModelPart","InternalModelContentChangeEvent","LineInjectedText","ModelInjectedTextChangedEvent","ModelRawContentChangedEvent","ModelRawEOLChanged","ModelRawFlush","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","IUndoRedoService","createTextBufferFactory","text","builder","acceptChunk","finish","createTextBufferFactoryFromSnapshot","snapshot","chunk","read","createTextBuffer","value","defaultEOL","factory","isITextSnapshot","create","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","constructor","source","_source","_eos","result","resultCnt","resultLength","tmp","join","invalidFunc","Error","TextModel","languageId","creationOptions","associatedResource","_undoRedoService","_languageService","_languageConfigurationService","_onWillDispose","_register","onWillDispose","event","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_onDidChangeInjectedText","_eventEmitter","DidChangeContentEmitter","_deltaDecorationCallCnt","id","isForSimpleWidget","_associatedResource","parse","_attachedEditorCount","textBuffer","disposable","_buffer","_bufferDisposable","_options","resolveOptions","_bracketPairs","_guidesTextModelPart","_decorationProvider","_tokenizationTextModelPart","bufferLineCount","getLineCount","bufferTextLength","getValueLengthInRange","getLineLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposed","__isDisposing","_instanceId","singleLetterHash","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","onDidChange","beginDeferredEmit","fire","endDeferredEmit","options","detectIndentation","guessedIndentation","tabSize","insertSpaces","TextModelResolvedOptions","indentSize","trimAutoWhitespace","bracketPairColorizationOptions","onDidChangeLanguage","onDidChangeLanguageConfiguration","onDidChangeTokens","onDidChangeContent","listener","slowEvent","e","contentChangedEvent","onDidChangeContentOrInjectedText","fastEvent","_isDisposing","tokenization","bracketPairs","guides","dispose","emptyDisposedTextBuffer","None","_assertNotDisposed","_emitContentChangedEvent","rawChange","change","handleDidChangeContent","setValue","_setValueFromTextBuffer","_createContentChanged2","range","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","changes","eol","getEOL","versionId","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","endLineNumber","endColumn","getLineMaxColumn","_increaseVersionId","flush","clear","getValue","setEOL","newEOL","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","len","node","delta","cachedAbsoluteStart","start","startOffset","getOffsetAt","startLineNumber","startColumn","endOffset","cachedAbsoluteEnd","cachedVersionId","end","onBeforeAttached","handleDidChangeAttached","undefined","onBeforeDetached","isAttachedToEditor","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForTokenization","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineCount","lineNumber","lineLength","uri","getOptions","getFormattingOptions","updateOptions","_newOpts","bracketColorizationOptions","newOpts","equals","createChangeEvent","handleDidChangeOptions","defaultInsertSpaces","defaultTabSize","str","mightContainRTL","mightContainUnusualLineTerminators","removeUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","resetMightContainUnusualLineTerminators","pushEditOperations","map","m","mightContainNonBasicASCII","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","position","_validatePosition","column","getPositionAt","rawOffset","offset","Math","min","getLength","max","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","preserveBOM","fullModelRange","fullModelValue","getValueInRange","getBOM","createSnapshot","getValueLength","rawRange","validateRange","getCharacterCountInRange","getLineContent","getLinesContent","getEndOfLineSequence","getLineMinColumn","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","floor","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","getLineCharCode","isHighSurrogate","_lineNumber","_column","validatePosition","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","searchString","rawSearchScope","isRegex","matchCase","wordSeparators","searchRanges","Array","isArray","every","searchScope","isIRange","sort","d1","d2","uniqueSearchRanges","push","reduce","prev","curr","areIntersecting","plusRange","matchMapper","indexOf","searchParams","parseSearchRequest","arr","concat","findNextMatch","rawSearchStart","searchStart","ret","findPreviousMatch","pushStackElement","popStackElement","pushEOL","currentEOL","_validateEditOperation","rawOperation","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","_validateEditOperations","rawOperations","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","incomingEdits","op","editsAreNearCursors","sel","foundEditNearSel","j","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","charAt","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","rangeEnd","newEnd","oldText","_applyUndoRedoEdits","_applyRedo","oldPosition","oldEnd","newText","applyEdits","computeUndoEdits","operations","_doApplyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","eolCount","firstLineLength","lastLineLength","acceptEdit","acceptReplace","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","cnt","fromLineNumber","injectedTexts","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","size","affectedLines","from","lineChangeEvents","_getInjectedTextInLine","changeDecorations","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","delete","reset","setOptions","insert","removeAllDecorationsWithOwnerId","nodes","collectNodesFromOwner","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","decorations","_getDecorationsInRange","getDecorationsInRange","validatedRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","filter","t","getAllDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","nodeRange","oldDecorationsIds","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","getLanguageId","setMode","setLanguageId","getLanguageIdAtPosition","getWordAtPosition","getWordUntilPosition","normalizePosition","affinity","getLineIndentColumn","indentOfLine","DEFAULT_CREATION_OPTIONS","line","indent","isNodeInOverviewRuler","isNodeInjectedText","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","textLength","cleanClassName","className","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","getColor","theme","type","_resolveColor","invalidateCachedColor","toString","ModelDecorationMinimapOptions","fromHex","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","_a","_b","description","blockClassName","stickiness","zIndex","hoverMessage","glyphMarginHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","register","createDynamic","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFire","_affectsMinimap","_affectsOverviewRuler","affectsMinimap","affectsOverviewRuler","Set","add","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","merge"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { combinedDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    constructor(source, languageId, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._deltaDecorationCallCnt = 0;\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n    }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions({\n            tabSize: options.tabSize,\n            indentSize: options.indentSize,\n            insertSpaces: options.insertSpaces,\n            trimAutoWhitespace: options.trimAutoWhitespace,\n            defaultEOL: options.defaultEOL,\n            bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n        });\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null) {\n            // There's nothing to do\n            return;\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Flush all tokens\n        this._tokenizationTextModelPart.flush();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    onBeforeDetached() {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update tokens and decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n                this._tokenizationTextModelPart.acceptEdit(change.range, change.text, eolCount, firstLineLength, lastLineLength);\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        const result = new Array(newDecorationsLen);\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n            let node = null;\n            if (oldDecorationIndex < oldDecorationsLen) {\n                // (1) get ourselves an old node\n                do {\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\n                // (2) remove the node from the tree (if it exists)\n                if (node) {\n                    if (node.options.after) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                    }\n                    this._decorationsTree.delete(node);\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                }\n            }\n            if (newDecorationIndex < newDecorationsLen) {\n                // (3) create a new node if necessary\n                if (!node) {\n                    const internalDecorationId = (++this._lastDecorationId);\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\n                    node = new IntervalNode(decorationId, 0, 0);\n                    this._decorations[decorationId] = node;\n                }\n                // (4) initialize node\n                const newDecoration = newDecorations[newDecorationIndex];\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                const options = _normalizeOptions(newDecoration.options);\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                node.ownerId = ownerId;\n                node.reset(versionId, startOffset, endOffset, range);\n                node.setOptions(options);\n                if (node.options.after) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                }\n                if (node.options.before) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                }\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\n                this._decorationsTree.insert(node);\n                result[newDecorationIndex] = node.id;\n                newDecorationIndex++;\n            }\n            else {\n                if (node) {\n                    delete this._decorations[node.id];\n                }\n            }\n        }\n        return result;\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setMode(languageId) {\n        this.tokenization.setLanguageId(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n}\nexport class ModelDecorationOptions {\n    constructor(options) {\n        var _a, _b;\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_a = options.hideInCommentTokens) !== null && _a !== void 0 ? _a : false;\n        this.hideInStringTokens = (_b = options.hideInStringTokens) !== null && _b !== void 0 ? _b : false;\n    }\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFire) {\n                this.handleBeforeFire(this._affectedInjectedTextLines);\n                const event = {\n                    affectsMinimap: this._affectsMinimap,\n                    affectsOverviewRuler: this._affectsOverviewRuler\n                };\n                this._shouldFire = false;\n                this._affectsMinimap = false;\n                this._affectsOverviewRuler = false;\n                this._actual.fire(event);\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        this._shouldFire = true;\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._shouldFire = true;\n    }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,UAAU,GAAI,IAAI,IAAI,IAAI,CAACA,UAAU,IAAK,UAAUC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE;EACnF,IAAIC,CAAC,GAAGC,SAAS,CAACC,MAAM;IAAEC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGH,MAAM,GAAGE,IAAI,KAAK,IAAI,GAAGA,IAAI,GAAGK,MAAM,CAACC,wBAAwB,CAACR,MAAM,EAAEC,GAAG,CAAC,GAAGC,IAAI;IAAEO,CAAC;EAC5H,IAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAACC,QAAQ,KAAK,UAAU,EAAEL,CAAC,GAAGI,OAAO,CAACC,QAAQ,CAACZ,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,CAAC,CAAC,KAC1H,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAM,GAAG,CAAC,EAAEO,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAC,CAAC,EAAEN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACH,CAAC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACT,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,GAAGG,CAAC,CAACT,MAAM,EAAEC,GAAG,CAAC,KAAKK,CAAC;EACjJ,OAAOH,CAAC,GAAG,CAAC,IAAIG,CAAC,IAAIC,MAAM,CAACM,cAAc,CAACb,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,EAAEA,CAAC;AACjE,CAAC;AACD,IAAIQ,OAAO,GAAI,IAAI,IAAI,IAAI,CAACA,OAAO,IAAK,UAAUC,UAAU,EAAEC,SAAS,EAAE;EACrE,OAAO,UAAUhB,MAAM,EAAEC,GAAG,EAAE;IAAEe,SAAS,CAAChB,MAAM,EAAEC,GAAG,EAAEc,UAAU,CAAC;EAAE,CAAC;AACzE,CAAC;AACD,SAASE,UAAU,EAAEC,QAAQ,QAAQ,gCAAgC;AACrE,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,iBAAiB,QAAQ,gCAAgC;AAClE,SAASC,OAAO,QAAQ,+BAA+B;AACvD,SAASC,kBAAkB,EAAEC,UAAU,QAAQ,mCAAmC;AAClF,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,SAASC,GAAG,QAAQ,6BAA6B;AACjD,SAASC,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,oBAAoB,QAAQ,wBAAwB;AAC7D,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,SAAS,QAAQ,sBAAsB;AAChD,SAASC,qBAAqB,QAAQ,8BAA8B;AACpE,SAASC,gBAAgB,QAAQ,0BAA0B;AAC3D,SAASC,6BAA6B,QAAQ,+CAA+C;AAC7F,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,SAASC,yBAAyB,QAAQ,iDAAiD;AAC3F,SAASC,uCAAuC,QAAQ,wEAAwE;AAChI,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,SAASC,YAAY,EAAEC,YAAY,EAAEC,eAAe,QAAQ,mBAAmB;AAC/E,SAASC,mBAAmB,QAAQ,8CAA8C;AAClF,SAASC,0BAA0B,QAAQ,qDAAqD;AAChG,SAASC,YAAY,EAAEC,eAAe,QAAQ,sBAAsB;AACpE,SAASC,yBAAyB,QAAQ,gCAAgC;AAC1E,SAASC,+BAA+B,EAAEC,gBAAgB,EAAEC,6BAA6B,EAAEC,2BAA2B,EAAEC,kBAAkB,EAAEC,aAAa,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,qBAAqB,QAAQ,uBAAuB;AAC1P,SAASC,gBAAgB,QAAQ,+CAA+C;AAChF,OAAO,SAASC,uBAAuB,CAACC,IAAI,EAAE;EAC1C,MAAMC,OAAO,GAAG,IAAIhB,0BAA0B,EAAE;EAChDgB,OAAO,CAACC,WAAW,CAACF,IAAI,CAAC;EACzB,OAAOC,OAAO,CAACE,MAAM,EAAE;AAC3B;AACA,OAAO,SAASC,mCAAmC,CAACC,QAAQ,EAAE;EAC1D,MAAMJ,OAAO,GAAG,IAAIhB,0BAA0B,EAAE;EAChD,IAAIqB,KAAK;EACT,OAAO,QAAQA,KAAK,GAAGD,QAAQ,CAACE,IAAI,EAAE,CAAC,KAAK,QAAQ,EAAE;IAClDN,OAAO,CAACC,WAAW,CAACI,KAAK,CAAC;EAC9B;EACA,OAAOL,OAAO,CAACE,MAAM,EAAE;AAC3B;AACA,OAAO,SAASK,gBAAgB,CAACC,KAAK,EAAEC,UAAU,EAAE;EAChD,IAAIC,OAAO;EACX,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;IAC3BE,OAAO,GAAGZ,uBAAuB,CAACU,KAAK,CAAC;EAC5C,CAAC,MACI,IAAIlC,KAAK,CAACqC,eAAe,CAACH,KAAK,CAAC,EAAE;IACnCE,OAAO,GAAGP,mCAAmC,CAACK,KAAK,CAAC;EACxD,CAAC,MACI;IACDE,OAAO,GAAGF,KAAK;EACnB;EACA,OAAOE,OAAO,CAACE,MAAM,CAACH,UAAU,CAAC;AACrC;AACA,IAAII,QAAQ,GAAG,CAAC;AAChB,MAAMC,gBAAgB,GAAG,GAAG;AAC5B,OAAO,MAAMC,kBAAkB,GAAG,KAAK;AACvC,MAAMC,iBAAiB,CAAC;EACpBC,WAAW,CAACC,MAAM,EAAE;IAChB,IAAI,CAACC,OAAO,GAAGD,MAAM;IACrB,IAAI,CAACE,IAAI,GAAG,KAAK;EACrB;EACAd,IAAI,GAAG;IACH,IAAI,IAAI,CAACc,IAAI,EAAE;MACX,OAAO,IAAI;IACf;IACA,MAAMC,MAAM,GAAG,EAAE;IACjB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAIC,YAAY,GAAG,CAAC;IACpB,GAAG;MACC,MAAMC,GAAG,GAAG,IAAI,CAACL,OAAO,CAACb,IAAI,EAAE;MAC/B,IAAIkB,GAAG,KAAK,IAAI,EAAE;QACd;QACA,IAAI,CAACJ,IAAI,GAAG,IAAI;QAChB,IAAIE,SAAS,KAAK,CAAC,EAAE;UACjB,OAAO,IAAI;QACf,CAAC,MACI;UACD,OAAOD,MAAM,CAACI,IAAI,CAAC,EAAE,CAAC;QAC1B;MACJ;MACA,IAAID,GAAG,CAAC/E,MAAM,GAAG,CAAC,EAAE;QAChB4E,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGE,GAAG;QACzBD,YAAY,IAAIC,GAAG,CAAC/E,MAAM;MAC9B;MACA,IAAI8E,YAAY,IAAI,EAAE,GAAG,IAAI,EAAE;QAC3B,OAAOF,MAAM,CAACI,IAAI,CAAC,EAAE,CAAC;MAC1B;IACJ,CAAC,QAAQ,IAAI;EACjB;AACJ;AACA,MAAMC,WAAW,GAAG,MAAM;EAAE,MAAM,IAAIC,KAAK,CAAE,yBAAwB,CAAC;AAAE,CAAC;AACzE,IAAIC,SAAS,GAAG,MAAMA,SAAS,SAASjE,UAAU,CAAC;EAC/CsD,WAAW,CAACC,MAAM,EAAEW,UAAU,EAAEC,eAAe,EAAgG;IAAA,IAA9FC,kBAAkB,uEAAG,IAAI;IAAA,IAAEC,gBAAgB;IAAA,IAAEC,gBAAgB;IAAA,IAAEC,6BAA6B;IACzI,KAAK,EAAE;IACP,IAAI,CAACF,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,6BAA6B,GAAGA,6BAA6B;IAClE;IACA,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,SAAS,CAAC,IAAI3E,OAAO,EAAE,CAAC;IACnD,IAAI,CAAC4E,aAAa,GAAG,IAAI,CAACF,cAAc,CAACG,KAAK;IAC9C,IAAI,CAACC,uBAAuB,GAAG,IAAI,CAACH,SAAS,CAAC,IAAII,2BAA2B,CAACC,yBAAyB,IAAI,IAAI,CAACC,uCAAuC,CAACD,yBAAyB,CAAC,CAAC,CAAC;IACpL,IAAI,CAACE,sBAAsB,GAAG,IAAI,CAACJ,uBAAuB,CAACD,KAAK;IAChE,IAAI,CAACM,mBAAmB,GAAG,IAAI,CAACR,SAAS,CAAC,IAAI3E,OAAO,EAAE,CAAC;IACxD,IAAI,CAACoF,kBAAkB,GAAG,IAAI,CAACD,mBAAmB,CAACN,KAAK;IACxD,IAAI,CAACQ,oBAAoB,GAAG,IAAI,CAACV,SAAS,CAAC,IAAI3E,OAAO,EAAE,CAAC;IACzD,IAAI,CAACsF,mBAAmB,GAAG,IAAI,CAACD,oBAAoB,CAACR,KAAK;IAC1D,IAAI,CAACU,wBAAwB,GAAG,IAAI,CAACZ,SAAS,CAAC,IAAI3E,OAAO,EAAE,CAAC;IAC7D,IAAI,CAACwF,aAAa,GAAG,IAAI,CAACb,SAAS,CAAC,IAAIc,uBAAuB,EAAE,CAAC;IAClE,IAAI,CAACC,uBAAuB,GAAG,CAAC;IAChC;IACAtC,QAAQ,EAAE;IACV,IAAI,CAACuC,EAAE,GAAG,QAAQ,GAAGvC,QAAQ;IAC7B,IAAI,CAACwC,iBAAiB,GAAGvB,eAAe,CAACuB,iBAAiB;IAC1D,IAAI,OAAOtB,kBAAkB,KAAK,WAAW,IAAIA,kBAAkB,KAAK,IAAI,EAAE;MAC1E,IAAI,CAACuB,mBAAmB,GAAGzF,GAAG,CAAC0F,KAAK,CAAC,mBAAmB,GAAG1C,QAAQ,CAAC;IACxE,CAAC,MACI;MACD,IAAI,CAACyC,mBAAmB,GAAGvB,kBAAkB;IACjD;IACA,IAAI,CAACyB,oBAAoB,GAAG,CAAC;IAC7B,MAAM;MAAEC,UAAU;MAAEC;IAAW,CAAC,GAAGnD,gBAAgB,CAACW,MAAM,EAAEY,eAAe,CAACrB,UAAU,CAAC;IACvF,IAAI,CAACkD,OAAO,GAAGF,UAAU;IACzB,IAAI,CAACG,iBAAiB,GAAGF,UAAU;IACnC,IAAI,CAACG,QAAQ,GAAGjC,SAAS,CAACkC,cAAc,CAAC,IAAI,CAACH,OAAO,EAAE7B,eAAe,CAAC;IACvE,IAAI,CAACiC,aAAa,GAAG,IAAI,CAAC3B,SAAS,CAAC,IAAI7D,yBAAyB,CAAC,IAAI,EAAE,IAAI,CAAC2D,6BAA6B,CAAC,CAAC;IAC5G,IAAI,CAAC8B,oBAAoB,GAAG,IAAI,CAAC5B,SAAS,CAAC,IAAI1D,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAACwD,6BAA6B,CAAC,CAAC;IAC7G,IAAI,CAAC+B,mBAAmB,GAAG,IAAI,CAAC7B,SAAS,CAAC,IAAI5D,uCAAuC,CAAC,IAAI,CAAC,CAAC;IAC5F,IAAI,CAAC0F,0BAA0B,GAAG,IAAI/E,yBAAyB,CAAC,IAAI,CAAC8C,gBAAgB,EAAE,IAAI,CAACC,6BAA6B,EAAE,IAAI,EAAE,IAAI,CAAC6B,aAAa,EAAElC,UAAU,CAAC;IAChK,MAAMsC,eAAe,GAAG,IAAI,CAACR,OAAO,CAACS,YAAY,EAAE;IACnD,MAAMC,gBAAgB,GAAG,IAAI,CAACV,OAAO,CAACW,qBAAqB,CAAC,IAAIrG,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEkG,eAAe,EAAE,IAAI,CAACR,OAAO,CAACY,aAAa,CAACJ,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,4CAA4C;IAC7L;IACA;IACA;IACA,IAAIrC,eAAe,CAAC0C,sBAAsB,EAAE;MACxC,IAAI,CAACC,0BAA0B,GAAKJ,gBAAgB,GAAGzC,SAAS,CAAC8C,yBAAyB,IAClFP,eAAe,GAAGvC,SAAS,CAAC+C,+BAAiC;IACzE,CAAC,MACI;MACD,IAAI,CAACF,0BAA0B,GAAG,KAAK;IAC3C;IACA,IAAI,CAACG,qBAAqB,GAAIP,gBAAgB,GAAGzC,SAAS,CAACiD,gBAAiB;IAC5E,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,qBAAqB,GAAG,CAAC;IAC9B,IAAI,CAACC,wBAAwB,GAAG,IAAI;IACpC,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,WAAW,GAAGvH,OAAO,CAACwH,gBAAgB,CAACvE,QAAQ,CAAC;IACrD,IAAI,CAACwE,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,YAAY,GAAG3I,MAAM,CAACiE,MAAM,CAAC,IAAI,CAAC;IACvC,IAAI,CAAC2E,gBAAgB,GAAG,IAAIC,gBAAgB,EAAE;IAC9C,IAAI,CAACC,eAAe,GAAG,IAAIhH,SAAS,CAAC,IAAI,EAAE,IAAI,CAACuD,gBAAgB,CAAC;IACjE,IAAI,CAAC0D,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,wBAAwB,GAAG,IAAI;IACpC,IAAI,CAACxD,SAAS,CAAC,IAAI,CAAC6B,mBAAmB,CAAC4B,WAAW,CAAC,MAAM;MACtD,IAAI,CAACtD,uBAAuB,CAACuD,iBAAiB,EAAE;MAChD,IAAI,CAACvD,uBAAuB,CAACwD,IAAI,EAAE;MACnC,IAAI,CAACxD,uBAAuB,CAACyD,eAAe,EAAE;IAClD,CAAC,CAAC,CAAC;EACP;EACA,OAAOlC,cAAc,CAACL,UAAU,EAAEwC,OAAO,EAAE;IACvC,IAAIA,OAAO,CAACC,iBAAiB,EAAE;MAC3B,MAAMC,kBAAkB,GAAGxH,gBAAgB,CAAC8E,UAAU,EAAEwC,OAAO,CAACG,OAAO,EAAEH,OAAO,CAACI,YAAY,CAAC;MAC9F,OAAO,IAAI/H,KAAK,CAACgI,wBAAwB,CAAC;QACtCF,OAAO,EAAED,kBAAkB,CAACC,OAAO;QACnCG,UAAU,EAAEJ,kBAAkB,CAACC,OAAO;QACtCC,YAAY,EAAEF,kBAAkB,CAACE,YAAY;QAC7CG,kBAAkB,EAAEP,OAAO,CAACO,kBAAkB;QAC9C/F,UAAU,EAAEwF,OAAO,CAACxF,UAAU;QAC9BgG,8BAA8B,EAAER,OAAO,CAACQ;MAC5C,CAAC,CAAC;IACN;IACA,OAAO,IAAInI,KAAK,CAACgI,wBAAwB,CAAC;MACtCF,OAAO,EAAEH,OAAO,CAACG,OAAO;MACxBG,UAAU,EAAEN,OAAO,CAACM,UAAU;MAC9BF,YAAY,EAAEJ,OAAO,CAACI,YAAY;MAClCG,kBAAkB,EAAEP,OAAO,CAACO,kBAAkB;MAC9C/F,UAAU,EAAEwF,OAAO,CAACxF,UAAU;MAC9BgG,8BAA8B,EAAER,OAAO,CAACQ;IAC5C,CAAC,CAAC;EACN;EACA,IAAIC,mBAAmB,GAAG;IAAE,OAAO,IAAI,CAACxC,0BAA0B,CAACwC,mBAAmB;EAAE;EACxF,IAAIC,gCAAgC,GAAG;IAAE,OAAO,IAAI,CAACzC,0BAA0B,CAACyC,gCAAgC;EAAE;EAClH,IAAIC,iBAAiB,GAAG;IAAE,OAAO,IAAI,CAAC1C,0BAA0B,CAAC0C,iBAAiB;EAAE;EACpFC,kBAAkB,CAACC,QAAQ,EAAE;IACzB,OAAO,IAAI,CAAC7D,aAAa,CAAC8D,SAAS,CAAEC,CAAC,IAAKF,QAAQ,CAACE,CAAC,CAACC,mBAAmB,CAAC,CAAC;EAC/E;EACAC,gCAAgC,CAACJ,QAAQ,EAAE;IACvC,OAAOpJ,kBAAkB,CAAC,IAAI,CAACuF,aAAa,CAACkE,SAAS,CAACH,CAAC,IAAIF,QAAQ,CAACE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAChE,wBAAwB,CAACV,KAAK,CAAC0E,CAAC,IAAIF,QAAQ,CAACE,CAAC,CAAC,CAAC,CAAC;EACpI;EACAI,YAAY,GAAG;IAAE,OAAO,IAAI,CAAClC,aAAa;EAAE;EAC5C,IAAImC,YAAY,GAAG;IAAE,OAAO,IAAI,CAACnD,0BAA0B;EAAE;EAC7D,IAAIoD,YAAY,GAAG;IAAE,OAAO,IAAI,CAACvD,aAAa;EAAE;EAChD,IAAIwD,MAAM,GAAG;IAAE,OAAO,IAAI,CAACvD,oBAAoB;EAAE;EACjDwD,OAAO,GAAG;IACN,IAAI,CAACtC,aAAa,GAAG,IAAI;IACzB,IAAI,CAAC/C,cAAc,CAAC4D,IAAI,EAAE;IAC1B,IAAI,CAAC7B,0BAA0B,CAACsD,OAAO,EAAE;IACzC,IAAI,CAACvC,WAAW,GAAG,IAAI;IACvB,KAAK,CAACuC,OAAO,EAAE;IACf,IAAI,CAAC5D,iBAAiB,CAAC4D,OAAO,EAAE;IAChC,IAAI,CAACtC,aAAa,GAAG,KAAK;IAC1B;IACA;IACA,MAAMuC,uBAAuB,GAAG,IAAI1I,mBAAmB,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC;IAC/F0I,uBAAuB,CAACD,OAAO,EAAE;IACjC,IAAI,CAAC7D,OAAO,GAAG8D,uBAAuB;IACtC,IAAI,CAAC7D,iBAAiB,GAAGjG,UAAU,CAAC+J,IAAI;EAC5C;EACAC,kBAAkB,GAAG;IACjB,IAAI,IAAI,CAAC1C,WAAW,EAAE;MAClB,MAAM,IAAItD,KAAK,CAAC,oBAAoB,CAAC;IACzC;EACJ;EACAiG,wBAAwB,CAACC,SAAS,EAAEC,MAAM,EAAE;IACxC,IAAI,IAAI,CAAC5C,aAAa,EAAE;MACpB;MACA;IACJ;IACA,IAAI,CAAChB,0BAA0B,CAAC6D,sBAAsB,CAACD,MAAM,CAAC;IAC9D,IAAI,CAAC/D,aAAa,CAACgE,sBAAsB,CAACD,MAAM,CAAC;IACjD,IAAI,CAAC7E,aAAa,CAAC8C,IAAI,CAAC,IAAI3G,+BAA+B,CAACyI,SAAS,EAAEC,MAAM,CAAC,CAAC;EACnF;EACAE,QAAQ,CAACxH,KAAK,EAAE;IACZ,IAAI,CAACmH,kBAAkB,EAAE;IACzB,IAAInH,KAAK,KAAK,IAAI,EAAE;MAChB;MACA;IACJ;IACA,MAAM;MAAEiD,UAAU;MAAEC;IAAW,CAAC,GAAGnD,gBAAgB,CAACC,KAAK,EAAE,IAAI,CAACqD,QAAQ,CAACpD,UAAU,CAAC;IACpF,IAAI,CAACwH,uBAAuB,CAACxE,UAAU,EAAEC,UAAU,CAAC;EACxD;EACAwE,sBAAsB,CAACC,KAAK,EAAEC,WAAW,EAAEC,WAAW,EAAEtI,IAAI,EAAEuI,SAAS,EAAEC,SAAS,EAAEC,OAAO,EAAE;IACzF,OAAO;MACHC,OAAO,EAAE,CAAC;QACFN,KAAK,EAAEA,KAAK;QACZC,WAAW,EAAEA,WAAW;QACxBC,WAAW,EAAEA,WAAW;QACxBtI,IAAI,EAAEA;MACV,CAAC,CAAC;MACN2I,GAAG,EAAE,IAAI,CAAC/E,OAAO,CAACgF,MAAM,EAAE;MAC1BC,SAAS,EAAE,IAAI,CAACC,YAAY,EAAE;MAC9BP,SAAS,EAAEA,SAAS;MACpBC,SAAS,EAAEA,SAAS;MACpBC,OAAO,EAAEA;IACb,CAAC;EACL;EACAP,uBAAuB,CAACxE,UAAU,EAAEqF,oBAAoB,EAAE;IACtD,IAAI,CAACnB,kBAAkB,EAAE;IACzB,MAAMoB,iBAAiB,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAClD,MAAMC,mBAAmB,GAAG,IAAI,CAAC3E,qBAAqB,CAACyE,iBAAiB,CAAC;IACzE,MAAMG,aAAa,GAAG,IAAI,CAAC9E,YAAY,EAAE;IACzC,MAAM+E,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,aAAa,CAAC;IACtD,IAAI,CAACvF,OAAO,GAAGF,UAAU;IACzB,IAAI,CAACG,iBAAiB,CAAC4D,OAAO,EAAE;IAChC,IAAI,CAAC5D,iBAAiB,GAAGkF,oBAAoB;IAC7C,IAAI,CAACO,kBAAkB,EAAE;IACzB;IACA,IAAI,CAACnF,0BAA0B,CAACoF,KAAK,EAAE;IACvC;IACA,IAAI,CAAChE,YAAY,GAAG3I,MAAM,CAACiE,MAAM,CAAC,IAAI,CAAC;IACvC,IAAI,CAAC2E,gBAAgB,GAAG,IAAIC,gBAAgB,EAAE;IAC9C;IACA,IAAI,CAACC,eAAe,CAAC8D,KAAK,EAAE;IAC5B,IAAI,CAAC3D,wBAAwB,GAAG,IAAI;IACpC,IAAI,CAACgC,wBAAwB,CAAC,IAAIrI,2BAA2B,CAAC,CAC1D,IAAIE,aAAa,EAAE,CACtB,EAAE,IAAI,CAACqF,UAAU,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAACoD,sBAAsB,CAAC,IAAIjK,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEiL,aAAa,EAAEC,SAAS,CAAC,EAAE,CAAC,EAAEF,mBAAmB,EAAE,IAAI,CAACO,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;EAC3K;EACAC,MAAM,CAACf,GAAG,EAAE;IACR,IAAI,CAACf,kBAAkB,EAAE;IACzB,MAAM+B,MAAM,GAAIhB,GAAG,KAAK,CAAC,CAAC,qCAAqC,MAAM,GAAG,IAAK;IAC7E,IAAI,IAAI,CAAC/E,OAAO,CAACgF,MAAM,EAAE,KAAKe,MAAM,EAAE;MAClC;MACA;IACJ;IACA,MAAMX,iBAAiB,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAClD,MAAMC,mBAAmB,GAAG,IAAI,CAAC3E,qBAAqB,CAACyE,iBAAiB,CAAC;IACzE,MAAMG,aAAa,GAAG,IAAI,CAAC9E,YAAY,EAAE;IACzC,MAAM+E,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,aAAa,CAAC;IACtD,IAAI,CAACS,kBAAkB,EAAE;IACzB,IAAI,CAAChG,OAAO,CAAC8F,MAAM,CAACC,MAAM,CAAC;IAC3B,IAAI,CAACL,kBAAkB,EAAE;IACzB,IAAI,CAACO,iBAAiB,EAAE;IACxB,IAAI,CAAChC,wBAAwB,CAAC,IAAIrI,2BAA2B,CAAC,CAC1D,IAAIC,kBAAkB,EAAE,CAC3B,EAAE,IAAI,CAACsF,UAAU,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAACoD,sBAAsB,CAAC,IAAIjK,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEiL,aAAa,EAAEC,SAAS,CAAC,EAAE,CAAC,EAAEF,mBAAmB,EAAE,IAAI,CAACO,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;EAC5K;EACAG,kBAAkB,GAAG;IACjB;IACA,IAAI,CAACpE,gBAAgB,CAACsE,wBAAwB,CAAC,IAAI,CAAC;EACxD;EACAD,iBAAiB,GAAG;IAChB;IACA,MAAMhB,SAAS,GAAG,IAAI,CAACC,YAAY,EAAE;IACrC,MAAMiB,cAAc,GAAG,IAAI,CAACvE,gBAAgB,CAACwE,qBAAqB,EAAE;IACpE,KAAK,IAAI/M,CAAC,GAAG,CAAC,EAAEgN,GAAG,GAAGF,cAAc,CAACrN,MAAM,EAAEO,CAAC,GAAGgN,GAAG,EAAEhN,CAAC,EAAE,EAAE;MACvD,MAAMiN,IAAI,GAAGH,cAAc,CAAC9M,CAAC,CAAC;MAC9B,MAAMmL,KAAK,GAAG8B,IAAI,CAAC9B,KAAK,CAAC,CAAC;MAC1B,MAAM+B,KAAK,GAAGD,IAAI,CAACE,mBAAmB,GAAGF,IAAI,CAACG,KAAK;MACnD,MAAMC,WAAW,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW,CAACnC,KAAK,CAACoC,eAAe,EAAEpC,KAAK,CAACqC,WAAW,CAAC;MACtF,MAAMC,SAAS,GAAG,IAAI,CAAC9G,OAAO,CAAC2G,WAAW,CAACnC,KAAK,CAACe,aAAa,EAAEf,KAAK,CAACgB,SAAS,CAAC;MAChFc,IAAI,CAACE,mBAAmB,GAAGE,WAAW;MACtCJ,IAAI,CAACS,iBAAiB,GAAGD,SAAS;MAClCR,IAAI,CAACU,eAAe,GAAG/B,SAAS;MAChCqB,IAAI,CAACG,KAAK,GAAGC,WAAW,GAAGH,KAAK;MAChCD,IAAI,CAACW,GAAG,GAAGH,SAAS,GAAGP,KAAK;MAC5BpL,eAAe,CAACmL,IAAI,CAAC;IACzB;EACJ;EACAY,gBAAgB,GAAG;IACf,IAAI,CAACrH,oBAAoB,EAAE;IAC3B,IAAI,IAAI,CAACA,oBAAoB,KAAK,CAAC,EAAE;MACjC,IAAI,CAACU,0BAA0B,CAAC4G,uBAAuB,EAAE;MACzD,IAAI,CAAChI,oBAAoB,CAACiD,IAAI,CAACgF,SAAS,CAAC;IAC7C;EACJ;EACAC,gBAAgB,GAAG;IACf,IAAI,CAACxH,oBAAoB,EAAE;IAC3B,IAAI,IAAI,CAACA,oBAAoB,KAAK,CAAC,EAAE;MACjC,IAAI,CAACU,0BAA0B,CAAC4G,uBAAuB,EAAE;MACzD,IAAI,CAAChI,oBAAoB,CAACiD,IAAI,CAACgF,SAAS,CAAC;IAC7C;EACJ;EACAE,kBAAkB,GAAG;IACjB,OAAO,IAAI,CAACzH,oBAAoB,GAAG,CAAC;EACxC;EACA0H,sBAAsB,GAAG;IACrB,OAAO,IAAI,CAAC1H,oBAAoB;EACpC;EACA2H,oBAAoB,GAAG;IACnB,OAAO,IAAI,CAACvG,qBAAqB;EACrC;EACAwG,yBAAyB,GAAG;IACxB,OAAO,IAAI,CAAC3G,0BAA0B;EAC1C;EACA4G,UAAU,GAAG;IACT,OAAO,IAAI,CAACpG,WAAW;EAC3B;EACAqG,sBAAsB,GAAG;IACrB,IAAI,CAAC3D,kBAAkB,EAAE;IACzB,IAAI,IAAI,CAACyD,yBAAyB,EAAE,EAAE;MAClC;MACA,OAAO,KAAK;IAChB;IACA,IAAIG,kBAAkB,GAAG,CAAC;IAC1B,IAAIC,iBAAiB,GAAG,CAAC;IACzB,MAAMC,SAAS,GAAG,IAAI,CAAC9H,OAAO,CAACS,YAAY,EAAE;IAC7C,KAAK,IAAIsH,UAAU,GAAG,CAAC,EAAEA,UAAU,IAAID,SAAS,EAAEC,UAAU,EAAE,EAAE;MAC5D,MAAMC,UAAU,GAAG,IAAI,CAAChI,OAAO,CAACY,aAAa,CAACmH,UAAU,CAAC;MACzD,IAAIC,UAAU,IAAI5K,kBAAkB,EAAE;QAClCyK,iBAAiB,IAAIG,UAAU;MACnC,CAAC,MACI;QACDJ,kBAAkB,IAAII,UAAU;MACpC;IACJ;IACA,OAAQH,iBAAiB,GAAGD,kBAAkB;EAClD;EACA,IAAIK,GAAG,GAAG;IACN,OAAO,IAAI,CAACtI,mBAAmB;EACnC;EACA;EACAuI,UAAU,GAAG;IACT,IAAI,CAAClE,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAC9D,QAAQ;EACxB;EACAiI,oBAAoB,GAAG;IACnB,OAAO;MACH1F,OAAO,EAAE,IAAI,CAACvC,QAAQ,CAAC0C,UAAU;MACjCF,YAAY,EAAE,IAAI,CAACxC,QAAQ,CAACwC;IAChC,CAAC;EACL;EACA0F,aAAa,CAACC,QAAQ,EAAE;IACpB,IAAI,CAACrE,kBAAkB,EAAE;IACzB,MAAMvB,OAAO,GAAI,OAAO4F,QAAQ,CAAC5F,OAAO,KAAK,WAAW,GAAI4F,QAAQ,CAAC5F,OAAO,GAAG,IAAI,CAACvC,QAAQ,CAACuC,OAAO;IACpG,MAAMG,UAAU,GAAI,OAAOyF,QAAQ,CAACzF,UAAU,KAAK,WAAW,GAAIyF,QAAQ,CAACzF,UAAU,GAAG,IAAI,CAAC1C,QAAQ,CAAC0C,UAAU;IAChH,MAAMF,YAAY,GAAI,OAAO2F,QAAQ,CAAC3F,YAAY,KAAK,WAAW,GAAI2F,QAAQ,CAAC3F,YAAY,GAAG,IAAI,CAACxC,QAAQ,CAACwC,YAAY;IACxH,MAAMG,kBAAkB,GAAI,OAAOwF,QAAQ,CAACxF,kBAAkB,KAAK,WAAW,GAAIwF,QAAQ,CAACxF,kBAAkB,GAAG,IAAI,CAAC3C,QAAQ,CAAC2C,kBAAkB;IAChJ,MAAMC,8BAA8B,GAAI,OAAOuF,QAAQ,CAACC,0BAA0B,KAAK,WAAW,GAAID,QAAQ,CAACC,0BAA0B,GAAG,IAAI,CAACpI,QAAQ,CAAC4C,8BAA8B;IACxL,MAAMyF,OAAO,GAAG,IAAI5N,KAAK,CAACgI,wBAAwB,CAAC;MAC/CF,OAAO,EAAEA,OAAO;MAChBG,UAAU,EAAEA,UAAU;MACtBF,YAAY,EAAEA,YAAY;MAC1B5F,UAAU,EAAE,IAAI,CAACoD,QAAQ,CAACpD,UAAU;MACpC+F,kBAAkB,EAAEA,kBAAkB;MACtCC;IACJ,CAAC,CAAC;IACF,IAAI,IAAI,CAAC5C,QAAQ,CAACsI,MAAM,CAACD,OAAO,CAAC,EAAE;MAC/B;IACJ;IACA,MAAMlF,CAAC,GAAG,IAAI,CAACnD,QAAQ,CAACuI,iBAAiB,CAACF,OAAO,CAAC;IAClD,IAAI,CAACrI,QAAQ,GAAGqI,OAAO;IACvB,IAAI,CAACnI,aAAa,CAACsI,sBAAsB,CAACrF,CAAC,CAAC;IAC5C,IAAI,CAAC/C,mBAAmB,CAACoI,sBAAsB,CAACrF,CAAC,CAAC;IAClD,IAAI,CAACpE,mBAAmB,CAACmD,IAAI,CAACiB,CAAC,CAAC;EACpC;EACAd,iBAAiB,CAACoG,mBAAmB,EAAEC,cAAc,EAAE;IACnD,IAAI,CAAC5E,kBAAkB,EAAE;IACzB,MAAMxB,kBAAkB,GAAGxH,gBAAgB,CAAC,IAAI,CAACgF,OAAO,EAAE4I,cAAc,EAAED,mBAAmB,CAAC;IAC9F,IAAI,CAACP,aAAa,CAAC;MACf1F,YAAY,EAAEF,kBAAkB,CAACE,YAAY;MAC7CD,OAAO,EAAED,kBAAkB,CAACC,OAAO;MACnCG,UAAU,EAAEJ,kBAAkB,CAACC,OAAO,CAAE;IAC5C,CAAC,CAAC;EACN;;EACArI,oBAAoB,CAACyO,GAAG,EAAE;IACtB,IAAI,CAAC7E,kBAAkB,EAAE;IACzB,OAAO5J,oBAAoB,CAACyO,GAAG,EAAE,IAAI,CAAC3I,QAAQ,CAAC0C,UAAU,EAAE,IAAI,CAAC1C,QAAQ,CAACwC,YAAY,CAAC;EAC1F;EACA;EACA;EACAwC,YAAY,GAAG;IACX,IAAI,CAAClB,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAC7C,UAAU;EAC1B;EACA2H,eAAe,GAAG;IACd,OAAO,IAAI,CAAC9I,OAAO,CAAC8I,eAAe,EAAE;EACzC;EACAC,kCAAkC,GAAG;IACjC,OAAO,IAAI,CAAC/I,OAAO,CAAC+I,kCAAkC,EAAE;EAC5D;EACAC,4BAA4B,GAAoB;IAAA,IAAnBC,UAAU,uEAAG,IAAI;IAC1C,MAAMC,OAAO,GAAG,IAAI,CAACC,WAAW,CAAClP,OAAO,CAACmP,wBAAwB,CAAC7L,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,uCAAuC;IAC7J,IAAI,CAACyC,OAAO,CAACqJ,uCAAuC,EAAE;IACtD,IAAI,CAACC,kBAAkB,CAACL,UAAU,EAAEC,OAAO,CAACK,GAAG,CAACC,CAAC,KAAK;MAAEhF,KAAK,EAAEgF,CAAC,CAAChF,KAAK;MAAEpI,IAAI,EAAE;IAAK,CAAC,CAAC,CAAC,EAAE,MAAM,IAAI,CAAC;EACvG;EACAqN,yBAAyB,GAAG;IACxB,OAAO,IAAI,CAACzJ,OAAO,CAACyJ,yBAAyB,EAAE;EACnD;EACAC,uBAAuB,GAAG;IACtB,IAAI,CAAC1F,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAC5C,qBAAqB;EACrC;EACAuI,0BAA0B,GAAG;IACzB,IAAI,CAAC3F,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAC3C,wBAAwB;EACxC;EACAsF,WAAW,CAACiD,WAAW,EAAE;IACrB,IAAI,CAAC5F,kBAAkB,EAAE;IACzB,MAAM6F,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAACF,WAAW,CAAC7B,UAAU,EAAE6B,WAAW,CAACG,MAAM,EAAE,CAAC,CAAC,yCAAyC;IAC/H,OAAO,IAAI,CAAC/J,OAAO,CAAC2G,WAAW,CAACkD,QAAQ,CAAC9B,UAAU,EAAE8B,QAAQ,CAACE,MAAM,CAAC;EACzE;EACAC,aAAa,CAACC,SAAS,EAAE;IACrB,IAAI,CAACjG,kBAAkB,EAAE;IACzB,MAAMkG,MAAM,GAAIC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpK,OAAO,CAACqK,SAAS,EAAE,EAAEF,IAAI,CAACG,GAAG,CAAC,CAAC,EAAEL,SAAS,CAAC,CAAE;IAC3E,OAAO,IAAI,CAACjK,OAAO,CAACgK,aAAa,CAACE,MAAM,CAAC;EAC7C;EACAxE,kBAAkB,GAAG;IACjB,IAAI,CAACvE,UAAU,GAAG,IAAI,CAACA,UAAU,GAAG,CAAC;IACrC,IAAI,CAACC,qBAAqB,GAAG,IAAI,CAACD,UAAU;EAChD;EACAoJ,mBAAmB,CAACtF,SAAS,EAAE;IAC3B,IAAI,CAAC9D,UAAU,GAAG8D,SAAS;EAC/B;EACAuF,8BAA8B,CAACC,uBAAuB,EAAE;IACpD,IAAI,CAACrJ,qBAAqB,GAAGqJ,uBAAuB;EACxD;EACAC,iCAAiC,CAACC,0BAA0B,EAAE;IAC1D,IAAI,CAACtJ,wBAAwB,GAAGsJ,0BAA0B;EAC9D;EACA9E,QAAQ,CAACd,GAAG,EAAuB;IAAA,IAArB6F,WAAW,uEAAG,KAAK;IAC7B,IAAI,CAAC5G,kBAAkB,EAAE;IACzB,MAAM6G,cAAc,GAAG,IAAI,CAACxF,iBAAiB,EAAE;IAC/C,MAAMyF,cAAc,GAAG,IAAI,CAACC,eAAe,CAACF,cAAc,EAAE9F,GAAG,CAAC;IAChE,IAAI6F,WAAW,EAAE;MACb,OAAO,IAAI,CAAC5K,OAAO,CAACgL,MAAM,EAAE,GAAGF,cAAc;IACjD;IACA,OAAOA,cAAc;EACzB;EACAG,cAAc,GAAsB;IAAA,IAArBL,WAAW,uEAAG,KAAK;IAC9B,OAAO,IAAIvN,iBAAiB,CAAC,IAAI,CAAC2C,OAAO,CAACiL,cAAc,CAACL,WAAW,CAAC,CAAC;EAC1E;EACAM,cAAc,CAACnG,GAAG,EAAuB;IAAA,IAArB6F,WAAW,uEAAG,KAAK;IACnC,IAAI,CAAC5G,kBAAkB,EAAE;IACzB,MAAM6G,cAAc,GAAG,IAAI,CAACxF,iBAAiB,EAAE;IAC/C,MAAMyF,cAAc,GAAG,IAAI,CAACnK,qBAAqB,CAACkK,cAAc,EAAE9F,GAAG,CAAC;IACtE,IAAI6F,WAAW,EAAE;MACb,OAAO,IAAI,CAAC5K,OAAO,CAACgL,MAAM,EAAE,CAAClS,MAAM,GAAGgS,cAAc;IACxD;IACA,OAAOA,cAAc;EACzB;EACAC,eAAe,CAACI,QAAQ,EAAuD;IAAA,IAArDpG,GAAG,uEAAG,CAAC;IAC7B,IAAI,CAACf,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAChE,OAAO,CAAC+K,eAAe,CAAC,IAAI,CAACK,aAAa,CAACD,QAAQ,CAAC,EAAEpG,GAAG,CAAC;EAC1E;EACApE,qBAAqB,CAACwK,QAAQ,EAAuD;IAAA,IAArDpG,GAAG,uEAAG,CAAC;IACnC,IAAI,CAACf,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAChE,OAAO,CAACW,qBAAqB,CAAC,IAAI,CAACyK,aAAa,CAACD,QAAQ,CAAC,EAAEpG,GAAG,CAAC;EAChF;EACAsG,wBAAwB,CAACF,QAAQ,EAAuD;IAAA,IAArDpG,GAAG,uEAAG,CAAC;IACtC,IAAI,CAACf,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAChE,OAAO,CAACqL,wBAAwB,CAAC,IAAI,CAACD,aAAa,CAACD,QAAQ,CAAC,EAAEpG,GAAG,CAAC;EACnF;EACAtE,YAAY,GAAG;IACX,IAAI,CAACuD,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAChE,OAAO,CAACS,YAAY,EAAE;EACtC;EACA6K,cAAc,CAACvD,UAAU,EAAE;IACvB,IAAI,CAAC/D,kBAAkB,EAAE;IACzB,IAAI+D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAACtH,YAAY,EAAE,EAAE;MACpD,MAAM,IAAIzC,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACgC,OAAO,CAACsL,cAAc,CAACvD,UAAU,CAAC;EAClD;EACAnH,aAAa,CAACmH,UAAU,EAAE;IACtB,IAAI,CAAC/D,kBAAkB,EAAE;IACzB,IAAI+D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAACtH,YAAY,EAAE,EAAE;MACpD,MAAM,IAAIzC,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACgC,OAAO,CAACY,aAAa,CAACmH,UAAU,CAAC;EACjD;EACAwD,eAAe,GAAG;IACd,IAAI,CAACvH,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAChE,OAAO,CAACuL,eAAe,EAAE;EACzC;EACAvG,MAAM,GAAG;IACL,IAAI,CAAChB,kBAAkB,EAAE;IACzB,OAAO,IAAI,CAAChE,OAAO,CAACgF,MAAM,EAAE;EAChC;EACAwG,oBAAoB,GAAG;IACnB,IAAI,CAACxH,kBAAkB,EAAE;IACzB,OAAQ,IAAI,CAAChE,OAAO,CAACgF,MAAM,EAAE,KAAK,IAAI,GAChC,CAAC,CAAC,mCACF,CAAC,CAAC;EACZ;;EACAyG,gBAAgB,CAAC1D,UAAU,EAAE;IACzB,IAAI,CAAC/D,kBAAkB,EAAE;IACzB,OAAO,CAAC;EACZ;EACAyB,gBAAgB,CAACsC,UAAU,EAAE;IACzB,IAAI,CAAC/D,kBAAkB,EAAE;IACzB,IAAI+D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAACtH,YAAY,EAAE,EAAE;MACpD,MAAM,IAAIzC,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACgC,OAAO,CAACY,aAAa,CAACmH,UAAU,CAAC,GAAG,CAAC;EACrD;EACA2D,+BAA+B,CAAC3D,UAAU,EAAE;IACxC,IAAI,CAAC/D,kBAAkB,EAAE;IACzB,IAAI+D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAACtH,YAAY,EAAE,EAAE;MACpD,MAAM,IAAIzC,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACgC,OAAO,CAAC0L,+BAA+B,CAAC3D,UAAU,CAAC;EACnE;EACA4D,8BAA8B,CAAC5D,UAAU,EAAE;IACvC,IAAI,CAAC/D,kBAAkB,EAAE;IACzB,IAAI+D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAACtH,YAAY,EAAE,EAAE;MACpD,MAAM,IAAIzC,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACgC,OAAO,CAAC2L,8BAA8B,CAAC5D,UAAU,CAAC;EAClE;EACA;AACJ;AACA;AACA;EACI6D,kCAAkC,CAACpH,KAAK,EAAE;IACtC,MAAMqH,UAAU,GAAG,IAAI,CAAC7L,OAAO,CAACS,YAAY,EAAE;IAC9C,MAAMqL,sBAAsB,GAAGtH,KAAK,CAACoC,eAAe;IACpD,MAAMmF,kBAAkB,GAAGvH,KAAK,CAACqC,WAAW;IAC5C,IAAID,eAAe,GAAGuD,IAAI,CAAC6B,KAAK,CAAE,OAAOF,sBAAsB,KAAK,QAAQ,IAAI,CAACG,KAAK,CAACH,sBAAsB,CAAC,GAAIA,sBAAsB,GAAG,CAAC,CAAC;IAC7I,IAAIjF,WAAW,GAAGsD,IAAI,CAAC6B,KAAK,CAAE,OAAOD,kBAAkB,KAAK,QAAQ,IAAI,CAACE,KAAK,CAACF,kBAAkB,CAAC,GAAIA,kBAAkB,GAAG,CAAC,CAAC;IAC7H,IAAInF,eAAe,GAAG,CAAC,EAAE;MACrBA,eAAe,GAAG,CAAC;MACnBC,WAAW,GAAG,CAAC;IACnB,CAAC,MACI,IAAID,eAAe,GAAGiF,UAAU,EAAE;MACnCjF,eAAe,GAAGiF,UAAU;MAC5BhF,WAAW,GAAG,IAAI,CAACpB,gBAAgB,CAACmB,eAAe,CAAC;IACxD,CAAC,MACI;MACD,IAAIC,WAAW,IAAI,CAAC,EAAE;QAClBA,WAAW,GAAG,CAAC;MACnB,CAAC,MACI;QACD,MAAMqF,SAAS,GAAG,IAAI,CAACzG,gBAAgB,CAACmB,eAAe,CAAC;QACxD,IAAIC,WAAW,IAAIqF,SAAS,EAAE;UAC1BrF,WAAW,GAAGqF,SAAS;QAC3B;MACJ;IACJ;IACA,MAAMC,oBAAoB,GAAG3H,KAAK,CAACe,aAAa;IAChD,MAAM6G,gBAAgB,GAAG5H,KAAK,CAACgB,SAAS;IACxC,IAAID,aAAa,GAAG4E,IAAI,CAAC6B,KAAK,CAAE,OAAOG,oBAAoB,KAAK,QAAQ,IAAI,CAACF,KAAK,CAACE,oBAAoB,CAAC,GAAIA,oBAAoB,GAAG,CAAC,CAAC;IACrI,IAAI3G,SAAS,GAAG2E,IAAI,CAAC6B,KAAK,CAAE,OAAOI,gBAAgB,KAAK,QAAQ,IAAI,CAACH,KAAK,CAACG,gBAAgB,CAAC,GAAIA,gBAAgB,GAAG,CAAC,CAAC;IACrH,IAAI7G,aAAa,GAAG,CAAC,EAAE;MACnBA,aAAa,GAAG,CAAC;MACjBC,SAAS,GAAG,CAAC;IACjB,CAAC,MACI,IAAID,aAAa,GAAGsG,UAAU,EAAE;MACjCtG,aAAa,GAAGsG,UAAU;MAC1BrG,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,aAAa,CAAC;IACpD,CAAC,MACI;MACD,IAAIC,SAAS,IAAI,CAAC,EAAE;QAChBA,SAAS,GAAG,CAAC;MACjB,CAAC,MACI;QACD,MAAM0G,SAAS,GAAG,IAAI,CAACzG,gBAAgB,CAACF,aAAa,CAAC;QACtD,IAAIC,SAAS,IAAI0G,SAAS,EAAE;UACxB1G,SAAS,GAAG0G,SAAS;QACzB;MACJ;IACJ;IACA,IAAIJ,sBAAsB,KAAKlF,eAAe,IACvCmF,kBAAkB,KAAKlF,WAAW,IAClCsF,oBAAoB,KAAK5G,aAAa,IACtC6G,gBAAgB,KAAK5G,SAAS,IAC9BhB,KAAK,YAAYlK,KAAK,IACtB,EAAEkK,KAAK,YAAYjK,SAAS,CAAC,EAAE;MAClC,OAAOiK,KAAK;IAChB;IACA,OAAO,IAAIlK,KAAK,CAACsM,eAAe,EAAEC,WAAW,EAAEtB,aAAa,EAAEC,SAAS,CAAC;EAC5E;EACA6G,gBAAgB,CAACtE,UAAU,EAAEgC,MAAM,EAAEuC,cAAc,EAAE;IACjD,IAAI,OAAOvE,UAAU,KAAK,QAAQ,IAAI,OAAOgC,MAAM,KAAK,QAAQ,EAAE;MAC9D,OAAO,KAAK;IAChB;IACA,IAAIkC,KAAK,CAAClE,UAAU,CAAC,IAAIkE,KAAK,CAAClC,MAAM,CAAC,EAAE;MACpC,OAAO,KAAK;IAChB;IACA,IAAIhC,UAAU,GAAG,CAAC,IAAIgC,MAAM,GAAG,CAAC,EAAE;MAC9B,OAAO,KAAK;IAChB;IACA,IAAI,CAAChC,UAAU,GAAG,CAAC,MAAMA,UAAU,IAAI,CAACgC,MAAM,GAAG,CAAC,MAAMA,MAAM,EAAE;MAC5D,OAAO,KAAK;IAChB;IACA,MAAMjC,SAAS,GAAG,IAAI,CAAC9H,OAAO,CAACS,YAAY,EAAE;IAC7C,IAAIsH,UAAU,GAAGD,SAAS,EAAE;MACxB,OAAO,KAAK;IAChB;IACA,IAAIiC,MAAM,KAAK,CAAC,EAAE;MACd,OAAO,IAAI;IACf;IACA,MAAMmC,SAAS,GAAG,IAAI,CAACzG,gBAAgB,CAACsC,UAAU,CAAC;IACnD,IAAIgC,MAAM,GAAGmC,SAAS,EAAE;MACpB,OAAO,KAAK;IAChB;IACA,IAAII,cAAc,KAAK,CAAC,CAAC,iDAAiD;MACtE;MACA,MAAMC,cAAc,GAAG,IAAI,CAACvM,OAAO,CAACwM,eAAe,CAACzE,UAAU,EAAEgC,MAAM,GAAG,CAAC,CAAC;MAC3E,IAAI9P,OAAO,CAACwS,eAAe,CAACF,cAAc,CAAC,EAAE;QACzC,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACAzC,iBAAiB,CAAC4C,WAAW,EAAEC,OAAO,EAAEL,cAAc,EAAE;IACpD,MAAMvE,UAAU,GAAGoC,IAAI,CAAC6B,KAAK,CAAE,OAAOU,WAAW,KAAK,QAAQ,IAAI,CAACT,KAAK,CAACS,WAAW,CAAC,GAAIA,WAAW,GAAG,CAAC,CAAC;IACzG,MAAM3C,MAAM,GAAGI,IAAI,CAAC6B,KAAK,CAAE,OAAOW,OAAO,KAAK,QAAQ,IAAI,CAACV,KAAK,CAACU,OAAO,CAAC,GAAIA,OAAO,GAAG,CAAC,CAAC;IACzF,MAAM7E,SAAS,GAAG,IAAI,CAAC9H,OAAO,CAACS,YAAY,EAAE;IAC7C,IAAIsH,UAAU,GAAG,CAAC,EAAE;MAChB,OAAO,IAAI1N,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;IAC7B;IACA,IAAI0N,UAAU,GAAGD,SAAS,EAAE;MACxB,OAAO,IAAIzN,QAAQ,CAACyN,SAAS,EAAE,IAAI,CAACrC,gBAAgB,CAACqC,SAAS,CAAC,CAAC;IACpE;IACA,IAAIiC,MAAM,IAAI,CAAC,EAAE;MACb,OAAO,IAAI1P,QAAQ,CAAC0N,UAAU,EAAE,CAAC,CAAC;IACtC;IACA,MAAMmE,SAAS,GAAG,IAAI,CAACzG,gBAAgB,CAACsC,UAAU,CAAC;IACnD,IAAIgC,MAAM,IAAImC,SAAS,EAAE;MACrB,OAAO,IAAI7R,QAAQ,CAAC0N,UAAU,EAAEmE,SAAS,CAAC;IAC9C;IACA,IAAII,cAAc,KAAK,CAAC,CAAC,iDAAiD;MACtE;MACA;MACA;MACA,MAAMC,cAAc,GAAG,IAAI,CAACvM,OAAO,CAACwM,eAAe,CAACzE,UAAU,EAAEgC,MAAM,GAAG,CAAC,CAAC;MAC3E,IAAI9P,OAAO,CAACwS,eAAe,CAACF,cAAc,CAAC,EAAE;QACzC,OAAO,IAAIlS,QAAQ,CAAC0N,UAAU,EAAEgC,MAAM,GAAG,CAAC,CAAC;MAC/C;IACJ;IACA,OAAO,IAAI1P,QAAQ,CAAC0N,UAAU,EAAEgC,MAAM,CAAC;EAC3C;EACA6C,gBAAgB,CAAC/C,QAAQ,EAAE;IACvB,MAAMyC,cAAc,GAAG,CAAC,CAAC;IACzB,IAAI,CAACtI,kBAAkB,EAAE;IACzB;IACA,IAAI6F,QAAQ,YAAYxP,QAAQ,EAAE;MAC9B,IAAI,IAAI,CAACgS,gBAAgB,CAACxC,QAAQ,CAAC9B,UAAU,EAAE8B,QAAQ,CAACE,MAAM,EAAEuC,cAAc,CAAC,EAAE;QAC7E,OAAOzC,QAAQ;MACnB;IACJ;IACA,OAAO,IAAI,CAACC,iBAAiB,CAACD,QAAQ,CAAC9B,UAAU,EAAE8B,QAAQ,CAACE,MAAM,EAAEuC,cAAc,CAAC;EACvF;EACAO,aAAa,CAACrI,KAAK,EAAE8H,cAAc,EAAE;IACjC,MAAM1F,eAAe,GAAGpC,KAAK,CAACoC,eAAe;IAC7C,MAAMC,WAAW,GAAGrC,KAAK,CAACqC,WAAW;IACrC,MAAMtB,aAAa,GAAGf,KAAK,CAACe,aAAa;IACzC,MAAMC,SAAS,GAAGhB,KAAK,CAACgB,SAAS;IACjC,IAAI,CAAC,IAAI,CAAC6G,gBAAgB,CAACzF,eAAe,EAAEC,WAAW,EAAE,CAAC,CAAC,yCAAyC,EAAE;MAClG,OAAO,KAAK;IAChB;IACA,IAAI,CAAC,IAAI,CAACwF,gBAAgB,CAAC9G,aAAa,EAAEC,SAAS,EAAE,CAAC,CAAC,yCAAyC,EAAE;MAC9F,OAAO,KAAK;IAChB;IACA,IAAI8G,cAAc,KAAK,CAAC,CAAC,iDAAiD;MACtE,MAAMQ,mBAAmB,GAAIjG,WAAW,GAAG,CAAC,GAAG,IAAI,CAAC7G,OAAO,CAACwM,eAAe,CAAC5F,eAAe,EAAEC,WAAW,GAAG,CAAC,CAAC,GAAG,CAAE;MAClH,MAAMkG,iBAAiB,GAAIvH,SAAS,GAAG,CAAC,IAAIA,SAAS,IAAI,IAAI,CAACxF,OAAO,CAACY,aAAa,CAAC2E,aAAa,CAAC,GAAG,IAAI,CAACvF,OAAO,CAACwM,eAAe,CAACjH,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAE;MACpK,MAAMwH,wBAAwB,GAAG/S,OAAO,CAACwS,eAAe,CAACK,mBAAmB,CAAC;MAC7E,MAAMG,sBAAsB,GAAGhT,OAAO,CAACwS,eAAe,CAACM,iBAAiB,CAAC;MACzE,IAAI,CAACC,wBAAwB,IAAI,CAACC,sBAAsB,EAAE;QACtD,OAAO,IAAI;MACf;MACA,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;EACA7B,aAAa,CAAC8B,MAAM,EAAE;IAClB,MAAMZ,cAAc,GAAG,CAAC,CAAC;IACzB,IAAI,CAACtI,kBAAkB,EAAE;IACzB;IACA,IAAKkJ,MAAM,YAAY5S,KAAK,IAAK,EAAE4S,MAAM,YAAY3S,SAAS,CAAC,EAAE;MAC7D,IAAI,IAAI,CAACsS,aAAa,CAACK,MAAM,EAAEZ,cAAc,CAAC,EAAE;QAC5C,OAAOY,MAAM;MACjB;IACJ;IACA,MAAMzG,KAAK,GAAG,IAAI,CAACqD,iBAAiB,CAACoD,MAAM,CAACtG,eAAe,EAAEsG,MAAM,CAACrG,WAAW,EAAE,CAAC,CAAC,yCAAyC;IAC5H,MAAMI,GAAG,GAAG,IAAI,CAAC6C,iBAAiB,CAACoD,MAAM,CAAC3H,aAAa,EAAE2H,MAAM,CAAC1H,SAAS,EAAE,CAAC,CAAC,yCAAyC;IACtH,MAAMoB,eAAe,GAAGH,KAAK,CAACsB,UAAU;IACxC,MAAMlB,WAAW,GAAGJ,KAAK,CAACsD,MAAM;IAChC,MAAMxE,aAAa,GAAG0B,GAAG,CAACc,UAAU;IACpC,MAAMvC,SAAS,GAAGyB,GAAG,CAAC8C,MAAM;IAC5B,IAAIuC,cAAc,KAAK,CAAC,CAAC,iDAAiD;MACtE,MAAMQ,mBAAmB,GAAIjG,WAAW,GAAG,CAAC,GAAG,IAAI,CAAC7G,OAAO,CAACwM,eAAe,CAAC5F,eAAe,EAAEC,WAAW,GAAG,CAAC,CAAC,GAAG,CAAE;MAClH,MAAMkG,iBAAiB,GAAIvH,SAAS,GAAG,CAAC,IAAIA,SAAS,IAAI,IAAI,CAACxF,OAAO,CAACY,aAAa,CAAC2E,aAAa,CAAC,GAAG,IAAI,CAACvF,OAAO,CAACwM,eAAe,CAACjH,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAE;MACpK,MAAMwH,wBAAwB,GAAG/S,OAAO,CAACwS,eAAe,CAACK,mBAAmB,CAAC;MAC7E,MAAMG,sBAAsB,GAAGhT,OAAO,CAACwS,eAAe,CAACM,iBAAiB,CAAC;MACzE,IAAI,CAACC,wBAAwB,IAAI,CAACC,sBAAsB,EAAE;QACtD,OAAO,IAAI3S,KAAK,CAACsM,eAAe,EAAEC,WAAW,EAAEtB,aAAa,EAAEC,SAAS,CAAC;MAC5E;MACA,IAAIoB,eAAe,KAAKrB,aAAa,IAAIsB,WAAW,KAAKrB,SAAS,EAAE;QAChE;QACA,OAAO,IAAIlL,KAAK,CAACsM,eAAe,EAAEC,WAAW,GAAG,CAAC,EAAEtB,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC;MACpF;MACA,IAAIwH,wBAAwB,IAAIC,sBAAsB,EAAE;QACpD;QACA,OAAO,IAAI3S,KAAK,CAACsM,eAAe,EAAEC,WAAW,GAAG,CAAC,EAAEtB,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC;MACpF;MACA,IAAIwH,wBAAwB,EAAE;QAC1B;QACA,OAAO,IAAI1S,KAAK,CAACsM,eAAe,EAAEC,WAAW,GAAG,CAAC,EAAEtB,aAAa,EAAEC,SAAS,CAAC;MAChF;MACA;MACA,OAAO,IAAIlL,KAAK,CAACsM,eAAe,EAAEC,WAAW,EAAEtB,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC;IAChF;IACA,OAAO,IAAIlL,KAAK,CAACsM,eAAe,EAAEC,WAAW,EAAEtB,aAAa,EAAEC,SAAS,CAAC;EAC5E;EACA2H,cAAc,CAACvD,WAAW,EAAEM,MAAM,EAAE;IAChC,IAAI,CAAClG,kBAAkB,EAAE;IACzB,MAAMoJ,SAAS,GAAG,IAAI,CAACzG,WAAW,CAACiD,WAAW,CAAC,GAAGM,MAAM;IACxD,OAAO,IAAI,CAACF,aAAa,CAACG,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpK,OAAO,CAACqK,SAAS,EAAE,EAAEF,IAAI,CAACG,GAAG,CAAC,CAAC,EAAE8C,SAAS,CAAC,CAAC,CAAC;EACzF;EACA/H,iBAAiB,GAAG;IAChB,IAAI,CAACrB,kBAAkB,EAAE;IACzB,MAAM8D,SAAS,GAAG,IAAI,CAACrH,YAAY,EAAE;IACrC,OAAO,IAAInG,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEwN,SAAS,EAAE,IAAI,CAACrC,gBAAgB,CAACqC,SAAS,CAAC,CAAC;EACvE;EACAuF,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAEC,gBAAgB,EAAE;IAC7E,OAAO,IAAI,CAACzN,OAAO,CAACqN,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAEC,gBAAgB,CAAC;EACxG;EACAtE,WAAW,CAACuE,YAAY,EAAEC,cAAc,EAAEC,OAAO,EAAEC,SAAS,EAAEC,cAAc,EAAEN,cAAc,EAAuC;IAAA,IAArCC,gBAAgB,uEAAGtQ,gBAAgB;IAC7H,IAAI,CAAC6G,kBAAkB,EAAE;IACzB,IAAI+J,YAAY,GAAG,IAAI;IACvB,IAAIJ,cAAc,KAAK,IAAI,EAAE;MACzB,IAAI,CAACK,KAAK,CAACC,OAAO,CAACN,cAAc,CAAC,EAAE;QAChCA,cAAc,GAAG,CAACA,cAAc,CAAC;MACrC;MACA,IAAIA,cAAc,CAACO,KAAK,CAAEC,WAAW,IAAK7T,KAAK,CAAC8T,QAAQ,CAACD,WAAW,CAAC,CAAC,EAAE;QACpEJ,YAAY,GAAGJ,cAAc,CAACpE,GAAG,CAAE4E,WAAW,IAAK,IAAI,CAAC/C,aAAa,CAAC+C,WAAW,CAAC,CAAC;MACvF;IACJ;IACA,IAAIJ,YAAY,KAAK,IAAI,EAAE;MACvBA,YAAY,GAAG,CAAC,IAAI,CAAC1I,iBAAiB,EAAE,CAAC;IAC7C;IACA0I,YAAY,GAAGA,YAAY,CAACM,IAAI,CAAC,CAACC,EAAE,EAAEC,EAAE,KAAKD,EAAE,CAAC1H,eAAe,GAAG2H,EAAE,CAAC3H,eAAe,IAAI0H,EAAE,CAACzH,WAAW,GAAG0H,EAAE,CAAC1H,WAAW,CAAC;IACxH,MAAM2H,kBAAkB,GAAG,EAAE;IAC7BA,kBAAkB,CAACC,IAAI,CAACV,YAAY,CAACW,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAK;MACxD,IAAItU,KAAK,CAACuU,eAAe,CAACF,IAAI,EAAEC,IAAI,CAAC,EAAE;QACnC,OAAOD,IAAI,CAACG,SAAS,CAACF,IAAI,CAAC;MAC/B;MACAJ,kBAAkB,CAACC,IAAI,CAACE,IAAI,CAAC;MAC7B,OAAOC,IAAI;IACf,CAAC,CAAC,CAAC;IACH,IAAIG,WAAW;IACf,IAAI,CAACnB,OAAO,IAAIF,YAAY,CAACsB,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;MAC5C;MACA,MAAMC,YAAY,GAAG,IAAI3T,YAAY,CAACoS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC;MACvF,MAAMP,UAAU,GAAG0B,YAAY,CAACC,kBAAkB,EAAE;MACpD,IAAI,CAAC3B,UAAU,EAAE;QACb,OAAO,EAAE;MACb;MACAwB,WAAW,GAAIzB,WAAW,IAAK,IAAI,CAACD,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAEC,gBAAgB,CAAC;IACxH,CAAC,MACI;MACDsB,WAAW,GAAIzB,WAAW,IAAK/R,eAAe,CAAC4N,WAAW,CAAC,IAAI,EAAE,IAAI7N,YAAY,CAACoS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC,EAAER,WAAW,EAAEE,cAAc,EAAEC,gBAAgB,CAAC;IACvL;IACA,OAAOe,kBAAkB,CAACjF,GAAG,CAACwF,WAAW,CAAC,CAACL,MAAM,CAAC,CAACS,GAAG,EAAEjG,OAAO,KAAKiG,GAAG,CAACC,MAAM,CAAClG,OAAO,CAAC,EAAE,EAAE,CAAC;EAChG;EACAmG,aAAa,CAAC3B,YAAY,EAAE4B,cAAc,EAAE1B,OAAO,EAAEC,SAAS,EAAEC,cAAc,EAAEN,cAAc,EAAE;IAC5F,IAAI,CAACxJ,kBAAkB,EAAE;IACzB,MAAMuL,WAAW,GAAG,IAAI,CAAC3C,gBAAgB,CAAC0C,cAAc,CAAC;IACzD,IAAI,CAAC1B,OAAO,IAAIF,YAAY,CAACsB,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;MAC5C,MAAMC,YAAY,GAAG,IAAI3T,YAAY,CAACoS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC;MACvF,MAAMP,UAAU,GAAG0B,YAAY,CAACC,kBAAkB,EAAE;MACpD,IAAI,CAAC3B,UAAU,EAAE;QACb,OAAO,IAAI;MACf;MACA,MAAMzF,SAAS,GAAG,IAAI,CAACrH,YAAY,EAAE;MACrC,IAAI6M,WAAW,GAAG,IAAIhT,KAAK,CAACiV,WAAW,CAACxH,UAAU,EAAEwH,WAAW,CAACxF,MAAM,EAAEjC,SAAS,EAAE,IAAI,CAACrC,gBAAgB,CAACqC,SAAS,CAAC,CAAC;MACpH,IAAI0H,GAAG,GAAG,IAAI,CAACnC,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAE,CAAC,CAAC;MAChFjS,eAAe,CAAC8T,aAAa,CAAC,IAAI,EAAE,IAAI/T,YAAY,CAACoS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC,EAAEyB,WAAW,EAAE/B,cAAc,CAAC;MACpI,IAAIgC,GAAG,CAAC1W,MAAM,GAAG,CAAC,EAAE;QAChB,OAAO0W,GAAG,CAAC,CAAC,CAAC;MACjB;MACAlC,WAAW,GAAG,IAAIhT,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEiV,WAAW,CAACxH,UAAU,EAAE,IAAI,CAACtC,gBAAgB,CAAC8J,WAAW,CAACxH,UAAU,CAAC,CAAC;MACpGyH,GAAG,GAAG,IAAI,CAACnC,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAE,CAAC,CAAC;MAC5E,IAAIgC,GAAG,CAAC1W,MAAM,GAAG,CAAC,EAAE;QAChB,OAAO0W,GAAG,CAAC,CAAC,CAAC;MACjB;MACA,OAAO,IAAI;IACf;IACA,OAAOjU,eAAe,CAAC8T,aAAa,CAAC,IAAI,EAAE,IAAI/T,YAAY,CAACoS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC,EAAEyB,WAAW,EAAE/B,cAAc,CAAC;EAC/I;EACAiC,iBAAiB,CAAC/B,YAAY,EAAE4B,cAAc,EAAE1B,OAAO,EAAEC,SAAS,EAAEC,cAAc,EAAEN,cAAc,EAAE;IAChG,IAAI,CAACxJ,kBAAkB,EAAE;IACzB,MAAMuL,WAAW,GAAG,IAAI,CAAC3C,gBAAgB,CAAC0C,cAAc,CAAC;IACzD,OAAO/T,eAAe,CAACkU,iBAAiB,CAAC,IAAI,EAAE,IAAInU,YAAY,CAACoS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC,EAAEyB,WAAW,EAAE/B,cAAc,CAAC;EACnJ;EACA;EACA;EACAkC,gBAAgB,GAAG;IACf,IAAI,CAAC5N,eAAe,CAAC4N,gBAAgB,EAAE;EAC3C;EACAC,eAAe,GAAG;IACd,IAAI,CAAC7N,eAAe,CAAC6N,eAAe,EAAE;EAC1C;EACAC,OAAO,CAAC7K,GAAG,EAAE;IACT,MAAM8K,UAAU,GAAI,IAAI,CAAC7K,MAAM,EAAE,KAAK,IAAI,GAAG,CAAC,CAAC,mCAAmC,CAAC,CAAC,kCAAmC;IACvH,IAAI6K,UAAU,KAAK9K,GAAG,EAAE;MACpB;IACJ;IACA,IAAI;MACA,IAAI,CAACnG,uBAAuB,CAACuD,iBAAiB,EAAE;MAChD,IAAI,CAAC7C,aAAa,CAAC6C,iBAAiB,EAAE;MACtC,IAAI,IAAI,CAACd,wBAAwB,KAAK,IAAI,EAAE;QACxC,IAAI,CAACA,wBAAwB,GAAG,IAAI,CAAChD,gBAAgB,CAAC4M,cAAc,CAAC,IAAI,CAAChD,GAAG,CAAC;MAClF;MACA,IAAI,CAACnG,eAAe,CAAC8N,OAAO,CAAC7K,GAAG,CAAC;IACrC,CAAC,SACO;MACJ,IAAI,CAACzF,aAAa,CAAC+C,eAAe,EAAE;MACpC,IAAI,CAACzD,uBAAuB,CAACyD,eAAe,EAAE;IAClD;EACJ;EACAyN,sBAAsB,CAACC,YAAY,EAAE;IACjC,IAAIA,YAAY,YAAYpV,KAAK,CAACqV,2BAA2B,EAAE;MAC3D,OAAOD,YAAY;IACvB;IACA,OAAO,IAAIpV,KAAK,CAACqV,2BAA2B,CAACD,YAAY,CAACE,UAAU,IAAI,IAAI,EAAE,IAAI,CAAC7E,aAAa,CAAC2E,YAAY,CAACvL,KAAK,CAAC,EAAEuL,YAAY,CAAC3T,IAAI,EAAE2T,YAAY,CAACG,gBAAgB,IAAI,KAAK,EAAEH,YAAY,CAACI,oBAAoB,IAAI,KAAK,EAAEJ,YAAY,CAACK,UAAU,IAAI,KAAK,CAAC;EAClQ;EACAC,uBAAuB,CAACC,aAAa,EAAE;IACnC,MAAM5S,MAAM,GAAG,EAAE;IACjB,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEgN,GAAG,GAAGiK,aAAa,CAACxX,MAAM,EAAEO,CAAC,GAAGgN,GAAG,EAAEhN,CAAC,EAAE,EAAE;MACtDqE,MAAM,CAACrE,CAAC,CAAC,GAAG,IAAI,CAACyW,sBAAsB,CAACQ,aAAa,CAACjX,CAAC,CAAC,CAAC;IAC7D;IACA,OAAOqE,MAAM;EACjB;EACA4L,kBAAkB,CAACiH,iBAAiB,EAAEC,cAAc,EAAEC,mBAAmB,EAAE;IACvE,IAAI;MACA,IAAI,CAAC7R,uBAAuB,CAACuD,iBAAiB,EAAE;MAChD,IAAI,CAAC7C,aAAa,CAAC6C,iBAAiB,EAAE;MACtC,OAAO,IAAI,CAACuO,mBAAmB,CAACH,iBAAiB,EAAE,IAAI,CAACF,uBAAuB,CAACG,cAAc,CAAC,EAAEC,mBAAmB,CAAC;IACzH,CAAC,SACO;MACJ,IAAI,CAACnR,aAAa,CAAC+C,eAAe,EAAE;MACpC,IAAI,CAACzD,uBAAuB,CAACyD,eAAe,EAAE;IAClD;EACJ;EACAqO,mBAAmB,CAACH,iBAAiB,EAAEC,cAAc,EAAEC,mBAAmB,EAAE;IACxE,IAAI,IAAI,CAACvQ,QAAQ,CAAC2C,kBAAkB,IAAI,IAAI,CAACZ,wBAAwB,EAAE;MACnE;MACA;MACA,MAAM0O,aAAa,GAAGH,cAAc,CAACjH,GAAG,CAAEqH,EAAE,IAAK;QAC7C,OAAO;UACHpM,KAAK,EAAE,IAAI,CAAC4G,aAAa,CAACwF,EAAE,CAACpM,KAAK,CAAC;UACnCpI,IAAI,EAAEwU,EAAE,CAACxU;QACb,CAAC;MACL,CAAC,CAAC;MACF;MACA;MACA,IAAIyU,mBAAmB,GAAG,IAAI;MAC9B,IAAIN,iBAAiB,EAAE;QACnB,KAAK,IAAIlX,CAAC,GAAG,CAAC,EAAEgN,GAAG,GAAGkK,iBAAiB,CAACzX,MAAM,EAAEO,CAAC,GAAGgN,GAAG,EAAEhN,CAAC,EAAE,EAAE;UAC1D,MAAMyX,GAAG,GAAGP,iBAAiB,CAAClX,CAAC,CAAC;UAChC,IAAI0X,gBAAgB,GAAG,KAAK;UAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGN,aAAa,CAAC7X,MAAM,EAAEkY,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;YACxD,MAAME,SAAS,GAAGP,aAAa,CAACK,CAAC,CAAC,CAACxM,KAAK;YACxC,MAAM2M,UAAU,GAAGD,SAAS,CAACtK,eAAe,GAAGkK,GAAG,CAACvL,aAAa;YAChE,MAAM6L,UAAU,GAAGN,GAAG,CAAClK,eAAe,GAAGsK,SAAS,CAAC3L,aAAa;YAChE,IAAI,CAAC4L,UAAU,IAAI,CAACC,UAAU,EAAE;cAC5BL,gBAAgB,GAAG,IAAI;cACvB;YACJ;UACJ;UACA,IAAI,CAACA,gBAAgB,EAAE;YACnBF,mBAAmB,GAAG,KAAK;YAC3B;UACJ;QACJ;MACJ;MACA,IAAIA,mBAAmB,EAAE;QACrB,KAAK,IAAIxX,CAAC,GAAG,CAAC,EAAEgN,GAAG,GAAG,IAAI,CAACpE,wBAAwB,CAACnJ,MAAM,EAAEO,CAAC,GAAGgN,GAAG,EAAEhN,CAAC,EAAE,EAAE;UACtE,MAAMgY,cAAc,GAAG,IAAI,CAACpP,wBAAwB,CAAC5I,CAAC,CAAC;UACvD,MAAMiY,aAAa,GAAG,IAAI,CAAC7L,gBAAgB,CAAC4L,cAAc,CAAC;UAC3D,IAAIE,aAAa,GAAG,IAAI;UACxB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGN,aAAa,CAAC7X,MAAM,EAAEkY,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;YACxD,MAAME,SAAS,GAAGP,aAAa,CAACK,CAAC,CAAC,CAACxM,KAAK;YACxC,MAAMgN,QAAQ,GAAGb,aAAa,CAACK,CAAC,CAAC,CAAC5U,IAAI;YACtC,IAAIiV,cAAc,GAAGH,SAAS,CAACtK,eAAe,IAAIyK,cAAc,GAAGH,SAAS,CAAC3L,aAAa,EAAE;cACxF;cACA;YACJ;YACA;YACA;YACA,IAAI8L,cAAc,KAAKH,SAAS,CAACtK,eAAe,IAAIsK,SAAS,CAACrK,WAAW,KAAKyK,aAAa,IACpFJ,SAAS,CAACO,OAAO,EAAE,IAAID,QAAQ,IAAIA,QAAQ,CAAC1Y,MAAM,GAAG,CAAC,IAAI0Y,QAAQ,CAACE,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;cAC1F;cACA;YACJ;YACA,IAAIL,cAAc,KAAKH,SAAS,CAACtK,eAAe,IAAIsK,SAAS,CAACrK,WAAW,KAAK,CAAC,IACxEqK,SAAS,CAACO,OAAO,EAAE,IAAID,QAAQ,IAAIA,QAAQ,CAAC1Y,MAAM,GAAG,CAAC,IAAI0Y,QAAQ,CAACE,MAAM,CAACF,QAAQ,CAAC1Y,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;cAC5G;cACA;YACJ;YACA;YACAyY,aAAa,GAAG,KAAK;YACrB;UACJ;UACA,IAAIA,aAAa,EAAE;YACf,MAAMI,SAAS,GAAG,IAAIrX,KAAK,CAAC+W,cAAc,EAAE,CAAC,EAAEA,cAAc,EAAEC,aAAa,CAAC;YAC7Ed,cAAc,CAAC/B,IAAI,CAAC,IAAI9T,KAAK,CAACqV,2BAA2B,CAAC,IAAI,EAAE2B,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;UAC1G;QACJ;MACJ;MACA,IAAI,CAAC1P,wBAAwB,GAAG,IAAI;IACxC;IACA,IAAI,IAAI,CAACZ,wBAAwB,KAAK,IAAI,EAAE;MACxC,IAAI,CAACA,wBAAwB,GAAG,IAAI,CAAChD,gBAAgB,CAAC4M,cAAc,CAAC,IAAI,CAAChD,GAAG,CAAC;IAClF;IACA,OAAO,IAAI,CAACnG,eAAe,CAAC8P,iBAAiB,CAACrB,iBAAiB,EAAEC,cAAc,EAAEC,mBAAmB,CAAC;EACzG;EACAoB,UAAU,CAAC/M,OAAO,EAAEC,GAAG,EAAE+M,6BAA6B,EAAEC,kBAAkB,EAAE;IACxE,MAAMC,KAAK,GAAGlN,OAAO,CAACyE,GAAG,CAAEpF,MAAM,IAAK;MAClC,MAAM8N,UAAU,GAAG,IAAI,CAACjI,aAAa,CAAC7F,MAAM,CAAC+N,WAAW,CAAC;MACzD,MAAMC,QAAQ,GAAG,IAAI,CAACnI,aAAa,CAAC7F,MAAM,CAACiO,MAAM,CAAC;MAClD,OAAO;QACH5N,KAAK,EAAE,IAAIlK,KAAK,CAAC2X,UAAU,CAAClK,UAAU,EAAEkK,UAAU,CAAClI,MAAM,EAAEoI,QAAQ,CAACpK,UAAU,EAAEoK,QAAQ,CAACpI,MAAM,CAAC;QAChG3N,IAAI,EAAE+H,MAAM,CAACkO;MACjB,CAAC;IACL,CAAC,CAAC;IACF,IAAI,CAACC,mBAAmB,CAACN,KAAK,EAAEjN,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE+M,6BAA6B,EAAEC,kBAAkB,CAAC;EACxG;EACAQ,UAAU,CAACzN,OAAO,EAAEC,GAAG,EAAE+M,6BAA6B,EAAEC,kBAAkB,EAAE;IACxE,MAAMC,KAAK,GAAGlN,OAAO,CAACyE,GAAG,CAAEpF,MAAM,IAAK;MAClC,MAAM8N,UAAU,GAAG,IAAI,CAACjI,aAAa,CAAC7F,MAAM,CAACqO,WAAW,CAAC;MACzD,MAAML,QAAQ,GAAG,IAAI,CAACnI,aAAa,CAAC7F,MAAM,CAACsO,MAAM,CAAC;MAClD,OAAO;QACHjO,KAAK,EAAE,IAAIlK,KAAK,CAAC2X,UAAU,CAAClK,UAAU,EAAEkK,UAAU,CAAClI,MAAM,EAAEoI,QAAQ,CAACpK,UAAU,EAAEoK,QAAQ,CAACpI,MAAM,CAAC;QAChG3N,IAAI,EAAE+H,MAAM,CAACuO;MACjB,CAAC;IACL,CAAC,CAAC;IACF,IAAI,CAACJ,mBAAmB,CAACN,KAAK,EAAEjN,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE+M,6BAA6B,EAAEC,kBAAkB,CAAC;EACxG;EACAO,mBAAmB,CAACN,KAAK,EAAEjN,GAAG,EAAEJ,SAAS,EAAEC,SAAS,EAAEkN,6BAA6B,EAAEC,kBAAkB,EAAE;IACrG,IAAI;MACA,IAAI,CAACnT,uBAAuB,CAACuD,iBAAiB,EAAE;MAChD,IAAI,CAAC7C,aAAa,CAAC6C,iBAAiB,EAAE;MACtC,IAAI,CAACJ,UAAU,GAAG4C,SAAS;MAC3B,IAAI,CAAC3C,UAAU,GAAG4C,SAAS;MAC3B,IAAI,CAAC+N,UAAU,CAACX,KAAK,EAAE,KAAK,CAAC;MAC7B,IAAI,CAAClM,MAAM,CAACf,GAAG,CAAC;MAChB,IAAI,CAACyF,8BAA8B,CAACsH,6BAA6B,CAAC;IACtE,CAAC,SACO;MACJ,IAAI,CAAC/P,UAAU,GAAG,KAAK;MACvB,IAAI,CAACC,UAAU,GAAG,KAAK;MACvB,IAAI,CAAC1C,aAAa,CAAC+C,eAAe,CAAC0P,kBAAkB,CAAC;MACtD,IAAI,CAACnT,uBAAuB,CAACyD,eAAe,EAAE;IAClD;EACJ;EACAsQ,UAAU,CAACrC,aAAa,EAA4B;IAAA,IAA1BsC,gBAAgB,uEAAG,KAAK;IAC9C,IAAI;MACA,IAAI,CAAChU,uBAAuB,CAACuD,iBAAiB,EAAE;MAChD,IAAI,CAAC7C,aAAa,CAAC6C,iBAAiB,EAAE;MACtC,MAAM0Q,UAAU,GAAG,IAAI,CAACxC,uBAAuB,CAACC,aAAa,CAAC;MAC9D,OAAO,IAAI,CAACwC,aAAa,CAACD,UAAU,EAAED,gBAAgB,CAAC;IAC3D,CAAC,SACO;MACJ,IAAI,CAACtT,aAAa,CAAC+C,eAAe,EAAE;MACpC,IAAI,CAACzD,uBAAuB,CAACyD,eAAe,EAAE;IAClD;EACJ;EACAyQ,aAAa,CAACxC,aAAa,EAAEsC,gBAAgB,EAAE;IAC3C,MAAMG,YAAY,GAAG,IAAI,CAAC/S,OAAO,CAACS,YAAY,EAAE;IAChD,MAAM/C,MAAM,GAAG,IAAI,CAACsC,OAAO,CAAC2S,UAAU,CAACrC,aAAa,EAAE,IAAI,CAACpQ,QAAQ,CAAC2C,kBAAkB,EAAE+P,gBAAgB,CAAC;IACzG,MAAMI,YAAY,GAAG,IAAI,CAAChT,OAAO,CAACS,YAAY,EAAE;IAChD,MAAMwS,cAAc,GAAGvV,MAAM,CAACoH,OAAO;IACrC,IAAI,CAAC7C,wBAAwB,GAAGvE,MAAM,CAACwV,6BAA6B;IACpE,IAAID,cAAc,CAACna,MAAM,KAAK,CAAC,EAAE;MAC7B;MACA;MACA;MACA;MACA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEgN,GAAG,GAAG4M,cAAc,CAACna,MAAM,EAAEO,CAAC,GAAGgN,GAAG,EAAEhN,CAAC,EAAE,EAAE;QACvD,MAAM8K,MAAM,GAAG8O,cAAc,CAAC5Z,CAAC,CAAC;QAChC,MAAM,CAAC8Z,QAAQ,EAAEC,eAAe,EAAEC,cAAc,CAAC,GAAGlZ,QAAQ,CAACgK,MAAM,CAAC/H,IAAI,CAAC;QACzE,IAAI,CAACmE,0BAA0B,CAAC+S,UAAU,CAACnP,MAAM,CAACK,KAAK,EAAEL,MAAM,CAAC/H,IAAI,EAAE+W,QAAQ,EAAEC,eAAe,EAAEC,cAAc,CAAC;QAChH,IAAI,CAACzR,gBAAgB,CAAC2R,aAAa,CAACpP,MAAM,CAACM,WAAW,EAAEN,MAAM,CAACO,WAAW,EAAEP,MAAM,CAAC/H,IAAI,CAACtD,MAAM,EAAEqL,MAAM,CAAC+L,gBAAgB,CAAC;MAC5H;MACA,MAAMsD,iBAAiB,GAAG,EAAE;MAC5B,IAAI,CAAC9N,kBAAkB,EAAE;MACzB,IAAIoC,SAAS,GAAGiL,YAAY;MAC5B,KAAK,IAAI1Z,CAAC,GAAG,CAAC,EAAEgN,GAAG,GAAG4M,cAAc,CAACna,MAAM,EAAEO,CAAC,GAAGgN,GAAG,EAAEhN,CAAC,EAAE,EAAE;QACvD,MAAM8K,MAAM,GAAG8O,cAAc,CAAC5Z,CAAC,CAAC;QAChC,MAAM,CAAC8Z,QAAQ,CAAC,GAAGhZ,QAAQ,CAACgK,MAAM,CAAC/H,IAAI,CAAC;QACxC,IAAI,CAACwC,uBAAuB,CAACwD,IAAI,EAAE;QACnC,MAAMwE,eAAe,GAAGzC,MAAM,CAACK,KAAK,CAACoC,eAAe;QACpD,MAAMrB,aAAa,GAAGpB,MAAM,CAACK,KAAK,CAACe,aAAa;QAChD,MAAMkO,gBAAgB,GAAGlO,aAAa,GAAGqB,eAAe;QACxD,MAAM8M,iBAAiB,GAAGP,QAAQ;QAClC,MAAMQ,eAAe,GAAGxJ,IAAI,CAACC,GAAG,CAACqJ,gBAAgB,EAAEC,iBAAiB,CAAC;QACrE,MAAME,oBAAoB,GAAIF,iBAAiB,GAAGD,gBAAiB;QACnE,MAAMI,0BAA0B,GAAGb,YAAY,GAAGlL,SAAS,GAAG8L,oBAAoB,GAAGhN,eAAe;QACpG,MAAMkN,mBAAmB,GAAGD,0BAA0B;QACtD,MAAME,sBAAsB,GAAGF,0BAA0B,GAAGH,iBAAiB;QAC7E,MAAMM,wCAAwC,GAAG,IAAI,CAACpS,gBAAgB,CAACqS,yBAAyB,CAAC,IAAI,EAAE,IAAI,CAACtN,WAAW,CAAC,IAAItM,QAAQ,CAACyZ,mBAAmB,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAACnN,WAAW,CAAC,IAAItM,QAAQ,CAAC0Z,sBAAsB,EAAE,IAAI,CAACtO,gBAAgB,CAACsO,sBAAsB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QACxQ,MAAMG,yBAAyB,GAAGxY,gBAAgB,CAACyY,eAAe,CAACH,wCAAwC,CAAC;QAC5G,MAAMI,8BAA8B,GAAG,IAAI1a,UAAU,CAACwa,yBAAyB,CAAC;QAChF,KAAK,IAAIlD,CAAC,GAAG2C,eAAe,EAAE3C,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UACvC,MAAMqD,cAAc,GAAGzN,eAAe,GAAGoK,CAAC;UAC1C,MAAMsD,qBAAqB,GAAGT,0BAA0B,GAAG7C,CAAC;UAC5DoD,8BAA8B,CAACG,gBAAgB,CAACxb,CAAC,IAAIA,CAAC,CAACgP,UAAU,GAAGuM,qBAAqB,CAAC;UAC1F,MAAME,wBAAwB,GAAGJ,8BAA8B,CAACG,gBAAgB,CAACxb,CAAC,IAAIA,CAAC,CAACgP,UAAU,KAAKuM,qBAAqB,CAAC;UAC7Hd,iBAAiB,CAAC/E,IAAI,CAAC,IAAI1S,mBAAmB,CAACsY,cAAc,EAAE,IAAI,CAAC/I,cAAc,CAACgJ,qBAAqB,CAAC,EAAEE,wBAAwB,CAAC,CAAC;QACzI;QACA,IAAIb,eAAe,GAAGF,gBAAgB,EAAE;UACpC;UACA,MAAMgB,qBAAqB,GAAG7N,eAAe,GAAG+M,eAAe;UAC/DH,iBAAiB,CAAC/E,IAAI,CAAC,IAAIzS,oBAAoB,CAACyY,qBAAqB,GAAG,CAAC,EAAElP,aAAa,CAAC,CAAC;QAC9F;QACA,IAAIoO,eAAe,GAAGD,iBAAiB,EAAE;UACrC,MAAMU,8BAA8B,GAAG,IAAI1a,UAAU,CAACwa,yBAAyB,CAAC;UAChF;UACA,MAAMQ,gBAAgB,GAAG9N,eAAe,GAAG+M,eAAe;UAC1D,MAAMgB,GAAG,GAAGjB,iBAAiB,GAAGC,eAAe;UAC/C,MAAMiB,cAAc,GAAG5B,YAAY,GAAGlL,SAAS,GAAG6M,GAAG,GAAGD,gBAAgB,GAAG,CAAC;UAC5E,MAAMG,aAAa,GAAG,EAAE;UACxB,MAAMC,QAAQ,GAAG,EAAE;UACnB,KAAK,IAAIzb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsb,GAAG,EAAEtb,CAAC,EAAE,EAAE;YAC1B,MAAM0O,UAAU,GAAG6M,cAAc,GAAGvb,CAAC;YACrCyb,QAAQ,CAACzb,CAAC,CAAC,GAAG,IAAI,CAACiS,cAAc,CAACvD,UAAU,CAAC;YAC7CqM,8BAA8B,CAACW,SAAS,CAAChc,CAAC,IAAIA,CAAC,CAACgP,UAAU,GAAGA,UAAU,CAAC;YACxE8M,aAAa,CAACxb,CAAC,CAAC,GAAG+a,8BAA8B,CAACW,SAAS,CAAChc,CAAC,IAAIA,CAAC,CAACgP,UAAU,KAAKA,UAAU,CAAC;UACjG;UACAyL,iBAAiB,CAAC/E,IAAI,CAAC,IAAIxS,qBAAqB,CAACyY,gBAAgB,GAAG,CAAC,EAAE9N,eAAe,GAAG8M,iBAAiB,EAAEoB,QAAQ,EAAED,aAAa,CAAC,CAAC;QACzI;QACA/M,SAAS,IAAI8L,oBAAoB;MACrC;MACA,IAAI,CAAC3P,wBAAwB,CAAC,IAAIrI,2BAA2B,CAAC4X,iBAAiB,EAAE,IAAI,CAACtO,YAAY,EAAE,EAAE,IAAI,CAACnD,UAAU,EAAE,IAAI,CAACC,UAAU,CAAC,EAAE;QACrI8C,OAAO,EAAEmO,cAAc;QACvBlO,GAAG,EAAE,IAAI,CAAC/E,OAAO,CAACgF,MAAM,EAAE;QAC1BC,SAAS,EAAE,IAAI,CAACC,YAAY,EAAE;QAC9BP,SAAS,EAAE,IAAI,CAAC5C,UAAU;QAC1B6C,SAAS,EAAE,IAAI,CAAC5C,UAAU;QAC1B6C,OAAO,EAAE;MACb,CAAC,CAAC;IACN;IACA,OAAQnH,MAAM,CAACsX,YAAY,KAAK,IAAI,GAAG5N,SAAS,GAAG1J,MAAM,CAACsX,YAAY;EAC1E;EACAC,IAAI,GAAG;IACH,OAAO,IAAI,CAAC5W,gBAAgB,CAAC4W,IAAI,CAAC,IAAI,CAAChN,GAAG,CAAC;EAC/C;EACAiN,OAAO,GAAG;IACN,OAAO,IAAI,CAAC7W,gBAAgB,CAAC6W,OAAO,CAAC,IAAI,CAACjN,GAAG,CAAC;EAClD;EACAkN,IAAI,GAAG;IACH,OAAO,IAAI,CAAC9W,gBAAgB,CAAC8W,IAAI,CAAC,IAAI,CAAClN,GAAG,CAAC;EAC/C;EACAmN,OAAO,GAAG;IACN,OAAO,IAAI,CAAC/W,gBAAgB,CAAC+W,OAAO,CAAC,IAAI,CAACnN,GAAG,CAAC;EAClD;EACA;EACA;EACAlJ,uCAAuC,CAACD,yBAAyB,EAAE;IAC/D;IACA,IAAIA,yBAAyB,KAAK,IAAI,IAAIA,yBAAyB,CAACuW,IAAI,KAAK,CAAC,EAAE;MAC5E;IACJ;IACA,MAAMC,aAAa,GAAGtH,KAAK,CAACuH,IAAI,CAACzW,yBAAyB,CAAC;IAC3D,MAAM0W,gBAAgB,GAAGF,aAAa,CAAC/L,GAAG,CAACxB,UAAU,IAAI,IAAIhM,mBAAmB,CAACgM,UAAU,EAAE,IAAI,CAACuD,cAAc,CAACvD,UAAU,CAAC,EAAE,IAAI,CAAC0N,sBAAsB,CAAC1N,UAAU,CAAC,CAAC,CAAC;IACvK,IAAI,CAAC1I,wBAAwB,CAAC+C,IAAI,CAAC,IAAIzG,6BAA6B,CAAC6Z,gBAAgB,CAAC,CAAC;EAC3F;EACAE,iBAAiB,CAACC,QAAQ,EAAe;IAAA,IAAbC,OAAO,uEAAG,CAAC;IACnC,IAAI,CAAC5R,kBAAkB,EAAE;IACzB,IAAI;MACA,IAAI,CAACpF,uBAAuB,CAACuD,iBAAiB,EAAE;MAChD,OAAO,IAAI,CAAC0T,kBAAkB,CAACD,OAAO,EAAED,QAAQ,CAAC;IACrD,CAAC,SACO;MACJ,IAAI,CAAC/W,uBAAuB,CAACyD,eAAe,EAAE;IAClD;EACJ;EACAwT,kBAAkB,CAACD,OAAO,EAAED,QAAQ,EAAE;IAClC,MAAMG,cAAc,GAAG;MACnBC,aAAa,EAAE,CAACvR,KAAK,EAAElC,OAAO,KAAK;QAC/B,OAAO,IAAI,CAAC0T,qBAAqB,CAACJ,OAAO,EAAE,EAAE,EAAE,CAAC;UAAEpR,KAAK,EAAEA,KAAK;UAAElC,OAAO,EAAEA;QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC3F,CAAC;MACD2T,gBAAgB,EAAE,CAACxW,EAAE,EAAEyW,QAAQ,KAAK;QAChC,IAAI,CAACC,qBAAqB,CAAC1W,EAAE,EAAEyW,QAAQ,CAAC;MAC5C,CAAC;MACDE,uBAAuB,EAAE,CAAC3W,EAAE,EAAE6C,OAAO,KAAK;QACtC,IAAI,CAAC+T,4BAA4B,CAAC5W,EAAE,EAAE6W,iBAAiB,CAAChU,OAAO,CAAC,CAAC;MACrE,CAAC;MACDiU,gBAAgB,EAAG9W,EAAE,IAAK;QACtB,IAAI,CAACuW,qBAAqB,CAACJ,OAAO,EAAE,CAACnW,EAAE,CAAC,EAAE,EAAE,CAAC;MACjD,CAAC;MACD+W,gBAAgB,EAAE,CAACC,cAAc,EAAEC,cAAc,KAAK;QAClD,IAAID,cAAc,CAAC3d,MAAM,KAAK,CAAC,IAAI4d,cAAc,CAAC5d,MAAM,KAAK,CAAC,EAAE;UAC5D;UACA,OAAO,EAAE;QACb;QACA,OAAO,IAAI,CAACkd,qBAAqB,CAACJ,OAAO,EAAEa,cAAc,EAAEC,cAAc,CAAC;MAC9E;IACJ,CAAC;IACD,IAAIhZ,MAAM,GAAG,IAAI;IACjB,IAAI;MACAA,MAAM,GAAGiY,QAAQ,CAACG,cAAc,CAAC;IACrC,CAAC,CACD,OAAOzS,CAAC,EAAE;MACNxJ,iBAAiB,CAACwJ,CAAC,CAAC;IACxB;IACA;IACAyS,cAAc,CAACC,aAAa,GAAGhY,WAAW;IAC1C+X,cAAc,CAACG,gBAAgB,GAAGlY,WAAW;IAC7C+X,cAAc,CAACM,uBAAuB,GAAGrY,WAAW;IACpD+X,cAAc,CAACS,gBAAgB,GAAGxY,WAAW;IAC7C+X,cAAc,CAACU,gBAAgB,GAAGzY,WAAW;IAC7C,OAAOL,MAAM;EACjB;EACA8Y,gBAAgB,CAACC,cAAc,EAAEC,cAAc,EAAe;IAAA,IAAbd,OAAO,uEAAG,CAAC;IACxD,IAAI,CAAC5R,kBAAkB,EAAE;IACzB,IAAI,CAACyS,cAAc,EAAE;MACjBA,cAAc,GAAG,EAAE;IACvB;IACA,IAAIA,cAAc,CAAC3d,MAAM,KAAK,CAAC,IAAI4d,cAAc,CAAC5d,MAAM,KAAK,CAAC,EAAE;MAC5D;MACA,OAAO,EAAE;IACb;IACA,IAAI;MACA,IAAI,CAAC0G,uBAAuB,EAAE;MAC9B,IAAI,IAAI,CAACA,uBAAuB,GAAG,CAAC,EAAE;QAClCmX,OAAO,CAACC,IAAI,CAAE,0EAAyE,CAAC;QACxF/c,iBAAiB,CAAC,IAAImE,KAAK,CAAE,0EAAyE,CAAC,CAAC;MAC5G;MACA,IAAI,CAACY,uBAAuB,CAACuD,iBAAiB,EAAE;MAChD,OAAO,IAAI,CAAC6T,qBAAqB,CAACJ,OAAO,EAAEa,cAAc,EAAEC,cAAc,CAAC;IAC9E,CAAC,SACO;MACJ,IAAI,CAAC9X,uBAAuB,CAACyD,eAAe,EAAE;MAC9C,IAAI,CAAC7C,uBAAuB,EAAE;IAClC;EACJ;EACAqX,gBAAgB,CAACpX,EAAE,EAAE;IACjB,OAAO,IAAI,CAACqX,kBAAkB,CAACrX,EAAE,CAAC;EACtC;EACAsX,gBAAgB,CAACtX,EAAE,EAAEyW,QAAQ,EAAEc,aAAa,EAAE;IAC1C,MAAM1Q,IAAI,GAAI7G,EAAE,GAAG,IAAI,CAACkC,YAAY,CAAClC,EAAE,CAAC,GAAG,IAAK;IAChD,IAAI,CAAC6G,IAAI,EAAE;MACP,IAAI,CAAC4P,QAAQ,EAAE;QACX;QACA,OAAO,IAAI;MACf;MACA;MACA,OAAO,IAAI,CAACF,qBAAqB,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC;QAAExR,KAAK,EAAE0R,QAAQ;QAAE5T,OAAO,EAAE2U,qBAAqB,CAACD,aAAa;MAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACrH;IACA,IAAI,CAACd,QAAQ,EAAE;MACX;MACA,IAAI,CAACtU,gBAAgB,CAACsV,MAAM,CAAC5Q,IAAI,CAAC;MAClC,OAAO,IAAI,CAAC3E,YAAY,CAAC2E,IAAI,CAAC7G,EAAE,CAAC;MACjC,OAAO,IAAI;IACf;IACA;IACA,MAAM+E,KAAK,GAAG,IAAI,CAACoH,kCAAkC,CAACsK,QAAQ,CAAC;IAC/D,MAAMxP,WAAW,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW,CAACnC,KAAK,CAACoC,eAAe,EAAEpC,KAAK,CAACqC,WAAW,CAAC;IACtF,MAAMC,SAAS,GAAG,IAAI,CAAC9G,OAAO,CAAC2G,WAAW,CAACnC,KAAK,CAACe,aAAa,EAAEf,KAAK,CAACgB,SAAS,CAAC;IAChF,IAAI,CAAC5D,gBAAgB,CAACsV,MAAM,CAAC5Q,IAAI,CAAC;IAClCA,IAAI,CAAC6Q,KAAK,CAAC,IAAI,CAACjS,YAAY,EAAE,EAAEwB,WAAW,EAAEI,SAAS,EAAEtC,KAAK,CAAC;IAC9D8B,IAAI,CAAC8Q,UAAU,CAACH,qBAAqB,CAACD,aAAa,CAAC,CAAC;IACrD,IAAI,CAACpV,gBAAgB,CAACyV,MAAM,CAAC/Q,IAAI,CAAC;IAClC,OAAOA,IAAI,CAAC7G,EAAE;EAClB;EACA6X,+BAA+B,CAAC1B,OAAO,EAAE;IACrC,IAAI,IAAI,CAACtU,WAAW,EAAE;MAClB;IACJ;IACA,MAAMiW,KAAK,GAAG,IAAI,CAAC3V,gBAAgB,CAAC4V,qBAAqB,CAAC5B,OAAO,CAAC;IAClE,KAAK,IAAIvc,CAAC,GAAG,CAAC,EAAEgN,GAAG,GAAGkR,KAAK,CAACze,MAAM,EAAEO,CAAC,GAAGgN,GAAG,EAAEhN,CAAC,EAAE,EAAE;MAC9C,MAAMiN,IAAI,GAAGiR,KAAK,CAACle,CAAC,CAAC;MACrB,IAAI,CAACuI,gBAAgB,CAACsV,MAAM,CAAC5Q,IAAI,CAAC;MAClC,OAAO,IAAI,CAAC3E,YAAY,CAAC2E,IAAI,CAAC7G,EAAE,CAAC;IACrC;EACJ;EACAgY,oBAAoB,CAACC,YAAY,EAAE;IAC/B,MAAMpR,IAAI,GAAG,IAAI,CAAC3E,YAAY,CAAC+V,YAAY,CAAC;IAC5C,IAAI,CAACpR,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,OAAOA,IAAI,CAAChE,OAAO;EACvB;EACAwU,kBAAkB,CAACY,YAAY,EAAE;IAC7B,MAAMpR,IAAI,GAAG,IAAI,CAAC3E,YAAY,CAAC+V,YAAY,CAAC;IAC5C,IAAI,CAACpR,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,OAAO,IAAI,CAAC1E,gBAAgB,CAAC+V,YAAY,CAAC,IAAI,EAAErR,IAAI,CAAC;EACzD;EACAsR,kBAAkB,CAAC7P,UAAU,EAA4C;IAAA,IAA1C6N,OAAO,uEAAG,CAAC;IAAA,IAAEiC,mBAAmB,uEAAG,KAAK;IACnE,IAAI9P,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAACtH,YAAY,EAAE,EAAE;MACpD,OAAO,EAAE;IACb;IACA,OAAO,IAAI,CAACqX,mBAAmB,CAAC/P,UAAU,EAAEA,UAAU,EAAE6N,OAAO,EAAEiC,mBAAmB,CAAC;EACzF;EACAC,mBAAmB,CAACC,gBAAgB,EAAEC,cAAc,EAA4C;IAAA,IAA1CpC,OAAO,uEAAG,CAAC;IAAA,IAAEiC,mBAAmB,uEAAG,KAAK;IAC1F,MAAM/P,SAAS,GAAG,IAAI,CAACrH,YAAY,EAAE;IACrC,MAAMmG,eAAe,GAAGuD,IAAI,CAACC,GAAG,CAACtC,SAAS,EAAEqC,IAAI,CAACG,GAAG,CAAC,CAAC,EAAEyN,gBAAgB,CAAC,CAAC;IAC1E,MAAMxS,aAAa,GAAG4E,IAAI,CAACC,GAAG,CAACtC,SAAS,EAAEqC,IAAI,CAACG,GAAG,CAAC,CAAC,EAAE0N,cAAc,CAAC,CAAC;IACtE,MAAMxS,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,aAAa,CAAC;IACtD,MAAMf,KAAK,GAAG,IAAIlK,KAAK,CAACsM,eAAe,EAAE,CAAC,EAAErB,aAAa,EAAEC,SAAS,CAAC;IACrE,MAAMyS,WAAW,GAAG,IAAI,CAACC,sBAAsB,CAAC1T,KAAK,EAAEoR,OAAO,EAAEiC,mBAAmB,CAAC;IACpFle,QAAQ,CAACse,WAAW,EAAE,IAAI,CAAC3X,mBAAmB,CAAC6X,qBAAqB,CAAC3T,KAAK,EAAEoR,OAAO,EAAEiC,mBAAmB,CAAC,CAAC;IAC1G,OAAOI,WAAW;EACtB;EACAE,qBAAqB,CAAC3T,KAAK,EAA4C;IAAA,IAA1CoR,OAAO,uEAAG,CAAC;IAAA,IAAEiC,mBAAmB,uEAAG,KAAK;IACjE,MAAMO,cAAc,GAAG,IAAI,CAAChN,aAAa,CAAC5G,KAAK,CAAC;IAChD,MAAMyT,WAAW,GAAG,IAAI,CAACC,sBAAsB,CAACE,cAAc,EAAExC,OAAO,EAAEiC,mBAAmB,CAAC;IAC7Fle,QAAQ,CAACse,WAAW,EAAE,IAAI,CAAC3X,mBAAmB,CAAC6X,qBAAqB,CAACC,cAAc,EAAExC,OAAO,EAAEiC,mBAAmB,CAAC,CAAC;IACnH,OAAOI,WAAW;EACtB;EACAI,2BAA2B,GAA2C;IAAA,IAA1CzC,OAAO,uEAAG,CAAC;IAAA,IAAEiC,mBAAmB,uEAAG,KAAK;IAChE,OAAO,IAAI,CAACjW,gBAAgB,CAAC0W,MAAM,CAAC,IAAI,EAAE1C,OAAO,EAAEiC,mBAAmB,EAAE,IAAI,CAAC;EACjF;EACAU,0BAA0B,GAAc;IAAA,IAAb3C,OAAO,uEAAG,CAAC;IAClC,OAAO,IAAI,CAAChU,gBAAgB,CAAC4W,kBAAkB,CAAC,IAAI,EAAE5C,OAAO,CAAC;EAClE;EACAH,sBAAsB,CAAC1N,UAAU,EAAE;IAC/B,MAAMrB,WAAW,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW,CAACoB,UAAU,EAAE,CAAC,CAAC;IAC3D,MAAMjB,SAAS,GAAGJ,WAAW,GAAG,IAAI,CAAC1G,OAAO,CAACY,aAAa,CAACmH,UAAU,CAAC;IACtE,MAAMrK,MAAM,GAAG,IAAI,CAACkE,gBAAgB,CAACqS,yBAAyB,CAAC,IAAI,EAAEvN,WAAW,EAAEI,SAAS,EAAE,CAAC,CAAC;IAC/F,OAAOpL,gBAAgB,CAACyY,eAAe,CAACzW,MAAM,CAAC,CAAC+a,MAAM,CAACC,CAAC,IAAIA,CAAC,CAAC3Q,UAAU,KAAKA,UAAU,CAAC;EAC5F;EACA4Q,iBAAiB,GAA2C;IAAA,IAA1C/C,OAAO,uEAAG,CAAC;IAAA,IAAEiC,mBAAmB,uEAAG,KAAK;IACtD,IAAIna,MAAM,GAAG,IAAI,CAACkE,gBAAgB,CAAC0W,MAAM,CAAC,IAAI,EAAE1C,OAAO,EAAEiC,mBAAmB,EAAE,KAAK,CAAC;IACpFna,MAAM,GAAGA,MAAM,CAAC0R,MAAM,CAAC,IAAI,CAAC9O,mBAAmB,CAACqY,iBAAiB,CAAC/C,OAAO,EAAEiC,mBAAmB,CAAC,CAAC;IAChG,OAAOna,MAAM;EACjB;EACAwa,sBAAsB,CAACU,WAAW,EAAEC,aAAa,EAAEhB,mBAAmB,EAAE;IACpE,MAAMnR,WAAW,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW,CAACiS,WAAW,CAAChS,eAAe,EAAEgS,WAAW,CAAC/R,WAAW,CAAC;IAClG,MAAMC,SAAS,GAAG,IAAI,CAAC9G,OAAO,CAAC2G,WAAW,CAACiS,WAAW,CAACrT,aAAa,EAAEqT,WAAW,CAACpT,SAAS,CAAC;IAC5F,OAAO,IAAI,CAAC5D,gBAAgB,CAACkX,gBAAgB,CAAC,IAAI,EAAEpS,WAAW,EAAEI,SAAS,EAAE+R,aAAa,EAAEhB,mBAAmB,CAAC;EACnH;EACAkB,UAAU,CAACtS,KAAK,EAAEQ,GAAG,EAAE;IACnB,OAAO,IAAI,CAACjH,OAAO,CAAC+Y,UAAU,CAACtS,KAAK,EAAEQ,GAAG,GAAGR,KAAK,CAAC;EACtD;EACA0P,qBAAqB,CAACuB,YAAY,EAAExK,MAAM,EAAE;IACxC,MAAM5G,IAAI,GAAG,IAAI,CAAC3E,YAAY,CAAC+V,YAAY,CAAC;IAC5C,IAAI,CAACpR,IAAI,EAAE;MACP;IACJ;IACA,IAAIA,IAAI,CAAChE,OAAO,CAAC0W,KAAK,EAAE;MACpB,MAAMC,QAAQ,GAAG,IAAI,CAACnC,kBAAkB,CAACY,YAAY,CAAC;MACtD,IAAI,CAAC9Y,uBAAuB,CAACsa,gCAAgC,CAACD,QAAQ,CAAC1T,aAAa,CAAC;IACzF;IACA,IAAIe,IAAI,CAAChE,OAAO,CAAC6W,MAAM,EAAE;MACrB,MAAMF,QAAQ,GAAG,IAAI,CAACnC,kBAAkB,CAACY,YAAY,CAAC;MACtD,IAAI,CAAC9Y,uBAAuB,CAACsa,gCAAgC,CAACD,QAAQ,CAACrS,eAAe,CAAC;IAC3F;IACA,MAAMpC,KAAK,GAAG,IAAI,CAACoH,kCAAkC,CAACsB,MAAM,CAAC;IAC7D,MAAMxG,WAAW,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW,CAACnC,KAAK,CAACoC,eAAe,EAAEpC,KAAK,CAACqC,WAAW,CAAC;IACtF,MAAMC,SAAS,GAAG,IAAI,CAAC9G,OAAO,CAAC2G,WAAW,CAACnC,KAAK,CAACe,aAAa,EAAEf,KAAK,CAACgB,SAAS,CAAC;IAChF,IAAI,CAAC5D,gBAAgB,CAACsV,MAAM,CAAC5Q,IAAI,CAAC;IAClCA,IAAI,CAAC6Q,KAAK,CAAC,IAAI,CAACjS,YAAY,EAAE,EAAEwB,WAAW,EAAEI,SAAS,EAAEtC,KAAK,CAAC;IAC9D,IAAI,CAAC5C,gBAAgB,CAACyV,MAAM,CAAC/Q,IAAI,CAAC;IAClC,IAAI,CAAC1H,uBAAuB,CAACwa,oBAAoB,CAAC9S,IAAI,CAAChE,OAAO,CAAC;IAC/D,IAAIgE,IAAI,CAAChE,OAAO,CAAC0W,KAAK,EAAE;MACpB,IAAI,CAACpa,uBAAuB,CAACsa,gCAAgC,CAAC1U,KAAK,CAACe,aAAa,CAAC;IACtF;IACA,IAAIe,IAAI,CAAChE,OAAO,CAAC6W,MAAM,EAAE;MACrB,IAAI,CAACva,uBAAuB,CAACsa,gCAAgC,CAAC1U,KAAK,CAACoC,eAAe,CAAC;IACxF;EACJ;EACAyP,4BAA4B,CAACqB,YAAY,EAAEpV,OAAO,EAAE;IAChD,MAAMgE,IAAI,GAAG,IAAI,CAAC3E,YAAY,CAAC+V,YAAY,CAAC;IAC5C,IAAI,CAACpR,IAAI,EAAE;MACP;IACJ;IACA,MAAM+S,sBAAsB,GAAI/S,IAAI,CAAChE,OAAO,CAACgX,aAAa,IAAIhT,IAAI,CAAChE,OAAO,CAACgX,aAAa,CAACC,KAAK,GAAG,IAAI,GAAG,KAAM;IAC9G,MAAMC,qBAAqB,GAAIlX,OAAO,CAACgX,aAAa,IAAIhX,OAAO,CAACgX,aAAa,CAACC,KAAK,GAAG,IAAI,GAAG,KAAM;IACnG,IAAI,CAAC3a,uBAAuB,CAACwa,oBAAoB,CAAC9S,IAAI,CAAChE,OAAO,CAAC;IAC/D,IAAI,CAAC1D,uBAAuB,CAACwa,oBAAoB,CAAC9W,OAAO,CAAC;IAC1D,IAAIgE,IAAI,CAAChE,OAAO,CAAC0W,KAAK,IAAI1W,OAAO,CAAC0W,KAAK,EAAE;MACrC,MAAMS,SAAS,GAAG,IAAI,CAAC7X,gBAAgB,CAAC+V,YAAY,CAAC,IAAI,EAAErR,IAAI,CAAC;MAChE,IAAI,CAAC1H,uBAAuB,CAACsa,gCAAgC,CAACO,SAAS,CAAClU,aAAa,CAAC;IAC1F;IACA,IAAIe,IAAI,CAAChE,OAAO,CAAC6W,MAAM,IAAI7W,OAAO,CAAC6W,MAAM,EAAE;MACvC,MAAMM,SAAS,GAAG,IAAI,CAAC7X,gBAAgB,CAAC+V,YAAY,CAAC,IAAI,EAAErR,IAAI,CAAC;MAChE,IAAI,CAAC1H,uBAAuB,CAACsa,gCAAgC,CAACO,SAAS,CAAC7S,eAAe,CAAC;IAC5F;IACA,IAAIyS,sBAAsB,KAAKG,qBAAqB,EAAE;MAClD;MACA,IAAI,CAAC5X,gBAAgB,CAACsV,MAAM,CAAC5Q,IAAI,CAAC;MAClCA,IAAI,CAAC8Q,UAAU,CAAC9U,OAAO,CAAC;MACxB,IAAI,CAACV,gBAAgB,CAACyV,MAAM,CAAC/Q,IAAI,CAAC;IACtC,CAAC,MACI;MACDA,IAAI,CAAC8Q,UAAU,CAAC9U,OAAO,CAAC;IAC5B;EACJ;EACA0T,qBAAqB,CAACJ,OAAO,EAAE8D,iBAAiB,EAAEhD,cAAc,EAAE;IAC9D,MAAMzR,SAAS,GAAG,IAAI,CAACC,YAAY,EAAE;IACrC,MAAMyU,iBAAiB,GAAGD,iBAAiB,CAAC5gB,MAAM;IAClD,IAAI8gB,kBAAkB,GAAG,CAAC;IAC1B,MAAMC,iBAAiB,GAAGnD,cAAc,CAAC5d,MAAM;IAC/C,IAAIghB,kBAAkB,GAAG,CAAC;IAC1B,MAAMpc,MAAM,GAAG,IAAIsQ,KAAK,CAAC6L,iBAAiB,CAAC;IAC3C,OAAOD,kBAAkB,GAAGD,iBAAiB,IAAIG,kBAAkB,GAAGD,iBAAiB,EAAE;MACrF,IAAIvT,IAAI,GAAG,IAAI;MACf,IAAIsT,kBAAkB,GAAGD,iBAAiB,EAAE;QACxC;QACA,GAAG;UACCrT,IAAI,GAAG,IAAI,CAAC3E,YAAY,CAAC+X,iBAAiB,CAACE,kBAAkB,EAAE,CAAC,CAAC;QACrE,CAAC,QAAQ,CAACtT,IAAI,IAAIsT,kBAAkB,GAAGD,iBAAiB;QACxD;QACA,IAAIrT,IAAI,EAAE;UACN,IAAIA,IAAI,CAAChE,OAAO,CAAC0W,KAAK,EAAE;YACpB,MAAMS,SAAS,GAAG,IAAI,CAAC7X,gBAAgB,CAAC+V,YAAY,CAAC,IAAI,EAAErR,IAAI,CAAC;YAChE,IAAI,CAAC1H,uBAAuB,CAACsa,gCAAgC,CAACO,SAAS,CAAClU,aAAa,CAAC;UAC1F;UACA,IAAIe,IAAI,CAAChE,OAAO,CAAC6W,MAAM,EAAE;YACrB,MAAMM,SAAS,GAAG,IAAI,CAAC7X,gBAAgB,CAAC+V,YAAY,CAAC,IAAI,EAAErR,IAAI,CAAC;YAChE,IAAI,CAAC1H,uBAAuB,CAACsa,gCAAgC,CAACO,SAAS,CAAC7S,eAAe,CAAC;UAC5F;UACA,IAAI,CAAChF,gBAAgB,CAACsV,MAAM,CAAC5Q,IAAI,CAAC;UAClC,IAAI,CAAC1H,uBAAuB,CAACwa,oBAAoB,CAAC9S,IAAI,CAAChE,OAAO,CAAC;QACnE;MACJ;MACA,IAAIwX,kBAAkB,GAAGD,iBAAiB,EAAE;QACxC;QACA,IAAI,CAACvT,IAAI,EAAE;UACP,MAAMyT,oBAAoB,GAAI,EAAE,IAAI,CAACrY,iBAAkB;UACvD,MAAMgW,YAAY,GAAI,GAAE,IAAI,CAAClW,WAAY,IAAGuY,oBAAqB,EAAC;UAClEzT,IAAI,GAAG,IAAIrL,YAAY,CAACyc,YAAY,EAAE,CAAC,EAAE,CAAC,CAAC;UAC3C,IAAI,CAAC/V,YAAY,CAAC+V,YAAY,CAAC,GAAGpR,IAAI;QAC1C;QACA;QACA,MAAM0T,aAAa,GAAGtD,cAAc,CAACoD,kBAAkB,CAAC;QACxD,MAAMtV,KAAK,GAAG,IAAI,CAACoH,kCAAkC,CAACoO,aAAa,CAACxV,KAAK,CAAC;QAC1E,MAAMlC,OAAO,GAAGgU,iBAAiB,CAAC0D,aAAa,CAAC1X,OAAO,CAAC;QACxD,MAAMoE,WAAW,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW,CAACnC,KAAK,CAACoC,eAAe,EAAEpC,KAAK,CAACqC,WAAW,CAAC;QACtF,MAAMC,SAAS,GAAG,IAAI,CAAC9G,OAAO,CAAC2G,WAAW,CAACnC,KAAK,CAACe,aAAa,EAAEf,KAAK,CAACgB,SAAS,CAAC;QAChFc,IAAI,CAACsP,OAAO,GAAGA,OAAO;QACtBtP,IAAI,CAAC6Q,KAAK,CAAClS,SAAS,EAAEyB,WAAW,EAAEI,SAAS,EAAEtC,KAAK,CAAC;QACpD8B,IAAI,CAAC8Q,UAAU,CAAC9U,OAAO,CAAC;QACxB,IAAIgE,IAAI,CAAChE,OAAO,CAAC0W,KAAK,EAAE;UACpB,IAAI,CAACpa,uBAAuB,CAACsa,gCAAgC,CAAC1U,KAAK,CAACe,aAAa,CAAC;QACtF;QACA,IAAIe,IAAI,CAAChE,OAAO,CAAC6W,MAAM,EAAE;UACrB,IAAI,CAACva,uBAAuB,CAACsa,gCAAgC,CAAC1U,KAAK,CAACoC,eAAe,CAAC;QACxF;QACA,IAAI,CAAChI,uBAAuB,CAACwa,oBAAoB,CAAC9W,OAAO,CAAC;QAC1D,IAAI,CAACV,gBAAgB,CAACyV,MAAM,CAAC/Q,IAAI,CAAC;QAClC5I,MAAM,CAACoc,kBAAkB,CAAC,GAAGxT,IAAI,CAAC7G,EAAE;QACpCqa,kBAAkB,EAAE;MACxB,CAAC,MACI;QACD,IAAIxT,IAAI,EAAE;UACN,OAAO,IAAI,CAAC3E,YAAY,CAAC2E,IAAI,CAAC7G,EAAE,CAAC;QACrC;MACJ;IACJ;IACA,OAAO/B,MAAM;EACjB;EACA;EACA;EACA;EACAuc,aAAa,GAAG;IACZ,OAAO,IAAI,CAACvW,YAAY,CAACuW,aAAa,EAAE;EAC5C;EACAC,OAAO,CAAChc,UAAU,EAAE;IAChB,IAAI,CAACwF,YAAY,CAACyW,aAAa,CAACjc,UAAU,CAAC;EAC/C;EACAkc,uBAAuB,CAACrS,UAAU,EAAEgC,MAAM,EAAE;IACxC,OAAO,IAAI,CAACrG,YAAY,CAAC0W,uBAAuB,CAACrS,UAAU,EAAEgC,MAAM,CAAC;EACxE;EACAsQ,iBAAiB,CAACxQ,QAAQ,EAAE;IACxB,OAAO,IAAI,CAACtJ,0BAA0B,CAAC8Z,iBAAiB,CAACxQ,QAAQ,CAAC;EACtE;EACAyQ,oBAAoB,CAACzQ,QAAQ,EAAE;IAC3B,OAAO,IAAI,CAACtJ,0BAA0B,CAAC+Z,oBAAoB,CAACzQ,QAAQ,CAAC;EACzE;EACA;EACA0Q,iBAAiB,CAAC1Q,QAAQ,EAAE2Q,QAAQ,EAAE;IAClC,OAAO3Q,QAAQ;EACnB;EACA;AACJ;AACA;AACA;EACI4Q,mBAAmB,CAAC1S,UAAU,EAAE;IAC5B;IACA,OAAO2S,YAAY,CAAC,IAAI,CAACpP,cAAc,CAACvD,UAAU,CAAC,CAAC,GAAG,CAAC;EAC5D;AACJ,CAAC;AACD9J,SAAS,CAACiD,gBAAgB,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC;AAC/CjD,SAAS,CAAC8C,yBAAyB,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC;AACxD9C,SAAS,CAAC+C,+BAA+B,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC;AACxD/C,SAAS,CAAC0c,wBAAwB,GAAG;EACjCjb,iBAAiB,EAAE,KAAK;EACxB+C,OAAO,EAAEjI,qBAAqB,CAACiI,OAAO;EACtCG,UAAU,EAAEpI,qBAAqB,CAACoI,UAAU;EAC5CF,YAAY,EAAElI,qBAAqB,CAACkI,YAAY;EAChDH,iBAAiB,EAAE,KAAK;EACxBzF,UAAU,EAAE,CAAC,CAAC;EACd+F,kBAAkB,EAAErI,qBAAqB,CAACqI,kBAAkB;EAC5DhC,sBAAsB,EAAErG,qBAAqB,CAACqG,sBAAsB;EACpEiC,8BAA8B,EAAEtI,qBAAqB,CAACsI;AAC1D,CAAC;AACD7E,SAAS,GAAG1F,UAAU,CAAC,CACnBgB,OAAO,CAAC,CAAC,EAAE2C,gBAAgB,CAAC,EAC5B3C,OAAO,CAAC,CAAC,EAAEkB,gBAAgB,CAAC,EAC5BlB,OAAO,CAAC,CAAC,EAAEmB,6BAA6B,CAAC,CAC5C,EAAEuD,SAAS,CAAC;AACb,SAASA,SAAS;AAClB,SAASyc,YAAY,CAACE,IAAI,EAAE;EACxB,IAAIC,MAAM,GAAG,CAAC;EACd,KAAK,MAAMjiB,CAAC,IAAIgiB,IAAI,EAAE;IAClB,IAAIhiB,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,IAAI,EAAE;MACzBiiB,MAAM,EAAE;IACZ,CAAC,MACI;MACD;IACJ;EACJ;EACA,OAAOA,MAAM;AACjB;AACA;AACA,SAASC,qBAAqB,CAACxU,IAAI,EAAE;EACjC,OAAQA,IAAI,CAAChE,OAAO,CAACgX,aAAa,IAAIhT,IAAI,CAAChE,OAAO,CAACgX,aAAa,CAACC,KAAK,GAAG,IAAI,GAAG,KAAK;AACzF;AACA,SAASwB,kBAAkB,CAACzU,IAAI,EAAE;EAC9B,OAAO,CAAC,CAACA,IAAI,CAAChE,OAAO,CAAC0W,KAAK,IAAI,CAAC,CAAC1S,IAAI,CAAChE,OAAO,CAAC6W,MAAM;AACxD;AACA,MAAMtX,gBAAgB,CAAC;EACnBvE,WAAW,GAAG;IACV,IAAI,CAAC0d,iBAAiB,GAAG,IAAI9f,YAAY,EAAE;IAC3C,IAAI,CAAC+f,iBAAiB,GAAG,IAAI/f,YAAY,EAAE;IAC3C,IAAI,CAACggB,4BAA4B,GAAG,IAAIhgB,YAAY,EAAE;EAC1D;EACAgL,wBAAwB,CAACiV,IAAI,EAAE;IAC3B,IAAI,CAAC7C,MAAM,CAAC6C,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC;EACtC;EACAC,sBAAsB,CAACD,IAAI,EAAE5D,KAAK,EAAE;IAChC,KAAK,MAAMjR,IAAI,IAAIiR,KAAK,EAAE;MACtB,IAAIjR,IAAI,CAAC9B,KAAK,KAAK,IAAI,EAAE;QACrB8B,IAAI,CAAC9B,KAAK,GAAG2W,IAAI,CAACpC,UAAU,CAACzS,IAAI,CAACE,mBAAmB,EAAEF,IAAI,CAACS,iBAAiB,CAAC;MAClF;IACJ;IACA,OAAOwQ,KAAK;EAChB;EACAuB,gBAAgB,CAACqC,IAAI,EAAE1U,KAAK,EAAEQ,GAAG,EAAE4R,aAAa,EAAEhB,mBAAmB,EAAE;IACnE,MAAM5S,SAAS,GAAGkW,IAAI,CAACjW,YAAY,EAAE;IACrC,MAAMxH,MAAM,GAAG,IAAI,CAAC2d,eAAe,CAAC5U,KAAK,EAAEQ,GAAG,EAAE4R,aAAa,EAAEhB,mBAAmB,EAAE5S,SAAS,CAAC;IAC9F,OAAO,IAAI,CAACmW,sBAAsB,CAACD,IAAI,EAAEzd,MAAM,CAAC;EACpD;EACA2d,eAAe,CAAC5U,KAAK,EAAEQ,GAAG,EAAE4R,aAAa,EAAEhB,mBAAmB,EAAE7Q,eAAe,EAAE;IAC7E,MAAMsU,EAAE,GAAG,IAAI,CAACN,iBAAiB,CAACO,cAAc,CAAC9U,KAAK,EAAEQ,GAAG,EAAE4R,aAAa,EAAEhB,mBAAmB,EAAE7Q,eAAe,CAAC;IACjH,MAAMwU,EAAE,GAAG,IAAI,CAACP,iBAAiB,CAACM,cAAc,CAAC9U,KAAK,EAAEQ,GAAG,EAAE4R,aAAa,EAAEhB,mBAAmB,EAAE7Q,eAAe,CAAC;IACjH,MAAMyU,EAAE,GAAG,IAAI,CAACP,4BAA4B,CAACK,cAAc,CAAC9U,KAAK,EAAEQ,GAAG,EAAE4R,aAAa,EAAEhB,mBAAmB,EAAE7Q,eAAe,CAAC;IAC5H,OAAOsU,EAAE,CAAClM,MAAM,CAACoM,EAAE,CAAC,CAACpM,MAAM,CAACqM,EAAE,CAAC;EACnC;EACAxH,yBAAyB,CAACkH,IAAI,EAAE1U,KAAK,EAAEQ,GAAG,EAAE4R,aAAa,EAAE;IACvD,MAAM5T,SAAS,GAAGkW,IAAI,CAACjW,YAAY,EAAE;IACrC,MAAMxH,MAAM,GAAG,IAAI,CAACwd,4BAA4B,CAACK,cAAc,CAAC9U,KAAK,EAAEQ,GAAG,EAAE4R,aAAa,EAAE,KAAK,EAAE5T,SAAS,CAAC;IAC5G,OAAO,IAAI,CAACmW,sBAAsB,CAACD,IAAI,EAAEzd,MAAM,CAAC,CAAC+a,MAAM,CAAEpf,CAAC,IAAKA,CAAC,CAACiJ,OAAO,CAACoZ,eAAe,IAAI,CAACriB,CAAC,CAACmL,KAAK,CAACiN,OAAO,EAAE,CAAC;EACnH;EACA+G,kBAAkB,CAAC2C,IAAI,EAAEtC,aAAa,EAAE;IACpC,MAAM5T,SAAS,GAAGkW,IAAI,CAACjW,YAAY,EAAE;IACrC,MAAMxH,MAAM,GAAG,IAAI,CAACwd,4BAA4B,CAACS,MAAM,CAAC9C,aAAa,EAAE,KAAK,EAAE5T,SAAS,CAAC;IACxF,OAAO,IAAI,CAACmW,sBAAsB,CAACD,IAAI,EAAEzd,MAAM,CAAC,CAAC+a,MAAM,CAAEpf,CAAC,IAAKA,CAAC,CAACiJ,OAAO,CAACoZ,eAAe,IAAI,CAACriB,CAAC,CAACmL,KAAK,CAACiN,OAAO,EAAE,CAAC;EACnH;EACA6G,MAAM,CAAC6C,IAAI,EAAEtC,aAAa,EAAEhB,mBAAmB,EAAE+D,iBAAiB,EAAE;IAChE,MAAM3W,SAAS,GAAGkW,IAAI,CAACjW,YAAY,EAAE;IACrC,MAAMxH,MAAM,GAAG,IAAI,CAACme,OAAO,CAAChD,aAAa,EAAEhB,mBAAmB,EAAE+D,iBAAiB,EAAE3W,SAAS,CAAC;IAC7F,OAAO,IAAI,CAACmW,sBAAsB,CAACD,IAAI,EAAEzd,MAAM,CAAC;EACpD;EACAme,OAAO,CAAChD,aAAa,EAAEhB,mBAAmB,EAAE+D,iBAAiB,EAAE5U,eAAe,EAAE;IAC5E,IAAI4U,iBAAiB,EAAE;MACnB,OAAO,IAAI,CAACX,iBAAiB,CAACU,MAAM,CAAC9C,aAAa,EAAEhB,mBAAmB,EAAE7Q,eAAe,CAAC;IAC7F,CAAC,MACI;MACD,MAAMsU,EAAE,GAAG,IAAI,CAACN,iBAAiB,CAACW,MAAM,CAAC9C,aAAa,EAAEhB,mBAAmB,EAAE7Q,eAAe,CAAC;MAC7F,MAAMwU,EAAE,GAAG,IAAI,CAACP,iBAAiB,CAACU,MAAM,CAAC9C,aAAa,EAAEhB,mBAAmB,EAAE7Q,eAAe,CAAC;MAC7F,MAAMyU,EAAE,GAAG,IAAI,CAACP,4BAA4B,CAACS,MAAM,CAAC9C,aAAa,EAAEhB,mBAAmB,EAAE7Q,eAAe,CAAC;MACxG,OAAOsU,EAAE,CAAClM,MAAM,CAACoM,EAAE,CAAC,CAACpM,MAAM,CAACqM,EAAE,CAAC;IACnC;EACJ;EACAjE,qBAAqB,CAAC5B,OAAO,EAAE;IAC3B,MAAM0F,EAAE,GAAG,IAAI,CAACN,iBAAiB,CAACxD,qBAAqB,CAAC5B,OAAO,CAAC;IAChE,MAAM4F,EAAE,GAAG,IAAI,CAACP,iBAAiB,CAACzD,qBAAqB,CAAC5B,OAAO,CAAC;IAChE,MAAM6F,EAAE,GAAG,IAAI,CAACP,4BAA4B,CAAC1D,qBAAqB,CAAC5B,OAAO,CAAC;IAC3E,OAAO0F,EAAE,CAAClM,MAAM,CAACoM,EAAE,CAAC,CAACpM,MAAM,CAACqM,EAAE,CAAC;EACnC;EACArV,qBAAqB,GAAG;IACpB,MAAMkV,EAAE,GAAG,IAAI,CAACN,iBAAiB,CAAC5U,qBAAqB,EAAE;IACzD,MAAMoV,EAAE,GAAG,IAAI,CAACP,iBAAiB,CAAC7U,qBAAqB,EAAE;IACzD,MAAMqV,EAAE,GAAG,IAAI,CAACP,4BAA4B,CAAC9U,qBAAqB,EAAE;IACpE,OAAOkV,EAAE,CAAClM,MAAM,CAACoM,EAAE,CAAC,CAACpM,MAAM,CAACqM,EAAE,CAAC;EACnC;EACApE,MAAM,CAAC/Q,IAAI,EAAE;IACT,IAAIyU,kBAAkB,CAACzU,IAAI,CAAC,EAAE;MAC1B,IAAI,CAAC4U,4BAA4B,CAAC7D,MAAM,CAAC/Q,IAAI,CAAC;IAClD,CAAC,MACI,IAAIwU,qBAAqB,CAACxU,IAAI,CAAC,EAAE;MAClC,IAAI,CAAC2U,iBAAiB,CAAC5D,MAAM,CAAC/Q,IAAI,CAAC;IACvC,CAAC,MACI;MACD,IAAI,CAAC0U,iBAAiB,CAAC3D,MAAM,CAAC/Q,IAAI,CAAC;IACvC;EACJ;EACA4Q,MAAM,CAAC5Q,IAAI,EAAE;IACT,IAAIyU,kBAAkB,CAACzU,IAAI,CAAC,EAAE;MAC1B,IAAI,CAAC4U,4BAA4B,CAAChE,MAAM,CAAC5Q,IAAI,CAAC;IAClD,CAAC,MACI,IAAIwU,qBAAqB,CAACxU,IAAI,CAAC,EAAE;MAClC,IAAI,CAAC2U,iBAAiB,CAAC/D,MAAM,CAAC5Q,IAAI,CAAC;IACvC,CAAC,MACI;MACD,IAAI,CAAC0U,iBAAiB,CAAC9D,MAAM,CAAC5Q,IAAI,CAAC;IACvC;EACJ;EACAqR,YAAY,CAACwD,IAAI,EAAE7U,IAAI,EAAE;IACrB,MAAMrB,SAAS,GAAGkW,IAAI,CAACjW,YAAY,EAAE;IACrC,IAAIoB,IAAI,CAACU,eAAe,KAAK/B,SAAS,EAAE;MACpC,IAAI,CAAC6W,YAAY,CAACxV,IAAI,EAAErB,SAAS,CAAC;IACtC;IACA,IAAIqB,IAAI,CAAC9B,KAAK,KAAK,IAAI,EAAE;MACrB8B,IAAI,CAAC9B,KAAK,GAAG2W,IAAI,CAACpC,UAAU,CAACzS,IAAI,CAACE,mBAAmB,EAAEF,IAAI,CAACS,iBAAiB,CAAC;IAClF;IACA,OAAOT,IAAI,CAAC9B,KAAK;EACrB;EACAsX,YAAY,CAACxV,IAAI,EAAEU,eAAe,EAAE;IAChC,IAAI+T,kBAAkB,CAACzU,IAAI,CAAC,EAAE;MAC1B,IAAI,CAAC4U,4BAA4B,CAACa,WAAW,CAACzV,IAAI,EAAEU,eAAe,CAAC;IACxE,CAAC,MACI,IAAI8T,qBAAqB,CAACxU,IAAI,CAAC,EAAE;MAClC,IAAI,CAAC2U,iBAAiB,CAACc,WAAW,CAACzV,IAAI,EAAEU,eAAe,CAAC;IAC7D,CAAC,MACI;MACD,IAAI,CAACgU,iBAAiB,CAACe,WAAW,CAACzV,IAAI,EAAEU,eAAe,CAAC;IAC7D;EACJ;EACAuM,aAAa,CAACrJ,MAAM,EAAEpR,MAAM,EAAEkjB,UAAU,EAAE9L,gBAAgB,EAAE;IACxD,IAAI,CAAC8K,iBAAiB,CAACzH,aAAa,CAACrJ,MAAM,EAAEpR,MAAM,EAAEkjB,UAAU,EAAE9L,gBAAgB,CAAC;IAClF,IAAI,CAAC+K,iBAAiB,CAAC1H,aAAa,CAACrJ,MAAM,EAAEpR,MAAM,EAAEkjB,UAAU,EAAE9L,gBAAgB,CAAC;IAClF,IAAI,CAACgL,4BAA4B,CAAC3H,aAAa,CAACrJ,MAAM,EAAEpR,MAAM,EAAEkjB,UAAU,EAAE9L,gBAAgB,CAAC;EACjG;AACJ;AACA,SAAS+L,cAAc,CAACC,SAAS,EAAE;EAC/B,OAAOA,SAAS,CAACC,OAAO,CAAC,gBAAgB,EAAE,GAAG,CAAC;AACnD;AACA,MAAMC,iBAAiB,CAAC;EACpB9e,WAAW,CAACgF,OAAO,EAAE;IACjB,IAAI,CAACiX,KAAK,GAAGjX,OAAO,CAACiX,KAAK,IAAI,EAAE;IAChC,IAAI,CAAC8C,SAAS,GAAG/Z,OAAO,CAAC+Z,SAAS,IAAI,EAAE;EAC5C;AACJ;AACA,OAAO,MAAMC,mCAAmC,SAASF,iBAAiB,CAAC;EACvE9e,WAAW,CAACgF,OAAO,EAAE;IACjB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACia,cAAc,GAAG,IAAI;IAC1B,IAAI,CAAC1S,QAAQ,GAAI,OAAOvH,OAAO,CAACuH,QAAQ,KAAK,QAAQ,GAAGvH,OAAO,CAACuH,QAAQ,GAAGlP,KAAK,CAAC6hB,iBAAiB,CAACC,MAAO;EAC9G;EACAC,QAAQ,CAACC,KAAK,EAAE;IACZ,IAAI,CAAC,IAAI,CAACJ,cAAc,EAAE;MACtB,IAAII,KAAK,CAACC,IAAI,KAAK,OAAO,IAAI,IAAI,CAACP,SAAS,EAAE;QAC1C,IAAI,CAACE,cAAc,GAAG,IAAI,CAACM,aAAa,CAAC,IAAI,CAACR,SAAS,EAAEM,KAAK,CAAC;MACnE,CAAC,MACI;QACD,IAAI,CAACJ,cAAc,GAAG,IAAI,CAACM,aAAa,CAAC,IAAI,CAACtD,KAAK,EAAEoD,KAAK,CAAC;MAC/D;IACJ;IACA,OAAO,IAAI,CAACJ,cAAc;EAC9B;EACAO,qBAAqB,GAAG;IACpB,IAAI,CAACP,cAAc,GAAG,IAAI;EAC9B;EACAM,aAAa,CAACtD,KAAK,EAAEoD,KAAK,EAAE;IACxB,IAAI,OAAOpD,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAOA,KAAK;IAChB;IACA,MAAM3gB,CAAC,GAAG2gB,KAAK,GAAGoD,KAAK,CAACD,QAAQ,CAACnD,KAAK,CAAC9Z,EAAE,CAAC,GAAG,IAAI;IACjD,IAAI,CAAC7G,CAAC,EAAE;MACJ,OAAO,EAAE;IACb;IACA,OAAOA,CAAC,CAACmkB,QAAQ,EAAE;EACvB;AACJ;AACA,OAAO,MAAMC,6BAA6B,SAASZ,iBAAiB,CAAC;EACjE9e,WAAW,CAACgF,OAAO,EAAE;IACjB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACuH,QAAQ,GAAGvH,OAAO,CAACuH,QAAQ;EACpC;EACA6S,QAAQ,CAACC,KAAK,EAAE;IACZ,IAAI,CAAC,IAAI,CAACJ,cAAc,EAAE;MACtB,IAAII,KAAK,CAACC,IAAI,KAAK,OAAO,IAAI,IAAI,CAACP,SAAS,EAAE;QAC1C,IAAI,CAACE,cAAc,GAAG,IAAI,CAACM,aAAa,CAAC,IAAI,CAACR,SAAS,EAAEM,KAAK,CAAC;MACnE,CAAC,MACI;QACD,IAAI,CAACJ,cAAc,GAAG,IAAI,CAACM,aAAa,CAAC,IAAI,CAACtD,KAAK,EAAEoD,KAAK,CAAC;MAC/D;IACJ;IACA,OAAO,IAAI,CAACJ,cAAc;EAC9B;EACAO,qBAAqB,GAAG;IACpB,IAAI,CAACP,cAAc,GAAGnV,SAAS;EACnC;EACAyV,aAAa,CAACtD,KAAK,EAAEoD,KAAK,EAAE;IACxB,IAAI,OAAOpD,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAO3f,KAAK,CAACqjB,OAAO,CAAC1D,KAAK,CAAC;IAC/B;IACA,OAAOoD,KAAK,CAACD,QAAQ,CAACnD,KAAK,CAAC9Z,EAAE,CAAC;EACnC;AACJ;AACA,OAAO,MAAMyd,kCAAkC,CAAC;EAC5C5f,WAAW,CAACgF,OAAO,EAAE;IACjB,IAAI,CAAC6a,OAAO,GAAG7a,OAAO,CAAC6a,OAAO,IAAI,EAAE;IACpC,IAAI,CAACC,eAAe,GAAG9a,OAAO,CAAC8a,eAAe,IAAI,IAAI;IACtD,IAAI,CAACC,mCAAmC,GAAG/a,OAAO,CAAC+a,mCAAmC,IAAI,KAAK;IAC/F,IAAI,CAACC,YAAY,GAAGhb,OAAO,CAACgb,YAAY,IAAI,IAAI;IAChD,IAAI,CAACC,WAAW,GAAGjb,OAAO,CAACib,WAAW,IAAI,IAAI;EAClD;EACA,OAAOhI,IAAI,CAACjT,OAAO,EAAE;IACjB,IAAIA,OAAO,YAAY4a,kCAAkC,EAAE;MACvD,OAAO5a,OAAO;IAClB;IACA,OAAO,IAAI4a,kCAAkC,CAAC5a,OAAO,CAAC;EAC1D;AACJ;AACA,OAAO,MAAMkb,sBAAsB,CAAC;EAChClgB,WAAW,CAACgF,OAAO,EAAE;IACjB,IAAImb,EAAE,EAAEC,EAAE;IACV,IAAI,CAACC,WAAW,GAAGrb,OAAO,CAACqb,WAAW;IACtC,IAAI,CAACC,cAAc,GAAGtb,OAAO,CAACsb,cAAc,GAAG3B,cAAc,CAAC3Z,OAAO,CAACsb,cAAc,CAAC,GAAG,IAAI;IAC5F,IAAI,CAACC,UAAU,GAAGvb,OAAO,CAACub,UAAU,IAAI,CAAC,CAAC;IAC1C,IAAI,CAACC,MAAM,GAAGxb,OAAO,CAACwb,MAAM,IAAI,CAAC;IACjC,IAAI,CAAC5B,SAAS,GAAG5Z,OAAO,CAAC4Z,SAAS,GAAGD,cAAc,CAAC3Z,OAAO,CAAC4Z,SAAS,CAAC,GAAG,IAAI;IAC7E,IAAI,CAAC6B,YAAY,GAAGzb,OAAO,CAACyb,YAAY,IAAI,IAAI;IAChD,IAAI,CAACC,uBAAuB,GAAG1b,OAAO,CAAC0b,uBAAuB,IAAI,IAAI;IACtE,IAAI,CAACC,WAAW,GAAG3b,OAAO,CAAC2b,WAAW,IAAI,KAAK;IAC/C,IAAI,CAACvC,eAAe,GAAGpZ,OAAO,CAACoZ,eAAe,IAAI,KAAK;IACvD,IAAI,CAACwC,qBAAqB,GAAG5b,OAAO,CAAC4b,qBAAqB,IAAI,KAAK;IACnE,IAAI,CAAC5E,aAAa,GAAGhX,OAAO,CAACgX,aAAa,GAAG,IAAIgD,mCAAmC,CAACha,OAAO,CAACgX,aAAa,CAAC,GAAG,IAAI;IAClH,IAAI,CAAC6E,OAAO,GAAG7b,OAAO,CAAC6b,OAAO,GAAG,IAAInB,6BAA6B,CAAC1a,OAAO,CAAC6b,OAAO,CAAC,GAAG,IAAI;IAC1F,IAAI,CAACC,oBAAoB,GAAG9b,OAAO,CAAC8b,oBAAoB,GAAGnC,cAAc,CAAC3Z,OAAO,CAAC8b,oBAAoB,CAAC,GAAG,IAAI;IAC9G,IAAI,CAACC,yBAAyB,GAAG/b,OAAO,CAAC+b,yBAAyB,GAAGpC,cAAc,CAAC3Z,OAAO,CAAC+b,yBAAyB,CAAC,GAAG,IAAI;IAC7H,IAAI,CAACC,4BAA4B,GAAGhc,OAAO,CAACgc,4BAA4B,GAAGrC,cAAc,CAAC3Z,OAAO,CAACgc,4BAA4B,CAAC,GAAG,IAAI;IACtI,IAAI,CAACC,eAAe,GAAGjc,OAAO,CAACic,eAAe,GAAGtC,cAAc,CAAC3Z,OAAO,CAACic,eAAe,CAAC,GAAG,IAAI;IAC/F,IAAI,CAACnB,eAAe,GAAG9a,OAAO,CAAC8a,eAAe,GAAGnB,cAAc,CAAC3Z,OAAO,CAAC8a,eAAe,CAAC,GAAG,IAAI;IAC/F,IAAI,CAACC,mCAAmC,GAAG/a,OAAO,CAAC+a,mCAAmC,IAAI,KAAK;IAC/F,IAAI,CAACmB,sBAAsB,GAAGlc,OAAO,CAACkc,sBAAsB,GAAGvC,cAAc,CAAC3Z,OAAO,CAACkc,sBAAsB,CAAC,GAAG,IAAI;IACpH,IAAI,CAACC,qBAAqB,GAAGnc,OAAO,CAACmc,qBAAqB,GAAGxC,cAAc,CAAC3Z,OAAO,CAACmc,qBAAqB,CAAC,GAAG,IAAI;IACjH,IAAI,CAACzF,KAAK,GAAG1W,OAAO,CAAC0W,KAAK,GAAGkE,kCAAkC,CAAC3H,IAAI,CAACjT,OAAO,CAAC0W,KAAK,CAAC,GAAG,IAAI;IAC1F,IAAI,CAACG,MAAM,GAAG7W,OAAO,CAAC6W,MAAM,GAAG+D,kCAAkC,CAAC3H,IAAI,CAACjT,OAAO,CAAC6W,MAAM,CAAC,GAAG,IAAI;IAC7F,IAAI,CAACuF,mBAAmB,GAAG,CAACjB,EAAE,GAAGnb,OAAO,CAACoc,mBAAmB,MAAM,IAAI,IAAIjB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,KAAK;IACpG,IAAI,CAACkB,kBAAkB,GAAG,CAACjB,EAAE,GAAGpb,OAAO,CAACqc,kBAAkB,MAAM,IAAI,IAAIjB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,KAAK;EACtG;EACA,OAAOkB,QAAQ,CAACtc,OAAO,EAAE;IACrB,OAAO,IAAIkb,sBAAsB,CAAClb,OAAO,CAAC;EAC9C;EACA,OAAOuc,aAAa,CAACvc,OAAO,EAAE;IAC1B,OAAO,IAAIkb,sBAAsB,CAAClb,OAAO,CAAC;EAC9C;AACJ;AACAkb,sBAAsB,CAACsB,KAAK,GAAGtB,sBAAsB,CAACoB,QAAQ,CAAC;EAAEjB,WAAW,EAAE;AAAQ,CAAC,CAAC;AACxF;AACA;AACA;AACA,MAAM1G,qBAAqB,GAAG,CAC1BuG,sBAAsB,CAACoB,QAAQ,CAAC;EAAEjB,WAAW,EAAE,iDAAiD;EAAEE,UAAU,EAAE,CAAC,CAAC;AAAgE,CAAC,CAAC,EAClLL,sBAAsB,CAACoB,QAAQ,CAAC;EAAEjB,WAAW,EAAE,gDAAgD;EAAEE,UAAU,EAAE,CAAC,CAAC;AAA+D,CAAC,CAAC,EAChLL,sBAAsB,CAACoB,QAAQ,CAAC;EAAEjB,WAAW,EAAE,6CAA6C;EAAEE,UAAU,EAAE,CAAC,CAAC;AAA6D,CAAC,CAAC,EAC3KL,sBAAsB,CAACoB,QAAQ,CAAC;EAAEjB,WAAW,EAAE,4CAA4C;EAAEE,UAAU,EAAE,CAAC,CAAC;AAA4D,CAAC,CAAC,CAC5K;;AACD,SAASvH,iBAAiB,CAAChU,OAAO,EAAE;EAChC,IAAIA,OAAO,YAAYkb,sBAAsB,EAAE;IAC3C,OAAOlb,OAAO;EAClB;EACA,OAAOkb,sBAAsB,CAACqB,aAAa,CAACvc,OAAO,CAAC;AACxD;AACA,OAAO,MAAMzD,2BAA2B,SAAS7E,UAAU,CAAC;EACxDsD,WAAW,CAACyhB,gBAAgB,EAAE;IAC1B,KAAK,EAAE;IACP,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,OAAO,GAAG,IAAI,CAACvgB,SAAS,CAAC,IAAI3E,OAAO,EAAE,CAAC;IAC5C,IAAI,CAAC6E,KAAK,GAAG,IAAI,CAACqgB,OAAO,CAACrgB,KAAK;IAC/B,IAAI,CAACsgB,0BAA0B,GAAG,IAAI;IACtC,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,qBAAqB,GAAG,KAAK;EACtC;EACAld,iBAAiB,GAAG;IAChB,IAAI,CAAC+c,YAAY,EAAE;EACvB;EACA7c,eAAe,GAAG;IACd,IAAIob,EAAE;IACN,IAAI,CAACyB,YAAY,EAAE;IACnB,IAAI,IAAI,CAACA,YAAY,KAAK,CAAC,EAAE;MACzB,IAAI,IAAI,CAACC,WAAW,EAAE;QAClB,IAAI,CAACJ,gBAAgB,CAAC,IAAI,CAACE,0BAA0B,CAAC;QACtD,MAAMtgB,KAAK,GAAG;UACV2gB,cAAc,EAAE,IAAI,CAACF,eAAe;UACpCG,oBAAoB,EAAE,IAAI,CAACF;QAC/B,CAAC;QACD,IAAI,CAACF,WAAW,GAAG,KAAK;QACxB,IAAI,CAACC,eAAe,GAAG,KAAK;QAC5B,IAAI,CAACC,qBAAqB,GAAG,KAAK;QAClC,IAAI,CAACL,OAAO,CAAC5c,IAAI,CAACzD,KAAK,CAAC;MAC5B;MACA,CAAC8e,EAAE,GAAG,IAAI,CAACwB,0BAA0B,MAAM,IAAI,IAAIxB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC7X,KAAK,EAAE;MACtF,IAAI,CAACqZ,0BAA0B,GAAG,IAAI;IAC1C;EACJ;EACA/F,gCAAgC,CAACnR,UAAU,EAAE;IACzC,IAAI,CAAC,IAAI,CAACkX,0BAA0B,EAAE;MAClC,IAAI,CAACA,0BAA0B,GAAG,IAAIO,GAAG,EAAE;IAC/C;IACA,IAAI,CAACP,0BAA0B,CAACQ,GAAG,CAAC1X,UAAU,CAAC;EACnD;EACAqR,oBAAoB,CAAC9W,OAAO,EAAE;IAC1B,IAAI,CAAC,IAAI,CAAC8c,eAAe,EAAE;MACvB,IAAI,CAACA,eAAe,GAAG9c,OAAO,CAAC6b,OAAO,IAAI7b,OAAO,CAAC6b,OAAO,CAACtU,QAAQ,GAAG,IAAI,GAAG,KAAK;IACrF;IACA,IAAI,CAAC,IAAI,CAACwV,qBAAqB,EAAE;MAC7B,IAAI,CAACA,qBAAqB,GAAG/c,OAAO,CAACgX,aAAa,IAAIhX,OAAO,CAACgX,aAAa,CAACC,KAAK,GAAG,IAAI,GAAG,KAAK;IACpG;IACA,IAAI,CAAC4F,WAAW,GAAG,IAAI;EAC3B;EACA/c,IAAI,GAAG;IACH,IAAI,CAACgd,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,qBAAqB,GAAG,IAAI;IACjC,IAAI,CAACF,WAAW,GAAG,IAAI;EAC3B;AACJ;AACA;AACA,OAAO,MAAM5f,uBAAuB,SAASvF,UAAU,CAAC;EACpDsD,WAAW,GAAG;IACV,KAAK,EAAE;IACP;AACR;AACA;IACQ,IAAI,CAACoiB,YAAY,GAAG,IAAI,CAACjhB,SAAS,CAAC,IAAI3E,OAAO,EAAE,CAAC;IACjD,IAAI,CAAC0J,SAAS,GAAG,IAAI,CAACkc,YAAY,CAAC/gB,KAAK;IACxC,IAAI,CAACghB,YAAY,GAAG,IAAI,CAAClhB,SAAS,CAAC,IAAI3E,OAAO,EAAE,CAAC;IACjD,IAAI,CAACsJ,SAAS,GAAG,IAAI,CAACuc,YAAY,CAAChhB,KAAK;IACxC,IAAI,CAACugB,YAAY,GAAG,CAAC;IACrB,IAAI,CAACU,cAAc,GAAG,IAAI;EAC9B;EACAzd,iBAAiB,GAAG;IAChB,IAAI,CAAC+c,YAAY,EAAE;EACvB;EACA7c,eAAe,GAA4B;IAAA,IAA3B0P,kBAAkB,uEAAG,IAAI;IACrC,IAAI,CAACmN,YAAY,EAAE;IACnB,IAAI,IAAI,CAACA,YAAY,KAAK,CAAC,EAAE;MACzB,IAAI,IAAI,CAACU,cAAc,KAAK,IAAI,EAAE;QAC9B,IAAI,CAACA,cAAc,CAACC,sBAAsB,CAAC9N,kBAAkB,GAAGA,kBAAkB;QAClF,MAAM1O,CAAC,GAAG,IAAI,CAACuc,cAAc;QAC7B,IAAI,CAACA,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACF,YAAY,CAACtd,IAAI,CAACiB,CAAC,CAAC;QACzB,IAAI,CAACsc,YAAY,CAACvd,IAAI,CAACiB,CAAC,CAAC;MAC7B;IACJ;EACJ;EACAjB,IAAI,CAACiB,CAAC,EAAE;IACJ,IAAI,IAAI,CAAC6b,YAAY,GAAG,CAAC,EAAE;MACvB,IAAI,IAAI,CAACU,cAAc,EAAE;QACrB,IAAI,CAACA,cAAc,GAAG,IAAI,CAACA,cAAc,CAACE,KAAK,CAACzc,CAAC,CAAC;MACtD,CAAC,MACI;QACD,IAAI,CAACuc,cAAc,GAAGvc,CAAC;MAC3B;MACA;IACJ;IACA,IAAI,CAACqc,YAAY,CAACtd,IAAI,CAACiB,CAAC,CAAC;IACzB,IAAI,CAACsc,YAAY,CAACvd,IAAI,CAACiB,CAAC,CAAC;EAC7B;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}