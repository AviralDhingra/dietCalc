{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport class TokenizationTextModelPart extends TextModelPart {\n  constructor(_languageService, _languageConfigurationService, _textModel, bracketPairsTextModelPart, _languageId) {\n    super();\n    this._languageService = _languageService;\n    this._languageConfigurationService = _languageConfigurationService;\n    this._textModel = _textModel;\n    this.bracketPairsTextModelPart = bracketPairsTextModelPart;\n    this._languageId = _languageId;\n    this._onDidChangeLanguage = this._register(new Emitter());\n    this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n    this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n    this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n    this._onDidChangeTokens = this._register(new Emitter());\n    this.onDidChangeTokens = this._onDidChangeTokens.event;\n    this._backgroundTokenizationState = 0 /* BackgroundTokenizationState.Uninitialized */;\n    this._onBackgroundTokenizationStateChanged = this._register(new Emitter());\n    this._tokens = new ContiguousTokensStore(this._languageService.languageIdCodec);\n    this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n    this._tokenization = new TextModelTokenization(_textModel, this, this._languageService.languageIdCodec);\n    this._languageRegistryListener = this._languageConfigurationService.onDidChange(e => {\n      if (e.affects(this._languageId)) {\n        this._onDidChangeLanguageConfiguration.fire({});\n      }\n    });\n  }\n  acceptEdit(range, text, eolCount, firstLineLength, lastLineLength) {\n    this._tokens.acceptEdit(range, eolCount, firstLineLength);\n    this._semanticTokens.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n  }\n\n  handleDidChangeAttached() {\n    this._tokenization.handleDidChangeAttached();\n  }\n  flush() {\n    this._tokens.flush();\n    this._semanticTokens.flush();\n  }\n  handleDidChangeContent(change) {\n    this._tokenization.handleDidChangeContent(change);\n  }\n  dispose() {\n    this._languageRegistryListener.dispose();\n    this._tokenization.dispose();\n    super.dispose();\n  }\n  get backgroundTokenizationState() {\n    return this._backgroundTokenizationState;\n  }\n  handleTokenizationProgress(completed) {\n    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n      // We already did a full tokenization and don't go back to progressing.\n      return;\n    }\n    const newState = completed ? 2 /* BackgroundTokenizationState.Completed */ : 1 /* BackgroundTokenizationState.InProgress */;\n    if (this._backgroundTokenizationState !== newState) {\n      this._backgroundTokenizationState = newState;\n      this.bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n      this._onBackgroundTokenizationStateChanged.fire();\n    }\n  }\n  setTokens(tokens) {\n    let backgroundTokenizationCompleted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (tokens.length !== 0) {\n      const ranges = [];\n      for (let i = 0, len = tokens.length; i < len; i++) {\n        const element = tokens[i];\n        let minChangedLineNumber = 0;\n        let maxChangedLineNumber = 0;\n        let hasChange = false;\n        for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n          if (hasChange) {\n            this._tokens.setTokens(this._languageId, lineNumber - 1, this._textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n            maxChangedLineNumber = lineNumber;\n          } else {\n            const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n            if (lineHasChange) {\n              hasChange = true;\n              minChangedLineNumber = lineNumber;\n              maxChangedLineNumber = lineNumber;\n            }\n          }\n        }\n        if (hasChange) {\n          ranges.push({\n            fromLineNumber: minChangedLineNumber,\n            toLineNumber: maxChangedLineNumber\n          });\n        }\n      }\n      if (ranges.length > 0) {\n        this._emitModelTokensChangedEvent({\n          tokenizationSupportChanged: false,\n          semanticTokensApplied: false,\n          ranges: ranges\n        });\n      }\n    }\n    this.handleTokenizationProgress(backgroundTokenizationCompleted);\n  }\n  setSemanticTokens(tokens, isComplete) {\n    this._semanticTokens.set(tokens, isComplete);\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      semanticTokensApplied: tokens !== null,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this._textModel.getLineCount()\n      }]\n    });\n  }\n  hasCompleteSemanticTokens() {\n    return this._semanticTokens.isComplete();\n  }\n  hasSomeSemanticTokens() {\n    return !this._semanticTokens.isEmpty();\n  }\n  setPartialSemanticTokens(range, tokens) {\n    if (this.hasCompleteSemanticTokens()) {\n      return;\n    }\n    const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      semanticTokensApplied: true,\n      ranges: [{\n        fromLineNumber: changedRange.startLineNumber,\n        toLineNumber: changedRange.endLineNumber\n      }]\n    });\n  }\n  tokenizeViewport(startLineNumber, endLineNumber) {\n    startLineNumber = Math.max(1, startLineNumber);\n    endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n    this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n  }\n  clearTokens() {\n    this._tokens.flush();\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: true,\n      semanticTokensApplied: false,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this._textModel.getLineCount()\n      }]\n    });\n  }\n  _emitModelTokensChangedEvent(e) {\n    if (!this._textModel._isDisposing()) {\n      this.bracketPairsTextModelPart.handleDidChangeTokens(e);\n      this._onDidChangeTokens.fire(e);\n    }\n  }\n  resetTokenization() {\n    this._tokenization.reset();\n  }\n  forceTokenization(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    this._tokenization.forceTokenization(lineNumber);\n  }\n  isCheapToTokenize(lineNumber) {\n    return this._tokenization.isCheapToTokenize(lineNumber);\n  }\n  tokenizeIfCheap(lineNumber) {\n    if (this.isCheapToTokenize(lineNumber)) {\n      this.forceTokenization(lineNumber);\n    }\n  }\n  getLineTokens(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._getLineTokens(lineNumber);\n  }\n  _getLineTokens(lineNumber) {\n    const lineText = this._textModel.getLineContent(lineNumber);\n    const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);\n    return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n  }\n  getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n    const position = this._textModel.validatePosition(new Position(lineNumber, column));\n    return this._tokenization.getTokenTypeIfInsertingCharacter(position, character);\n  }\n  tokenizeLineWithEdit(position, length, newText) {\n    const validatedPosition = this._textModel.validatePosition(position);\n    return this._tokenization.tokenizeLineWithEdit(validatedPosition, length, newText);\n  }\n  getLanguageConfiguration(languageId) {\n    return this._languageConfigurationService.getLanguageConfiguration(languageId);\n  }\n  // Having tokens allows implementing additional helper methods\n  getWordAtPosition(_position) {\n    this.assertNotDisposed();\n    const position = this._textModel.validatePosition(_position);\n    const lineContent = this._textModel.getLineContent(position.lineNumber);\n    const lineTokens = this._getLineTokens(position.lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    // (1). First try checking right biased word\n    const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n    const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n    // Make sure the result touches the original passed in position\n    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n      return rightBiasedWord;\n    }\n    // (2). Else, if we were at a language boundary, check the left biased word\n    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n      // edge case, where `position` sits between two tokens belonging to two different languages\n      const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n      const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n      // Make sure the result touches the original passed in position\n      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n        return leftBiasedWord;\n      }\n    }\n    return null;\n  }\n  static _findLanguageBoundaries(lineTokens, tokenIndex) {\n    const languageId = lineTokens.getLanguageId(tokenIndex);\n    // go left until a different language is hit\n    let startOffset = 0;\n    for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n      startOffset = lineTokens.getStartOffset(i);\n    }\n    // go right until a different language is hit\n    let endOffset = lineTokens.getLineContent().length;\n    for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n      endOffset = lineTokens.getEndOffset(i);\n    }\n    return [startOffset, endOffset];\n  }\n  getWordUntilPosition(position) {\n    const wordAtPosition = this.getWordAtPosition(position);\n    if (!wordAtPosition) {\n      return {\n        word: '',\n        startColumn: position.column,\n        endColumn: position.column\n      };\n    }\n    return {\n      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n      startColumn: wordAtPosition.startColumn,\n      endColumn: position.column\n    };\n  }\n  getLanguageId() {\n    return this._languageId;\n  }\n  getLanguageIdAtPosition(lineNumber, column) {\n    const position = this._textModel.validatePosition(new Position(lineNumber, column));\n    const lineTokens = this.getLineTokens(position.lineNumber);\n    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n  }\n  setLanguageId(languageId) {\n    if (this._languageId === languageId) {\n      // There's nothing to do\n      return;\n    }\n    const e = {\n      oldLanguage: this._languageId,\n      newLanguage: languageId\n    };\n    this._languageId = languageId;\n    this.bracketPairsTextModelPart.handleDidChangeLanguage(e);\n    this._tokenization.handleDidChangeLanguage(e);\n    this._onDidChangeLanguage.fire(e);\n    this._onDidChangeLanguageConfiguration.fire({});\n  }\n}","map":{"version":3,"names":["Emitter","Position","getWordAtText","TextModelPart","TextModelTokenization","ContiguousTokensStore","SparseTokensStore","TokenizationTextModelPart","constructor","_languageService","_languageConfigurationService","_textModel","bracketPairsTextModelPart","_languageId","_onDidChangeLanguage","_register","onDidChangeLanguage","event","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_backgroundTokenizationState","_onBackgroundTokenizationStateChanged","_tokens","languageIdCodec","_semanticTokens","_tokenization","_languageRegistryListener","onDidChange","e","affects","fire","acceptEdit","range","text","eolCount","firstLineLength","lastLineLength","length","charCodeAt","handleDidChangeAttached","flush","handleDidChangeContent","change","dispose","backgroundTokenizationState","handleTokenizationProgress","completed","newState","handleDidChangeBackgroundTokenizationState","setTokens","tokens","backgroundTokenizationCompleted","ranges","i","len","element","minChangedLineNumber","maxChangedLineNumber","hasChange","lineNumber","startLineNumber","endLineNumber","getLineLength","getLineTokens","lineHasChange","push","fromLineNumber","toLineNumber","_emitModelTokensChangedEvent","tokenizationSupportChanged","semanticTokensApplied","setSemanticTokens","isComplete","set","getLineCount","hasCompleteSemanticTokens","hasSomeSemanticTokens","isEmpty","setPartialSemanticTokens","changedRange","validateRange","setPartial","tokenizeViewport","Math","max","min","clearTokens","_isDisposing","handleDidChangeTokens","resetTokenization","reset","forceTokenization","Error","isCheapToTokenize","tokenizeIfCheap","_getLineTokens","lineText","getLineContent","syntacticTokens","getTokens","addSparseTokens","getTokenTypeIfInsertingCharacter","column","character","position","validatePosition","tokenizeLineWithEdit","newText","validatedPosition","getLanguageConfiguration","languageId","getWordAtPosition","_position","assertNotDisposed","lineContent","lineTokens","tokenIndex","findTokenIndexAtOffset","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getLanguageId","getWordDefinition","substring","startColumn","endColumn","lbStartOffset","lbEndOffset","leftBiasedWord","startOffset","getStartOffset","endOffset","tokenCount","getCount","getEndOffset","getWordUntilPosition","wordAtPosition","word","substr","getLanguageIdAtPosition","setLanguageId","oldLanguage","newLanguage","handleDidChangeLanguage"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport class TokenizationTextModelPart extends TextModelPart {\n    constructor(_languageService, _languageConfigurationService, _textModel, bracketPairsTextModelPart, _languageId) {\n        super();\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._textModel = _textModel;\n        this.bracketPairsTextModelPart = bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._backgroundTokenizationState = 0 /* BackgroundTokenizationState.Uninitialized */;\n        this._onBackgroundTokenizationStateChanged = this._register(new Emitter());\n        this._tokens = new ContiguousTokensStore(this._languageService.languageIdCodec);\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._tokenization = new TextModelTokenization(_textModel, this, this._languageService.languageIdCodec);\n        this._languageRegistryListener = this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        });\n    }\n    acceptEdit(range, text, eolCount, firstLineLength, lastLineLength) {\n        this._tokens.acceptEdit(range, eolCount, firstLineLength);\n        this._semanticTokens.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n    }\n    handleDidChangeAttached() {\n        this._tokenization.handleDidChangeAttached();\n    }\n    flush() {\n        this._tokens.flush();\n        this._semanticTokens.flush();\n    }\n    handleDidChangeContent(change) {\n        this._tokenization.handleDidChangeContent(change);\n    }\n    dispose() {\n        this._languageRegistryListener.dispose();\n        this._tokenization.dispose();\n        super.dispose();\n    }\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    handleTokenizationProgress(completed) {\n        if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // We already did a full tokenization and don't go back to progressing.\n            return;\n        }\n        const newState = completed ? 2 /* BackgroundTokenizationState.Completed */ : 1 /* BackgroundTokenizationState.InProgress */;\n        if (this._backgroundTokenizationState !== newState) {\n            this._backgroundTokenizationState = newState;\n            this.bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n            this._onBackgroundTokenizationStateChanged.fire();\n        }\n    }\n    setTokens(tokens, backgroundTokenizationCompleted = false) {\n        if (tokens.length !== 0) {\n            const ranges = [];\n            for (let i = 0, len = tokens.length; i < len; i++) {\n                const element = tokens[i];\n                let minChangedLineNumber = 0;\n                let maxChangedLineNumber = 0;\n                let hasChange = false;\n                for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                    if (hasChange) {\n                        this._tokens.setTokens(this._languageId, lineNumber - 1, this._textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                        maxChangedLineNumber = lineNumber;\n                    }\n                    else {\n                        const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                        if (lineHasChange) {\n                            hasChange = true;\n                            minChangedLineNumber = lineNumber;\n                            maxChangedLineNumber = lineNumber;\n                        }\n                    }\n                }\n                if (hasChange) {\n                    ranges.push({\n                        fromLineNumber: minChangedLineNumber,\n                        toLineNumber: maxChangedLineNumber,\n                    });\n                }\n            }\n            if (ranges.length > 0) {\n                this._emitModelTokensChangedEvent({\n                    tokenizationSupportChanged: false,\n                    semanticTokensApplied: false,\n                    ranges: ranges,\n                });\n            }\n        }\n        this.handleTokenizationProgress(backgroundTokenizationCompleted);\n    }\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        startLineNumber = Math.max(1, startLineNumber);\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n    }\n    clearTokens() {\n        this._tokens.flush();\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: true,\n            semanticTokensApplied: false,\n            ranges: [\n                {\n                    fromLineNumber: 1,\n                    toLineNumber: this._textModel.getLineCount(),\n                },\n            ],\n        });\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this.bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    resetTokenization() {\n        this._tokenization.reset();\n    }\n    forceTokenization(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        this._tokenization.forceTokenization(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        return this._tokenization.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._getLineTokens(lineNumber);\n    }\n    _getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        return this._tokenization.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        const validatedPosition = this._textModel.validatePosition(position);\n        return this._tokenization.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    // Having tokens allows implementing additional helper methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this._getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column,\n            };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId) {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId\n        };\n        this._languageId = languageId;\n        this.bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokenization.handleDidChangeLanguage(e);\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}