{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n  constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n    this.value = value;\n    this.selectionStart = selectionStart;\n    this.selectionEnd = selectionEnd;\n    this.selectionStartPosition = selectionStartPosition;\n    this.selectionEndPosition = selectionEndPosition;\n  }\n  toString() {\n    return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;\n  }\n  static readFromTextArea(textArea) {\n    return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n  }\n  collapseSelection() {\n    return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n  }\n  writeToTextArea(reason, textArea, select) {\n    if (_debugComposition) {\n      console.log(`writeToTextArea ${reason}: ${this.toString()}`);\n    }\n    textArea.setValue(reason, this.value);\n    if (select) {\n      textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n    }\n  }\n  deduceEditorPosition(offset) {\n    if (offset <= this.selectionStart) {\n      const str = this.value.substring(offset, this.selectionStart);\n      return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n    }\n    if (offset >= this.selectionEnd) {\n      const str = this.value.substring(this.selectionEnd, offset);\n      return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\n    }\n    const str1 = this.value.substring(this.selectionStart, offset);\n    if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n      return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n    }\n    const str2 = this.value.substring(offset, this.selectionEnd);\n    return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n  }\n  _finishDeduceEditorPosition(anchor, deltaText, signum) {\n    let lineFeedCnt = 0;\n    let lastLineFeedIndex = -1;\n    while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n      lineFeedCnt++;\n    }\n    return [anchor, signum * deltaText.length, lineFeedCnt];\n  }\n  static deduceInput(previousState, currentState, couldBeEmojiInput) {\n    if (!previousState) {\n      // This is the EMPTY state\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    }\n    if (_debugComposition) {\n      console.log('------------------------deduceInput');\n      console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n      console.log(`CURRENT STATE: ${currentState.toString()}`);\n    }\n    const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionStart, currentState.selectionStart);\n    const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd, currentState.value.length - currentState.selectionEnd);\n    const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n    const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n    const previousSelectionStart = previousState.selectionStart - prefixLength;\n    const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n    const currentSelectionStart = currentState.selectionStart - prefixLength;\n    const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n    if (_debugComposition) {\n      console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n      console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n    }\n    if (currentSelectionStart === currentSelectionEnd) {\n      // no current selection\n      const replacePreviousCharacters = previousState.selectionStart - prefixLength;\n      if (_debugComposition) {\n        console.log(`REMOVE PREVIOUS: ${replacePreviousCharacters} chars`);\n      }\n      return {\n        text: currentValue,\n        replacePrevCharCnt: replacePreviousCharacters,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    }\n    // there is a current selection => composition case\n    const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n    return {\n      text: currentValue,\n      replacePrevCharCnt: replacePreviousCharacters,\n      replaceNextCharCnt: 0,\n      positionDelta: 0\n    };\n  }\n  static deduceAndroidCompositionInput(previousState, currentState) {\n    if (!previousState) {\n      // This is the EMPTY state\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    }\n    if (_debugComposition) {\n      console.log('------------------------deduceAndroidCompositionInput');\n      console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n      console.log(`CURRENT STATE: ${currentState.toString()}`);\n    }\n    if (previousState.value === currentState.value) {\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: currentState.selectionEnd - previousState.selectionEnd\n      };\n    }\n    const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n    const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n    const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n    const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n    const previousSelectionStart = previousState.selectionStart - prefixLength;\n    const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n    const currentSelectionStart = currentState.selectionStart - prefixLength;\n    const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n    if (_debugComposition) {\n      console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n      console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n    }\n    return {\n      text: currentValue,\n      replacePrevCharCnt: previousSelectionEnd,\n      replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n      positionDelta: currentSelectionEnd - currentValue.length\n    };\n  }\n}\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\nexport class PagedScreenReaderStrategy {\n  static _getPageOfLine(lineNumber, linesPerPage) {\n    return Math.floor((lineNumber - 1) / linesPerPage);\n  }\n  static _getRangeForPage(page, linesPerPage) {\n    const offset = page * linesPerPage;\n    const startLineNumber = offset + 1;\n    const endLineNumber = offset + linesPerPage;\n    return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n  }\n  static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\n    const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n    const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n    const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n    const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n    const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n    let pretext = model.getValueInRange(pretextRange, 1 /* EndOfLinePreference.LF */);\n    const lastLine = model.getLineCount();\n    const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n    const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n    let posttext = model.getValueInRange(posttextRange, 1 /* EndOfLinePreference.LF */);\n    let text;\n    if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n      // take full selection\n      text = model.getValueInRange(selection, 1 /* EndOfLinePreference.LF */);\n    } else {\n      const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n      const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n      text = model.getValueInRange(selectionRange1, 1 /* EndOfLinePreference.LF */) + String.fromCharCode(8230) + model.getValueInRange(selectionRange2, 1 /* EndOfLinePreference.LF */);\n    }\n    // Chromium handles very poorly text even of a few thousand chars\n    // Cut text to avoid stalling the entire UI\n    if (trimLongText) {\n      const LIMIT_CHARS = 500;\n      if (pretext.length > LIMIT_CHARS) {\n        pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n      }\n      if (posttext.length > LIMIT_CHARS) {\n        posttext = posttext.substring(0, LIMIT_CHARS);\n      }\n      if (text.length > 2 * LIMIT_CHARS) {\n        text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n      }\n    }\n    return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n  }\n}","map":{"version":3,"names":["strings","Position","Range","_debugComposition","TextAreaState","constructor","value","selectionStart","selectionEnd","selectionStartPosition","selectionEndPosition","toString","readFromTextArea","textArea","getValue","getSelectionStart","getSelectionEnd","collapseSelection","length","writeToTextArea","reason","select","console","log","setValue","setSelectionRange","deduceEditorPosition","offset","str","substring","_finishDeduceEditorPosition","str1","indexOf","String","fromCharCode","str2","anchor","deltaText","signum","lineFeedCnt","lastLineFeedIndex","deduceInput","previousState","currentState","couldBeEmojiInput","text","replacePrevCharCnt","replaceNextCharCnt","positionDelta","prefixLength","Math","min","commonPrefixLength","suffixLength","commonSuffixLength","previousValue","currentValue","previousSelectionStart","previousSelectionEnd","currentSelectionStart","currentSelectionEnd","replacePreviousCharacters","deduceAndroidCompositionInput","EMPTY","PagedScreenReaderStrategy","_getPageOfLine","lineNumber","linesPerPage","floor","_getRangeForPage","page","startLineNumber","endLineNumber","fromEditorSelection","model","selection","trimLongText","selectionStartPage","selectionStartPageRange","selectionEndPage","selectionEndPageRange","pretextRange","intersectRanges","startColumn","pretext","getValueInRange","lastLine","getLineCount","lastLineMaxColumn","getLineMaxColumn","posttextRange","endColumn","posttext","selectionRange1","selectionRange2","LIMIT_CHARS"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n    constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n        this.value = value;\n        this.selectionStart = selectionStart;\n        this.selectionEnd = selectionEnd;\n        this.selectionStartPosition = selectionStartPosition;\n        this.selectionEndPosition = selectionEndPosition;\n    }\n    toString() {\n        return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;\n    }\n    static readFromTextArea(textArea) {\n        return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n    }\n    collapseSelection() {\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n    }\n    writeToTextArea(reason, textArea, select) {\n        if (_debugComposition) {\n            console.log(`writeToTextArea ${reason}: ${this.toString()}`);\n        }\n        textArea.setValue(reason, this.value);\n        if (select) {\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n        }\n    }\n    deduceEditorPosition(offset) {\n        if (offset <= this.selectionStart) {\n            const str = this.value.substring(offset, this.selectionStart);\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n        }\n        if (offset >= this.selectionEnd) {\n            const str = this.value.substring(this.selectionEnd, offset);\n            return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\n        }\n        const str1 = this.value.substring(this.selectionStart, offset);\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n        }\n        const str2 = this.value.substring(offset, this.selectionEnd);\n        return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n    }\n    _finishDeduceEditorPosition(anchor, deltaText, signum) {\n        let lineFeedCnt = 0;\n        let lastLineFeedIndex = -1;\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n            lineFeedCnt++;\n        }\n        return [anchor, signum * deltaText.length, lineFeedCnt];\n    }\n    static deduceInput(previousState, currentState, couldBeEmojiInput) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceInput');\n            console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n            console.log(`CURRENT STATE: ${currentState.toString()}`);\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionStart, currentState.selectionStart);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd, currentState.value.length - currentState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n            console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n        }\n        if (currentSelectionStart === currentSelectionEnd) {\n            // no current selection\n            const replacePreviousCharacters = (previousState.selectionStart - prefixLength);\n            if (_debugComposition) {\n                console.log(`REMOVE PREVIOUS: ${replacePreviousCharacters} chars`);\n            }\n            return {\n                text: currentValue,\n                replacePrevCharCnt: replacePreviousCharacters,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        // there is a current selection => composition case\n        const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n        return {\n            text: currentValue,\n            replacePrevCharCnt: replacePreviousCharacters,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n    }\n    static deduceAndroidCompositionInput(previousState, currentState) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceAndroidCompositionInput');\n            console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n            console.log(`CURRENT STATE: ${currentState.toString()}`);\n        }\n        if (previousState.value === currentState.value) {\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: currentState.selectionEnd - previousState.selectionEnd\n            };\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n            console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n        }\n        return {\n            text: currentValue,\n            replacePrevCharCnt: previousSelectionEnd,\n            replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n            positionDelta: currentSelectionEnd - currentValue.length\n        };\n    }\n}\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\nexport class PagedScreenReaderStrategy {\n    static _getPageOfLine(lineNumber, linesPerPage) {\n        return Math.floor((lineNumber - 1) / linesPerPage);\n    }\n    static _getRangeForPage(page, linesPerPage) {\n        const offset = page * linesPerPage;\n        const startLineNumber = offset + 1;\n        const endLineNumber = offset + linesPerPage;\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n    }\n    static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\n        const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n        const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n        const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n        const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n        const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n        let pretext = model.getValueInRange(pretextRange, 1 /* EndOfLinePreference.LF */);\n        const lastLine = model.getLineCount();\n        const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n        const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n        let posttext = model.getValueInRange(posttextRange, 1 /* EndOfLinePreference.LF */);\n        let text;\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n            // take full selection\n            text = model.getValueInRange(selection, 1 /* EndOfLinePreference.LF */);\n        }\n        else {\n            const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n            const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n            text = (model.getValueInRange(selectionRange1, 1 /* EndOfLinePreference.LF */)\n                + String.fromCharCode(8230)\n                + model.getValueInRange(selectionRange2, 1 /* EndOfLinePreference.LF */));\n        }\n        // Chromium handles very poorly text even of a few thousand chars\n        // Cut text to avoid stalling the entire UI\n        if (trimLongText) {\n            const LIMIT_CHARS = 500;\n            if (pretext.length > LIMIT_CHARS) {\n                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n            }\n            if (posttext.length > LIMIT_CHARS) {\n                posttext = posttext.substring(0, LIMIT_CHARS);\n            }\n            if (text.length > 2 * LIMIT_CHARS) {\n                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n            }\n        }\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}