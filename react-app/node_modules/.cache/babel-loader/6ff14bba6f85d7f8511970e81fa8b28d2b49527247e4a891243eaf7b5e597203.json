{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nexport class BracketPairsTree extends Disposable {\n  constructor(textModel, getLanguageConfiguration) {\n    super();\n    this.textModel = textModel;\n    this.getLanguageConfiguration = getLanguageConfiguration;\n    this.didChangeEmitter = new Emitter();\n    this.denseKeyProvider = new DenseKeyProvider();\n    this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n    this.onDidChange = this.didChangeEmitter.event;\n    if (textModel.tokenization.backgroundTokenizationState === 0 /* BackgroundTokenizationState.Uninitialized */) {\n      // There are no token information yet\n      const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n      const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n      this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n      this.astWithTokens = this.initialAstWithoutTokens;\n    } else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n      // Skip the initial ast, as there is no flickering.\n      // Directly create the tree with token information.\n      this.initialAstWithoutTokens = undefined;\n      this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n    } else if (textModel.tokenization.backgroundTokenizationState === 1 /* BackgroundTokenizationState.InProgress */) {\n      this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n      this.astWithTokens = this.initialAstWithoutTokens;\n    }\n  }\n  didLanguageChange(languageId) {\n    return this.brackets.didLanguageChange(languageId);\n  }\n  //#region TextModel events\n  handleDidChangeBackgroundTokenizationState() {\n    if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n      const wasUndefined = this.initialAstWithoutTokens === undefined;\n      // Clear the initial tree as we can use the tree with token information now.\n      this.initialAstWithoutTokens = undefined;\n      if (!wasUndefined) {\n        this.didChangeEmitter.fire();\n      }\n    }\n  }\n  handleDidChangeTokens(_ref) {\n    let {\n      ranges\n    } = _ref;\n    const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n    this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n    if (!this.initialAstWithoutTokens) {\n      this.didChangeEmitter.fire();\n    }\n  }\n  handleContentChanged(change) {\n    const edits = change.changes.map(c => {\n      const range = Range.lift(c.range);\n      return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n    }).reverse();\n    this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n    if (this.initialAstWithoutTokens) {\n      this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);\n    }\n  }\n  //#endregion\n  /**\n   * @pure (only if isPure = true)\n  */\n  parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n    // Is much faster if `isPure = false`.\n    const isPure = false;\n    const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n    const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n    const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n    return result;\n  }\n  getBracketsInRange(range) {\n    const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n    const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n    const result = new Array();\n    const node = this.initialAstWithoutTokens || this.astWithTokens;\n    collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result, 0, new Map());\n    return result;\n  }\n  getBracketPairsInRange(range, includeMinIndentation) {\n    const result = new Array();\n    const startLength = positionToLength(range.getStartPosition());\n    const endLength = positionToLength(range.getEndPosition());\n    const node = this.initialAstWithoutTokens || this.astWithTokens;\n    const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);\n    collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n    return result;\n  }\n  getFirstBracketAfter(position) {\n    const node = this.initialAstWithoutTokens || this.astWithTokens;\n    return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n  }\n  getFirstBracketBefore(position) {\n    const node = this.initialAstWithoutTokens || this.astWithTokens;\n    return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n  }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n  if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n    const lengths = [];\n    for (const child of node.children) {\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n      lengths.push({\n        nodeOffsetStart,\n        nodeOffsetEnd\n      });\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n    for (let i = lengths.length - 1; i >= 0; i--) {\n      const {\n        nodeOffsetStart,\n        nodeOffsetEnd\n      } = lengths[i];\n      if (lengthLessThan(nodeOffsetStart, position)) {\n        const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  } else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n    return null;\n  } else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n    const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    return {\n      bracketInfo: node.bracketInfo,\n      range\n    };\n  }\n  return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n  if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n    for (const child of node.children) {\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n      if (lengthLessThan(position, nodeOffsetEnd)) {\n        const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n        if (result) {\n          return result;\n        }\n      }\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n    return null;\n  } else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n    return null;\n  } else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n    const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    return {\n      bracketInfo: node.bracketInfo,\n      range\n    };\n  }\n  return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level, levelPerBracketType) {\n  if (level > 200) {\n    return;\n  }\n  if (node.kind === 4 /* AstNodeKind.List */) {\n    for (const child of node.children) {\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level, levelPerBracketType);\n      }\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n  } else if (node.kind === 2 /* AstNodeKind.Pair */) {\n    let levelPerBracket = 0;\n    if (levelPerBracketType) {\n      let existing = levelPerBracketType.get(node.openingBracket.text);\n      if (existing === undefined) {\n        existing = 0;\n      }\n      levelPerBracket = existing;\n      existing++;\n      levelPerBracketType.set(node.openingBracket.text, existing);\n    }\n    // Don't use node.children here to improve performance\n    {\n      const child = node.openingBracket;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level, levelPerBracket, !node.closingBracket));\n      }\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n    if (node.child) {\n      const child = node.child;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level + 1, levelPerBracketType);\n      }\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n    if (node.closingBracket) {\n      const child = node.closingBracket;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level, levelPerBracket, false));\n      }\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n    levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n  } else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n    const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    result.push(new BracketInfo(range, level - 1, 0, true));\n  } else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n    const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    result.push(new BracketInfo(range, level - 1, 0, false));\n  }\n}\nclass CollectBracketPairsContext {\n  constructor(result, includeMinIndentation, textModel) {\n    this.result = result;\n    this.includeMinIndentation = includeMinIndentation;\n    this.textModel = textModel;\n  }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n  var _a;\n  if (level > 200) {\n    return;\n  }\n  if (node.kind === 2 /* AstNodeKind.Pair */) {\n    let levelPerBracket = 0;\n    if (levelPerBracketType) {\n      let existing = levelPerBracketType.get(node.openingBracket.text);\n      if (existing === undefined) {\n        existing = 0;\n      }\n      levelPerBracket = existing;\n      existing++;\n      levelPerBracketType.set(node.openingBracket.text, existing);\n    }\n    const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n    let minIndentation = -1;\n    if (context.includeMinIndentation) {\n      minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n    }\n    context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd) : undefined, level, levelPerBracket, node, minIndentation));\n    nodeOffsetStart = openingBracketEnd;\n    if (node.child) {\n      const child = node.child;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n      }\n    }\n    levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n  } else {\n    let curOffset = nodeOffsetStart;\n    for (const child of node.children) {\n      const childOffset = curOffset;\n      curOffset = lengthAdd(curOffset, child.length);\n      if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {\n        collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n      }\n    }\n  }\n}","map":{"version":3,"names":["Emitter","Disposable","Range","BracketInfo","BracketPairWithMinIndentationInfo","TextEditInfo","LanguageAgnosticBracketTokens","lengthAdd","lengthGreaterThanEqual","lengthLessThan","lengthLessThanEqual","lengthOfString","lengthsToRange","lengthZero","positionToLength","toLength","parseDocument","DenseKeyProvider","FastTokenizer","TextBufferTokenizer","BracketPairsTree","constructor","textModel","getLanguageConfiguration","didChangeEmitter","denseKeyProvider","brackets","onDidChange","event","tokenization","backgroundTokenizationState","getSingleLanguageBracketTokens","getLanguageId","tokenizer","getValue","initialAstWithoutTokens","undefined","astWithTokens","parseDocumentFromTextBuffer","didLanguageChange","languageId","handleDidChangeBackgroundTokenizationState","wasUndefined","fire","handleDidChangeTokens","ranges","edits","map","r","fromLineNumber","toLineNumber","handleContentChanged","change","changes","c","range","lift","getStartPosition","getEndPosition","text","reverse","previousAst","immutable","isPure","previousAstClone","deepClone","result","getBracketsInRange","startOffset","startLineNumber","startColumn","endOffset","endLineNumber","endColumn","Array","node","collectBrackets","length","Map","getBracketPairsInRange","includeMinIndentation","startLength","endLength","context","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","position","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","kind","lengths","child","children","push","i","bracketInfo","level","levelPerBracketType","levelPerBracket","existing","get","openingBracket","set","closingBracket","_a","openingBracketEnd","minIndentation","computeMinIndentation","curOffset","childOffset"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nexport class BracketPairsTree extends Disposable {\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        if (textModel.tokenization.backgroundTokenizationState === 0 /* BackgroundTokenizationState.Uninitialized */) {\n            // There are no token information yet\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 1 /* BackgroundTokenizationState.InProgress */) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = change.changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n        if (this.initialAstWithoutTokens) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);\n        }\n    }\n    //#endregion\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range) {\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        const result = new Array();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result, 0, new Map());\n        return result;\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        const result = new Array();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);\n        collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        return result;\n    }\n    getFirstBracketAfter(position) {\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level, levelPerBracketType) {\n    if (level > 200) {\n        return;\n    }\n    if (node.kind === 4 /* AstNodeKind.List */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level, levelPerBracketType);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n    }\n    else if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        // Don't use node.children here to improve performance\n        {\n            const child = node.openingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                result.push(new BracketInfo(range, level, levelPerBracket, !node.closingBracket));\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level + 1, levelPerBracketType);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.closingBracket) {\n            const child = node.closingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                result.push(new BracketInfo(range, level, levelPerBracket, false));\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, 0, true));\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, 0, false));\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(result, includeMinIndentation, textModel) {\n        this.result = result;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    var _a;\n    if (level > 200) {\n        return;\n    }\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n            }\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}