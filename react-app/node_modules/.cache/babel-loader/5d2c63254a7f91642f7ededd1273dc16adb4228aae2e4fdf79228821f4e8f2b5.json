{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nclass Coordinate {\n  constructor(top, left) {\n    this._coordinateBrand = undefined;\n    this.top = top;\n    this.left = left;\n  }\n}\nexport class ViewContentWidgets extends ViewPart {\n  constructor(context, viewDomNode) {\n    super(context);\n    this._viewDomNode = viewDomNode;\n    this._widgets = {};\n    this.domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this.domNode, 1 /* PartFingerprint.ContentWidgets */);\n    this.domNode.setClassName('contentWidgets');\n    this.domNode.setPosition('absolute');\n    this.domNode.setTop(0);\n    this.overflowingContentWidgetsDomNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this.overflowingContentWidgetsDomNode, 2 /* PartFingerprint.OverflowingContentWidgets */);\n    this.overflowingContentWidgetsDomNode.setClassName('overflowingContentWidgets');\n  }\n  dispose() {\n    super.dispose();\n    this._widgets = {};\n  }\n  // --- begin event handlers\n  onConfigurationChanged(e) {\n    const keys = Object.keys(this._widgets);\n    for (const widgetId of keys) {\n      this._widgets[widgetId].onConfigurationChanged(e);\n    }\n    return true;\n  }\n  onDecorationsChanged(e) {\n    // true for inline decorations that can end up relayouting text\n    return true;\n  }\n  onFlushed(e) {\n    return true;\n  }\n  onLineMappingChanged(e) {\n    const keys = Object.keys(this._widgets);\n    for (const widgetId of keys) {\n      this._widgets[widgetId].onLineMappingChanged(e);\n    }\n    return true;\n  }\n  onLinesChanged(e) {\n    return true;\n  }\n  onLinesDeleted(e) {\n    return true;\n  }\n  onLinesInserted(e) {\n    return true;\n  }\n  onScrollChanged(e) {\n    return true;\n  }\n  onZonesChanged(e) {\n    return true;\n  }\n  // ---- end view event handlers\n  addWidget(_widget) {\n    const myWidget = new Widget(this._context, this._viewDomNode, _widget);\n    this._widgets[myWidget.id] = myWidget;\n    if (myWidget.allowEditorOverflow) {\n      this.overflowingContentWidgetsDomNode.appendChild(myWidget.domNode);\n    } else {\n      this.domNode.appendChild(myWidget.domNode);\n    }\n    this.setShouldRender();\n  }\n  setWidgetPosition(widget, range, preference, affinity) {\n    const myWidget = this._widgets[widget.getId()];\n    myWidget.setPosition(range, preference, affinity);\n    this.setShouldRender();\n  }\n  removeWidget(widget) {\n    const widgetId = widget.getId();\n    if (this._widgets.hasOwnProperty(widgetId)) {\n      const myWidget = this._widgets[widgetId];\n      delete this._widgets[widgetId];\n      const domNode = myWidget.domNode.domNode;\n      domNode.parentNode.removeChild(domNode);\n      domNode.removeAttribute('monaco-visible-content-widget');\n      this.setShouldRender();\n    }\n  }\n  shouldSuppressMouseDownOnWidget(widgetId) {\n    if (this._widgets.hasOwnProperty(widgetId)) {\n      return this._widgets[widgetId].suppressMouseDown;\n    }\n    return false;\n  }\n  onBeforeRender(viewportData) {\n    const keys = Object.keys(this._widgets);\n    for (const widgetId of keys) {\n      this._widgets[widgetId].onBeforeRender(viewportData);\n    }\n  }\n  prepareRender(ctx) {\n    const keys = Object.keys(this._widgets);\n    for (const widgetId of keys) {\n      this._widgets[widgetId].prepareRender(ctx);\n    }\n  }\n  render(ctx) {\n    const keys = Object.keys(this._widgets);\n    for (const widgetId of keys) {\n      this._widgets[widgetId].render(ctx);\n    }\n  }\n}\nclass Widget {\n  constructor(context, viewDomNode, actual) {\n    this._context = context;\n    this._viewDomNode = viewDomNode;\n    this._actual = actual;\n    this.domNode = createFastDomNode(this._actual.getDomNode());\n    this.id = this._actual.getId();\n    this.allowEditorOverflow = this._actual.allowEditorOverflow || false;\n    this.suppressMouseDown = this._actual.suppressMouseDown || false;\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n    this._fixedOverflowWidgets = options.get(38 /* EditorOption.fixedOverflowWidgets */);\n    this._contentWidth = layoutInfo.contentWidth;\n    this._contentLeft = layoutInfo.contentLeft;\n    this._lineHeight = options.get(61 /* EditorOption.lineHeight */);\n    this._range = null;\n    this._viewRange = null;\n    this._affinity = null;\n    this._preference = [];\n    this._cachedDomNodeOffsetWidth = -1;\n    this._cachedDomNodeOffsetHeight = -1;\n    this._maxWidth = this._getMaxWidth();\n    this._isVisible = false;\n    this._renderData = null;\n    this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? 'fixed' : 'absolute');\n    this.domNode.setDisplay('none');\n    this.domNode.setVisibility('hidden');\n    this.domNode.setAttribute('widgetId', this.id);\n    this.domNode.setMaxWidth(this._maxWidth);\n  }\n  onConfigurationChanged(e) {\n    const options = this._context.configuration.options;\n    this._lineHeight = options.get(61 /* EditorOption.lineHeight */);\n    if (e.hasChanged(133 /* EditorOption.layoutInfo */)) {\n      const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n      this._contentLeft = layoutInfo.contentLeft;\n      this._contentWidth = layoutInfo.contentWidth;\n      this._maxWidth = this._getMaxWidth();\n    }\n  }\n  onLineMappingChanged(e) {\n    this._setPosition(this._range, this._affinity);\n  }\n  _setPosition(range, affinity) {\n    var _a;\n    this._range = range;\n    this._viewRange = null;\n    this._affinity = affinity;\n    if (this._range) {\n      // Do not trust that widgets give a valid position\n      const validModelRange = this._context.viewModel.model.validateRange(this._range);\n      if (this._context.viewModel.coordinatesConverter.modelPositionIsVisible(validModelRange.getStartPosition()) || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(validModelRange.getEndPosition())) {\n        this._viewRange = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(validModelRange, (_a = this._affinity) !== null && _a !== void 0 ? _a : undefined);\n      }\n    }\n  }\n  _getMaxWidth() {\n    return this.allowEditorOverflow ? window.innerWidth || document.documentElement.offsetWidth || document.body.offsetWidth : this._contentWidth;\n  }\n  setPosition(range, preference, affinity) {\n    this._setPosition(range, affinity);\n    this._preference = preference;\n    if (this._viewRange && this._preference && this._preference.length > 0) {\n      // this content widget would like to be visible if possible\n      // we change it from `display:none` to `display:block` even if it\n      // might be outside the viewport such that we can measure its size\n      // in `prepareRender`\n      this.domNode.setDisplay('block');\n    } else {\n      this.domNode.setDisplay('none');\n    }\n    this._cachedDomNodeOffsetWidth = -1;\n    this._cachedDomNodeOffsetHeight = -1;\n  }\n  _layoutBoxInViewport(topLeft, bottomLeft, width, height, ctx) {\n    // Our visible box is split horizontally by the current line => 2 boxes\n    // a) the box above the line\n    const aboveLineTop = topLeft.top;\n    const heightAboveLine = aboveLineTop;\n    // b) the box under the line\n    const underLineTop = bottomLeft.top + this._lineHeight;\n    const heightUnderLine = ctx.viewportHeight - underLineTop;\n    const aboveTop = aboveLineTop - height;\n    const fitsAbove = heightAboveLine >= height;\n    const belowTop = underLineTop;\n    const fitsBelow = heightUnderLine >= height;\n    // And its left\n    let actualAboveLeft = topLeft.left;\n    let actualBelowLeft = bottomLeft.left;\n    if (actualAboveLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n      actualAboveLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n    }\n    if (actualBelowLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n      actualBelowLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n    }\n    if (actualAboveLeft < ctx.scrollLeft) {\n      actualAboveLeft = ctx.scrollLeft;\n    }\n    if (actualBelowLeft < ctx.scrollLeft) {\n      actualBelowLeft = ctx.scrollLeft;\n    }\n    return {\n      fitsAbove: fitsAbove,\n      aboveTop: aboveTop,\n      aboveLeft: actualAboveLeft,\n      fitsBelow: fitsBelow,\n      belowTop: belowTop,\n      belowLeft: actualBelowLeft\n    };\n  }\n  _layoutHorizontalSegmentInPage(windowSize, domNodePosition, left, width) {\n    // Initially, the limits are defined as the dom node limits\n    const MIN_LIMIT = Math.max(0, domNodePosition.left - width);\n    const MAX_LIMIT = Math.min(domNodePosition.left + domNodePosition.width + width, windowSize.width);\n    let absoluteLeft = domNodePosition.left + left - dom.StandardWindow.scrollX;\n    if (absoluteLeft + width > MAX_LIMIT) {\n      const delta = absoluteLeft - (MAX_LIMIT - width);\n      absoluteLeft -= delta;\n      left -= delta;\n    }\n    if (absoluteLeft < MIN_LIMIT) {\n      const delta = absoluteLeft - MIN_LIMIT;\n      absoluteLeft -= delta;\n      left -= delta;\n    }\n    return [left, absoluteLeft];\n  }\n  _layoutBoxInPage(topLeft, bottomLeft, width, height, ctx) {\n    const aboveTop = topLeft.top - height;\n    const belowTop = bottomLeft.top + this._lineHeight;\n    const domNodePosition = dom.getDomNodePagePosition(this._viewDomNode.domNode);\n    const absoluteAboveTop = domNodePosition.top + aboveTop - dom.StandardWindow.scrollY;\n    const absoluteBelowTop = domNodePosition.top + belowTop - dom.StandardWindow.scrollY;\n    const windowSize = dom.getClientArea(document.body);\n    const [aboveLeft, absoluteAboveLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, topLeft.left - ctx.scrollLeft + this._contentLeft, width);\n    const [belowLeft, absoluteBelowLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, bottomLeft.left - ctx.scrollLeft + this._contentLeft, width);\n    // Leave some clearance to the top/bottom\n    const TOP_PADDING = 22;\n    const BOTTOM_PADDING = 22;\n    const fitsAbove = absoluteAboveTop >= TOP_PADDING;\n    const fitsBelow = absoluteBelowTop + height <= windowSize.height - BOTTOM_PADDING;\n    if (this._fixedOverflowWidgets) {\n      return {\n        fitsAbove,\n        aboveTop: Math.max(absoluteAboveTop, TOP_PADDING),\n        aboveLeft: absoluteAboveLeft,\n        fitsBelow,\n        belowTop: absoluteBelowTop,\n        belowLeft: absoluteBelowLeft\n      };\n    }\n    return {\n      fitsAbove,\n      aboveTop: aboveTop,\n      aboveLeft,\n      fitsBelow,\n      belowTop,\n      belowLeft\n    };\n  }\n  _prepareRenderWidgetAtExactPositionOverflowing(topLeft) {\n    return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);\n  }\n  /**\n   * Compute `this._topLeft`\n   */\n  _getTopAndBottomLeft(ctx) {\n    if (!this._viewRange) {\n      return [null, null];\n    }\n    const visibleRangesForRange = ctx.linesVisibleRangesForRange(this._viewRange, false);\n    if (!visibleRangesForRange || visibleRangesForRange.length === 0) {\n      return [null, null];\n    }\n    let firstLine = visibleRangesForRange[0];\n    let lastLine = visibleRangesForRange[0];\n    for (const visibleRangesForLine of visibleRangesForRange) {\n      if (visibleRangesForLine.lineNumber < firstLine.lineNumber) {\n        firstLine = visibleRangesForLine;\n      }\n      if (visibleRangesForLine.lineNumber > lastLine.lineNumber) {\n        lastLine = visibleRangesForLine;\n      }\n    }\n    let firstLineMinLeft = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */; //firstLine.Constants.MAX_SAFE_SMALL_INTEGER;\n    for (const visibleRange of firstLine.ranges) {\n      if (visibleRange.left < firstLineMinLeft) {\n        firstLineMinLeft = visibleRange.left;\n      }\n    }\n    let lastLineMinLeft = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */; //lastLine.Constants.MAX_SAFE_SMALL_INTEGER;\n    for (const visibleRange of lastLine.ranges) {\n      if (visibleRange.left < lastLineMinLeft) {\n        lastLineMinLeft = visibleRange.left;\n      }\n    }\n    const topForPosition = ctx.getVerticalOffsetForLineNumber(firstLine.lineNumber) - ctx.scrollTop;\n    const topLeft = new Coordinate(topForPosition, firstLineMinLeft);\n    const topForBottomLine = ctx.getVerticalOffsetForLineNumber(lastLine.lineNumber) - ctx.scrollTop;\n    const bottomLeft = new Coordinate(topForBottomLine, lastLineMinLeft);\n    return [topLeft, bottomLeft];\n  }\n  _prepareRenderWidget(ctx) {\n    if (!this._preference || this._preference.length === 0) {\n      return null;\n    }\n    const [topLeft, bottomLeft] = this._getTopAndBottomLeft(ctx);\n    if (!topLeft || !bottomLeft) {\n      return null;\n    }\n    if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {\n      let preferredDimensions = null;\n      if (typeof this._actual.beforeRender === 'function') {\n        preferredDimensions = safeInvoke(this._actual.beforeRender, this._actual);\n      }\n      if (preferredDimensions) {\n        this._cachedDomNodeOffsetWidth = preferredDimensions.width;\n        this._cachedDomNodeOffsetHeight = preferredDimensions.height;\n      } else {\n        const domNode = this.domNode.domNode;\n        const clientRect = domNode.getBoundingClientRect();\n        this._cachedDomNodeOffsetWidth = Math.round(clientRect.width);\n        this._cachedDomNodeOffsetHeight = Math.round(clientRect.height);\n      }\n    }\n    let placement;\n    if (this.allowEditorOverflow) {\n      placement = this._layoutBoxInPage(topLeft, bottomLeft, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);\n    } else {\n      placement = this._layoutBoxInViewport(topLeft, bottomLeft, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);\n    }\n    // Do two passes, first for perfect fit, second picks first option\n    for (let pass = 1; pass <= 2; pass++) {\n      for (const pref of this._preference) {\n        // placement\n        if (pref === 1 /* ContentWidgetPositionPreference.ABOVE */) {\n          if (!placement) {\n            // Widget outside of viewport\n            return null;\n          }\n          if (pass === 2 || placement.fitsAbove) {\n            return {\n              coordinate: new Coordinate(placement.aboveTop, placement.aboveLeft),\n              position: 1 /* ContentWidgetPositionPreference.ABOVE */\n            };\n          }\n        } else if (pref === 2 /* ContentWidgetPositionPreference.BELOW */) {\n          if (!placement) {\n            // Widget outside of viewport\n            return null;\n          }\n          if (pass === 2 || placement.fitsBelow) {\n            return {\n              coordinate: new Coordinate(placement.belowTop, placement.belowLeft),\n              position: 2 /* ContentWidgetPositionPreference.BELOW */\n            };\n          }\n        } else {\n          if (this.allowEditorOverflow) {\n            return {\n              coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(topLeft),\n              position: 0 /* ContentWidgetPositionPreference.EXACT */\n            };\n          } else {\n            return {\n              coordinate: topLeft,\n              position: 0 /* ContentWidgetPositionPreference.EXACT */\n            };\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.\n   */\n  onBeforeRender(viewportData) {\n    if (!this._viewRange || !this._preference) {\n      return;\n    }\n    if (this._viewRange.endLineNumber < viewportData.startLineNumber || this._viewRange.startLineNumber > viewportData.endLineNumber) {\n      // Outside of viewport\n      return;\n    }\n    this.domNode.setMaxWidth(this._maxWidth);\n  }\n  prepareRender(ctx) {\n    this._renderData = this._prepareRenderWidget(ctx);\n  }\n  render(ctx) {\n    if (!this._renderData) {\n      // This widget should be invisible\n      if (this._isVisible) {\n        this.domNode.removeAttribute('monaco-visible-content-widget');\n        this._isVisible = false;\n        this.domNode.setVisibility('hidden');\n      }\n      if (typeof this._actual.afterRender === 'function') {\n        safeInvoke(this._actual.afterRender, this._actual, null);\n      }\n      return;\n    }\n    // This widget should be visible\n    if (this.allowEditorOverflow) {\n      this.domNode.setTop(this._renderData.coordinate.top);\n      this.domNode.setLeft(this._renderData.coordinate.left);\n    } else {\n      this.domNode.setTop(this._renderData.coordinate.top + ctx.scrollTop - ctx.bigNumbersDelta);\n      this.domNode.setLeft(this._renderData.coordinate.left);\n    }\n    if (!this._isVisible) {\n      this.domNode.setVisibility('inherit');\n      this.domNode.setAttribute('monaco-visible-content-widget', 'true');\n      this._isVisible = true;\n    }\n    if (typeof this._actual.afterRender === 'function') {\n      safeInvoke(this._actual.afterRender, this._actual, this._renderData.position);\n    }\n  }\n}\nfunction safeInvoke(fn, thisArg) {\n  try {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    return fn.call(thisArg, ...args);\n  } catch (_a) {\n    // ignore\n    return null;\n  }\n}","map":{"version":3,"names":["dom","createFastDomNode","PartFingerprints","ViewPart","Coordinate","constructor","top","left","_coordinateBrand","undefined","ViewContentWidgets","context","viewDomNode","_viewDomNode","_widgets","domNode","document","createElement","write","setClassName","setPosition","setTop","overflowingContentWidgetsDomNode","dispose","onConfigurationChanged","e","keys","Object","widgetId","onDecorationsChanged","onFlushed","onLineMappingChanged","onLinesChanged","onLinesDeleted","onLinesInserted","onScrollChanged","onZonesChanged","addWidget","_widget","myWidget","Widget","_context","id","allowEditorOverflow","appendChild","setShouldRender","setWidgetPosition","widget","range","preference","affinity","getId","removeWidget","hasOwnProperty","parentNode","removeChild","removeAttribute","shouldSuppressMouseDownOnWidget","suppressMouseDown","onBeforeRender","viewportData","prepareRender","ctx","render","actual","_actual","getDomNode","options","configuration","layoutInfo","get","_fixedOverflowWidgets","_contentWidth","contentWidth","_contentLeft","contentLeft","_lineHeight","_range","_viewRange","_affinity","_preference","_cachedDomNodeOffsetWidth","_cachedDomNodeOffsetHeight","_maxWidth","_getMaxWidth","_isVisible","_renderData","setDisplay","setVisibility","setAttribute","setMaxWidth","hasChanged","_setPosition","_a","validModelRange","viewModel","model","validateRange","coordinatesConverter","modelPositionIsVisible","getStartPosition","getEndPosition","convertModelRangeToViewRange","window","innerWidth","documentElement","offsetWidth","body","length","_layoutBoxInViewport","topLeft","bottomLeft","width","height","aboveLineTop","heightAboveLine","underLineTop","heightUnderLine","viewportHeight","aboveTop","fitsAbove","belowTop","fitsBelow","actualAboveLeft","actualBelowLeft","scrollLeft","viewportWidth","aboveLeft","belowLeft","_layoutHorizontalSegmentInPage","windowSize","domNodePosition","MIN_LIMIT","Math","max","MAX_LIMIT","min","absoluteLeft","StandardWindow","scrollX","delta","_layoutBoxInPage","getDomNodePagePosition","absoluteAboveTop","scrollY","absoluteBelowTop","getClientArea","absoluteAboveLeft","absoluteBelowLeft","TOP_PADDING","BOTTOM_PADDING","_prepareRenderWidgetAtExactPositionOverflowing","_getTopAndBottomLeft","visibleRangesForRange","linesVisibleRangesForRange","firstLine","lastLine","visibleRangesForLine","lineNumber","firstLineMinLeft","visibleRange","ranges","lastLineMinLeft","topForPosition","getVerticalOffsetForLineNumber","scrollTop","topForBottomLine","_prepareRenderWidget","preferredDimensions","beforeRender","safeInvoke","clientRect","getBoundingClientRect","round","placement","pass","pref","coordinate","position","endLineNumber","startLineNumber","afterRender","setLeft","bigNumbersDelta","fn","thisArg","args","call"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/contentWidgets/contentWidgets.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nclass Coordinate {\n    constructor(top, left) {\n        this._coordinateBrand = undefined;\n        this.top = top;\n        this.left = left;\n    }\n}\nexport class ViewContentWidgets extends ViewPart {\n    constructor(context, viewDomNode) {\n        super(context);\n        this._viewDomNode = viewDomNode;\n        this._widgets = {};\n        this.domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this.domNode, 1 /* PartFingerprint.ContentWidgets */);\n        this.domNode.setClassName('contentWidgets');\n        this.domNode.setPosition('absolute');\n        this.domNode.setTop(0);\n        this.overflowingContentWidgetsDomNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this.overflowingContentWidgetsDomNode, 2 /* PartFingerprint.OverflowingContentWidgets */);\n        this.overflowingContentWidgetsDomNode.setClassName('overflowingContentWidgets');\n    }\n    dispose() {\n        super.dispose();\n        this._widgets = {};\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onConfigurationChanged(e);\n        }\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLineMappingChanged(e) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onLineMappingChanged(e);\n        }\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // ---- end view event handlers\n    addWidget(_widget) {\n        const myWidget = new Widget(this._context, this._viewDomNode, _widget);\n        this._widgets[myWidget.id] = myWidget;\n        if (myWidget.allowEditorOverflow) {\n            this.overflowingContentWidgetsDomNode.appendChild(myWidget.domNode);\n        }\n        else {\n            this.domNode.appendChild(myWidget.domNode);\n        }\n        this.setShouldRender();\n    }\n    setWidgetPosition(widget, range, preference, affinity) {\n        const myWidget = this._widgets[widget.getId()];\n        myWidget.setPosition(range, preference, affinity);\n        this.setShouldRender();\n    }\n    removeWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._widgets.hasOwnProperty(widgetId)) {\n            const myWidget = this._widgets[widgetId];\n            delete this._widgets[widgetId];\n            const domNode = myWidget.domNode.domNode;\n            domNode.parentNode.removeChild(domNode);\n            domNode.removeAttribute('monaco-visible-content-widget');\n            this.setShouldRender();\n        }\n    }\n    shouldSuppressMouseDownOnWidget(widgetId) {\n        if (this._widgets.hasOwnProperty(widgetId)) {\n            return this._widgets[widgetId].suppressMouseDown;\n        }\n        return false;\n    }\n    onBeforeRender(viewportData) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onBeforeRender(viewportData);\n        }\n    }\n    prepareRender(ctx) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].prepareRender(ctx);\n        }\n    }\n    render(ctx) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].render(ctx);\n        }\n    }\n}\nclass Widget {\n    constructor(context, viewDomNode, actual) {\n        this._context = context;\n        this._viewDomNode = viewDomNode;\n        this._actual = actual;\n        this.domNode = createFastDomNode(this._actual.getDomNode());\n        this.id = this._actual.getId();\n        this.allowEditorOverflow = this._actual.allowEditorOverflow || false;\n        this.suppressMouseDown = this._actual.suppressMouseDown || false;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this._fixedOverflowWidgets = options.get(38 /* EditorOption.fixedOverflowWidgets */);\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentLeft = layoutInfo.contentLeft;\n        this._lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this._range = null;\n        this._viewRange = null;\n        this._affinity = null;\n        this._preference = [];\n        this._cachedDomNodeOffsetWidth = -1;\n        this._cachedDomNodeOffsetHeight = -1;\n        this._maxWidth = this._getMaxWidth();\n        this._isVisible = false;\n        this._renderData = null;\n        this.domNode.setPosition((this._fixedOverflowWidgets && this.allowEditorOverflow) ? 'fixed' : 'absolute');\n        this.domNode.setDisplay('none');\n        this.domNode.setVisibility('hidden');\n        this.domNode.setAttribute('widgetId', this.id);\n        this.domNode.setMaxWidth(this._maxWidth);\n    }\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        if (e.hasChanged(133 /* EditorOption.layoutInfo */)) {\n            const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n            this._contentLeft = layoutInfo.contentLeft;\n            this._contentWidth = layoutInfo.contentWidth;\n            this._maxWidth = this._getMaxWidth();\n        }\n    }\n    onLineMappingChanged(e) {\n        this._setPosition(this._range, this._affinity);\n    }\n    _setPosition(range, affinity) {\n        var _a;\n        this._range = range;\n        this._viewRange = null;\n        this._affinity = affinity;\n        if (this._range) {\n            // Do not trust that widgets give a valid position\n            const validModelRange = this._context.viewModel.model.validateRange(this._range);\n            if (this._context.viewModel.coordinatesConverter.modelPositionIsVisible(validModelRange.getStartPosition()) || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(validModelRange.getEndPosition())) {\n                this._viewRange = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(validModelRange, (_a = this._affinity) !== null && _a !== void 0 ? _a : undefined);\n            }\n        }\n    }\n    _getMaxWidth() {\n        return (this.allowEditorOverflow\n            ? window.innerWidth || document.documentElement.offsetWidth || document.body.offsetWidth\n            : this._contentWidth);\n    }\n    setPosition(range, preference, affinity) {\n        this._setPosition(range, affinity);\n        this._preference = preference;\n        if (this._viewRange && this._preference && this._preference.length > 0) {\n            // this content widget would like to be visible if possible\n            // we change it from `display:none` to `display:block` even if it\n            // might be outside the viewport such that we can measure its size\n            // in `prepareRender`\n            this.domNode.setDisplay('block');\n        }\n        else {\n            this.domNode.setDisplay('none');\n        }\n        this._cachedDomNodeOffsetWidth = -1;\n        this._cachedDomNodeOffsetHeight = -1;\n    }\n    _layoutBoxInViewport(topLeft, bottomLeft, width, height, ctx) {\n        // Our visible box is split horizontally by the current line => 2 boxes\n        // a) the box above the line\n        const aboveLineTop = topLeft.top;\n        const heightAboveLine = aboveLineTop;\n        // b) the box under the line\n        const underLineTop = bottomLeft.top + this._lineHeight;\n        const heightUnderLine = ctx.viewportHeight - underLineTop;\n        const aboveTop = aboveLineTop - height;\n        const fitsAbove = (heightAboveLine >= height);\n        const belowTop = underLineTop;\n        const fitsBelow = (heightUnderLine >= height);\n        // And its left\n        let actualAboveLeft = topLeft.left;\n        let actualBelowLeft = bottomLeft.left;\n        if (actualAboveLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n            actualAboveLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n        }\n        if (actualBelowLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n            actualBelowLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n        }\n        if (actualAboveLeft < ctx.scrollLeft) {\n            actualAboveLeft = ctx.scrollLeft;\n        }\n        if (actualBelowLeft < ctx.scrollLeft) {\n            actualBelowLeft = ctx.scrollLeft;\n        }\n        return {\n            fitsAbove: fitsAbove,\n            aboveTop: aboveTop,\n            aboveLeft: actualAboveLeft,\n            fitsBelow: fitsBelow,\n            belowTop: belowTop,\n            belowLeft: actualBelowLeft,\n        };\n    }\n    _layoutHorizontalSegmentInPage(windowSize, domNodePosition, left, width) {\n        // Initially, the limits are defined as the dom node limits\n        const MIN_LIMIT = Math.max(0, domNodePosition.left - width);\n        const MAX_LIMIT = Math.min(domNodePosition.left + domNodePosition.width + width, windowSize.width);\n        let absoluteLeft = domNodePosition.left + left - dom.StandardWindow.scrollX;\n        if (absoluteLeft + width > MAX_LIMIT) {\n            const delta = absoluteLeft - (MAX_LIMIT - width);\n            absoluteLeft -= delta;\n            left -= delta;\n        }\n        if (absoluteLeft < MIN_LIMIT) {\n            const delta = absoluteLeft - MIN_LIMIT;\n            absoluteLeft -= delta;\n            left -= delta;\n        }\n        return [left, absoluteLeft];\n    }\n    _layoutBoxInPage(topLeft, bottomLeft, width, height, ctx) {\n        const aboveTop = topLeft.top - height;\n        const belowTop = bottomLeft.top + this._lineHeight;\n        const domNodePosition = dom.getDomNodePagePosition(this._viewDomNode.domNode);\n        const absoluteAboveTop = domNodePosition.top + aboveTop - dom.StandardWindow.scrollY;\n        const absoluteBelowTop = domNodePosition.top + belowTop - dom.StandardWindow.scrollY;\n        const windowSize = dom.getClientArea(document.body);\n        const [aboveLeft, absoluteAboveLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, topLeft.left - ctx.scrollLeft + this._contentLeft, width);\n        const [belowLeft, absoluteBelowLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, bottomLeft.left - ctx.scrollLeft + this._contentLeft, width);\n        // Leave some clearance to the top/bottom\n        const TOP_PADDING = 22;\n        const BOTTOM_PADDING = 22;\n        const fitsAbove = (absoluteAboveTop >= TOP_PADDING);\n        const fitsBelow = (absoluteBelowTop + height <= windowSize.height - BOTTOM_PADDING);\n        if (this._fixedOverflowWidgets) {\n            return {\n                fitsAbove,\n                aboveTop: Math.max(absoluteAboveTop, TOP_PADDING),\n                aboveLeft: absoluteAboveLeft,\n                fitsBelow,\n                belowTop: absoluteBelowTop,\n                belowLeft: absoluteBelowLeft\n            };\n        }\n        return {\n            fitsAbove,\n            aboveTop: aboveTop,\n            aboveLeft,\n            fitsBelow,\n            belowTop,\n            belowLeft\n        };\n    }\n    _prepareRenderWidgetAtExactPositionOverflowing(topLeft) {\n        return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);\n    }\n    /**\n     * Compute `this._topLeft`\n     */\n    _getTopAndBottomLeft(ctx) {\n        if (!this._viewRange) {\n            return [null, null];\n        }\n        const visibleRangesForRange = ctx.linesVisibleRangesForRange(this._viewRange, false);\n        if (!visibleRangesForRange || visibleRangesForRange.length === 0) {\n            return [null, null];\n        }\n        let firstLine = visibleRangesForRange[0];\n        let lastLine = visibleRangesForRange[0];\n        for (const visibleRangesForLine of visibleRangesForRange) {\n            if (visibleRangesForLine.lineNumber < firstLine.lineNumber) {\n                firstLine = visibleRangesForLine;\n            }\n            if (visibleRangesForLine.lineNumber > lastLine.lineNumber) {\n                lastLine = visibleRangesForLine;\n            }\n        }\n        let firstLineMinLeft = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */; //firstLine.Constants.MAX_SAFE_SMALL_INTEGER;\n        for (const visibleRange of firstLine.ranges) {\n            if (visibleRange.left < firstLineMinLeft) {\n                firstLineMinLeft = visibleRange.left;\n            }\n        }\n        let lastLineMinLeft = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */; //lastLine.Constants.MAX_SAFE_SMALL_INTEGER;\n        for (const visibleRange of lastLine.ranges) {\n            if (visibleRange.left < lastLineMinLeft) {\n                lastLineMinLeft = visibleRange.left;\n            }\n        }\n        const topForPosition = ctx.getVerticalOffsetForLineNumber(firstLine.lineNumber) - ctx.scrollTop;\n        const topLeft = new Coordinate(topForPosition, firstLineMinLeft);\n        const topForBottomLine = ctx.getVerticalOffsetForLineNumber(lastLine.lineNumber) - ctx.scrollTop;\n        const bottomLeft = new Coordinate(topForBottomLine, lastLineMinLeft);\n        return [topLeft, bottomLeft];\n    }\n    _prepareRenderWidget(ctx) {\n        if (!this._preference || this._preference.length === 0) {\n            return null;\n        }\n        const [topLeft, bottomLeft] = this._getTopAndBottomLeft(ctx);\n        if (!topLeft || !bottomLeft) {\n            return null;\n        }\n        if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {\n            let preferredDimensions = null;\n            if (typeof this._actual.beforeRender === 'function') {\n                preferredDimensions = safeInvoke(this._actual.beforeRender, this._actual);\n            }\n            if (preferredDimensions) {\n                this._cachedDomNodeOffsetWidth = preferredDimensions.width;\n                this._cachedDomNodeOffsetHeight = preferredDimensions.height;\n            }\n            else {\n                const domNode = this.domNode.domNode;\n                const clientRect = domNode.getBoundingClientRect();\n                this._cachedDomNodeOffsetWidth = Math.round(clientRect.width);\n                this._cachedDomNodeOffsetHeight = Math.round(clientRect.height);\n            }\n        }\n        let placement;\n        if (this.allowEditorOverflow) {\n            placement = this._layoutBoxInPage(topLeft, bottomLeft, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);\n        }\n        else {\n            placement = this._layoutBoxInViewport(topLeft, bottomLeft, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);\n        }\n        // Do two passes, first for perfect fit, second picks first option\n        for (let pass = 1; pass <= 2; pass++) {\n            for (const pref of this._preference) {\n                // placement\n                if (pref === 1 /* ContentWidgetPositionPreference.ABOVE */) {\n                    if (!placement) {\n                        // Widget outside of viewport\n                        return null;\n                    }\n                    if (pass === 2 || placement.fitsAbove) {\n                        return { coordinate: new Coordinate(placement.aboveTop, placement.aboveLeft), position: 1 /* ContentWidgetPositionPreference.ABOVE */ };\n                    }\n                }\n                else if (pref === 2 /* ContentWidgetPositionPreference.BELOW */) {\n                    if (!placement) {\n                        // Widget outside of viewport\n                        return null;\n                    }\n                    if (pass === 2 || placement.fitsBelow) {\n                        return { coordinate: new Coordinate(placement.belowTop, placement.belowLeft), position: 2 /* ContentWidgetPositionPreference.BELOW */ };\n                    }\n                }\n                else {\n                    if (this.allowEditorOverflow) {\n                        return { coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(topLeft), position: 0 /* ContentWidgetPositionPreference.EXACT */ };\n                    }\n                    else {\n                        return { coordinate: topLeft, position: 0 /* ContentWidgetPositionPreference.EXACT */ };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.\n     */\n    onBeforeRender(viewportData) {\n        if (!this._viewRange || !this._preference) {\n            return;\n        }\n        if (this._viewRange.endLineNumber < viewportData.startLineNumber || this._viewRange.startLineNumber > viewportData.endLineNumber) {\n            // Outside of viewport\n            return;\n        }\n        this.domNode.setMaxWidth(this._maxWidth);\n    }\n    prepareRender(ctx) {\n        this._renderData = this._prepareRenderWidget(ctx);\n    }\n    render(ctx) {\n        if (!this._renderData) {\n            // This widget should be invisible\n            if (this._isVisible) {\n                this.domNode.removeAttribute('monaco-visible-content-widget');\n                this._isVisible = false;\n                this.domNode.setVisibility('hidden');\n            }\n            if (typeof this._actual.afterRender === 'function') {\n                safeInvoke(this._actual.afterRender, this._actual, null);\n            }\n            return;\n        }\n        // This widget should be visible\n        if (this.allowEditorOverflow) {\n            this.domNode.setTop(this._renderData.coordinate.top);\n            this.domNode.setLeft(this._renderData.coordinate.left);\n        }\n        else {\n            this.domNode.setTop(this._renderData.coordinate.top + ctx.scrollTop - ctx.bigNumbersDelta);\n            this.domNode.setLeft(this._renderData.coordinate.left);\n        }\n        if (!this._isVisible) {\n            this.domNode.setVisibility('inherit');\n            this.domNode.setAttribute('monaco-visible-content-widget', 'true');\n            this._isVisible = true;\n        }\n        if (typeof this._actual.afterRender === 'function') {\n            safeInvoke(this._actual.afterRender, this._actual, this._renderData.position);\n        }\n    }\n}\nfunction safeInvoke(fn, thisArg, ...args) {\n    try {\n        return fn.call(thisArg, ...args);\n    }\n    catch (_a) {\n        // ignore\n        return null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}