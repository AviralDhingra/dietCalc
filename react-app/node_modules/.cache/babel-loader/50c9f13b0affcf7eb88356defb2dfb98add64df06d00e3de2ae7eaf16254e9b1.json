{"ast":null,"code":"import { onUnexpectedError } from './errors.js';\nimport { combinedDisposable, Disposable, DisposableStore, SafeDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n  Event.None = () => Disposable.None;\n  function _addLeakageTraceLogic(options) {\n    if (_enableSnapshotPotentialLeakWarning) {\n      const {\n        onListenerDidAdd: origListenerDidAdd\n      } = options;\n      const stack = Stacktrace.create();\n      let count = 0;\n      options.onListenerDidAdd = () => {\n        if (++count === 2) {\n          console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n          stack.print();\n        }\n        origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n      };\n    }\n  }\n  /**\n   * Given an event, returns another event which only fires once.\n   */\n  function once(event) {\n    return function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      // we need this, in case the event fires during the listener call\n      let didFire = false;\n      let result = undefined;\n      result = event(e => {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event.once = once;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function map(event, map, disposable) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(i => listener.call(thisArgs, map(i)), null, disposables);\n    }, disposable);\n  }\n  Event.map = map;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function forEach(event, each, disposable) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(i => {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    }, disposable);\n  }\n  Event.forEach = forEach;\n  function filter(event, filter, disposable) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(e => filter(e) && listener.call(thisArgs, e), null, disposables);\n    }, disposable);\n  }\n  Event.filter = filter;\n  /**\n   * Given an event, returns the same event but typed as `Event<void>`.\n   */\n  function signal(event) {\n    return event;\n  }\n  Event.signal = signal;\n  function any() {\n    for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {\n      events[_key] = arguments[_key];\n    }\n    return function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    };\n  }\n  Event.any = any;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function reduce(event, merge, initial, disposable) {\n    let output = initial;\n    return map(event, e => {\n      output = merge(output, e);\n      return output;\n    }, disposable);\n  }\n  Event.reduce = reduce;\n  function snapshot(event, disposable) {\n    let listener;\n    const options = {\n      onFirstListenerAdd() {\n        listener = event(emitter.fire, emitter);\n      },\n      onLastListenerRemove() {\n        listener === null || listener === void 0 ? void 0 : listener.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  function debounce(event, merge) {\n    let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    let leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let leakWarningThreshold = arguments.length > 4 ? arguments[4] : undefined;\n    let disposable = arguments.length > 5 ? arguments[5] : undefined;\n    let subscription;\n    let output = undefined;\n    let handle = undefined;\n    let numDebouncedCalls = 0;\n    const options = {\n      leakWarningThreshold,\n      onFirstListenerAdd() {\n        subscription = event(cur => {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n          clearTimeout(handle);\n          handle = setTimeout(() => {\n            const _output = output;\n            output = undefined;\n            handle = undefined;\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          }, delay);\n        });\n      },\n      onLastListenerRemove() {\n        subscription.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  Event.debounce = debounce;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function latch(event) {\n    let equals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (a, b) => a === b;\n    let disposable = arguments.length > 2 ? arguments[2] : undefined;\n    let firstCall = true;\n    let cache;\n    return filter(event, value => {\n      const shouldEmit = firstCall || !equals(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    }, disposable);\n  }\n  Event.latch = latch;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function split(event, isT, disposable) {\n    return [Event.filter(event, isT, disposable), Event.filter(event, e => !isT(e), disposable)];\n  }\n  Event.split = split;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function buffer(event) {\n    let flushAfterTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let _buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let buffer = _buffer.slice();\n    let listener = event(e => {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    const flush = () => {\n      buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n      buffer = null;\n    };\n    const emitter = new Emitter({\n      onFirstListenerAdd() {\n        if (!listener) {\n          listener = event(e => emitter.fire(e));\n        }\n      },\n      onFirstListenerDidAdd() {\n        if (buffer) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onLastListenerRemove() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    return emitter.event;\n  }\n  Event.buffer = buffer;\n  class ChainableEvent {\n    constructor(event) {\n      this.event = event;\n      this.disposables = new DisposableStore();\n    }\n    map(fn) {\n      return new ChainableEvent(map(this.event, fn, this.disposables));\n    }\n    forEach(fn) {\n      return new ChainableEvent(forEach(this.event, fn, this.disposables));\n    }\n    filter(fn) {\n      return new ChainableEvent(filter(this.event, fn, this.disposables));\n    }\n    reduce(merge, initial) {\n      return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));\n    }\n    latch() {\n      return new ChainableEvent(latch(this.event, undefined, this.disposables));\n    }\n    debounce(merge) {\n      let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      let leading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      let leakWarningThreshold = arguments.length > 3 ? arguments[3] : undefined;\n      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold, this.disposables));\n    }\n    on(listener, thisArgs, disposables) {\n      return this.event(listener, thisArgs, disposables);\n    }\n    once(listener, thisArgs, disposables) {\n      return once(this.event)(listener, thisArgs, disposables);\n    }\n    dispose() {\n      this.disposables.dispose();\n    }\n  }\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n  Event.chain = chain;\n  function fromNodeEventEmitter(emitter, eventName) {\n    let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : id => id;\n    const fn = function () {\n      return result.fire(map(...arguments));\n    };\n    const onFirstListenerAdd = () => emitter.on(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n    const result = new Emitter({\n      onFirstListenerAdd,\n      onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n  function fromDOMEventEmitter(emitter, eventName) {\n    let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : id => id;\n    const fn = function () {\n      return result.fire(map(...arguments));\n    };\n    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n    const result = new Emitter({\n      onFirstListenerAdd,\n      onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n  function toPromise(event) {\n    return new Promise(resolve => once(event)(resolve));\n  }\n  Event.toPromise = toPromise;\n  function runAndSubscribe(event, handler) {\n    handler(undefined);\n    return event(e => handler(e));\n  }\n  Event.runAndSubscribe = runAndSubscribe;\n  function runAndSubscribeWithStore(event, handler) {\n    let store = null;\n    function run(e) {\n      store === null || store === void 0 ? void 0 : store.dispose();\n      store = new DisposableStore();\n      handler(e, store);\n    }\n    run(undefined);\n    const disposable = event(e => run(e));\n    return toDisposable(() => {\n      disposable.dispose();\n      store === null || store === void 0 ? void 0 : store.dispose();\n    });\n  }\n  Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n  class EmitterObserver {\n    constructor(obs, store) {\n      this.obs = obs;\n      this._counter = 0;\n      this._hasChanged = false;\n      const options = {\n        onFirstListenerAdd: () => {\n          obs.addObserver(this);\n        },\n        onLastListenerRemove: () => {\n          obs.removeObserver(this);\n        }\n      };\n      if (!store) {\n        _addLeakageTraceLogic(options);\n      }\n      this.emitter = new Emitter(options);\n      if (store) {\n        store.add(this.emitter);\n      }\n    }\n    beginUpdate(_observable) {\n      // console.assert(_observable === this.obs);\n      this._counter++;\n    }\n    handleChange(_observable, _change) {\n      this._hasChanged = true;\n    }\n    endUpdate(_observable) {\n      if (--this._counter === 0) {\n        if (this._hasChanged) {\n          this._hasChanged = false;\n          this.emitter.fire(this.obs.get());\n        }\n      }\n    }\n  }\n  function fromObservable(obs, store) {\n    const observer = new EmitterObserver(obs, store);\n    return observer.emitter.event;\n  }\n  Event.fromObservable = fromObservable;\n})(Event || (Event = {}));\nclass EventProfiling {\n  constructor(name) {\n    this._listenerCount = 0;\n    this._invocationCount = 0;\n    this._elapsedOverall = 0;\n    this._name = `${name}_${EventProfiling._idPool++}`;\n  }\n  start(listenerCount) {\n    this._stopWatch = new StopWatch(true);\n    this._listenerCount = listenerCount;\n  }\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n      this._elapsedOverall += elapsed;\n      this._invocationCount += 1;\n      console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n      this._stopWatch = undefined;\n    }\n  }\n}\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n  constructor(customThreshold) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random().toString(18).slice(2, 5);\n    this.customThreshold = customThreshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  dispose() {\n    if (this._stacks) {\n      this._stacks.clear();\n    }\n  }\n  check(stack, listenerCount) {\n    let threshold = _globalLeakWarningThreshold;\n    if (typeof this.customThreshold === 'number') {\n      threshold = this.customThreshold;\n    }\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n    const count = this._stacks.get(stack.value) || 0;\n    this._stacks.set(stack.value, count + 1);\n    this._warnCountdown -= 1;\n    if (this._warnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._warnCountdown = threshold * 0.5;\n      // find most frequent listener and print warning\n      let topStack;\n      let topCount = 0;\n      for (const [stack, count] of this._stacks) {\n        if (!topStack || topCount < count) {\n          topStack = stack;\n          topCount = count;\n        }\n      }\n      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n      console.warn(topStack);\n    }\n    return () => {\n      const count = this._stacks.get(stack.value) || 0;\n      this._stacks.set(stack.value, count - 1);\n    };\n  }\n}\nclass Stacktrace {\n  constructor(value) {\n    this.value = value;\n  }\n  static create() {\n    var _a;\n    return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n  }\n  print() {\n    console.warn(this.value.split('\\n').slice(2).join('\\n'));\n  }\n}\nclass Listener {\n  constructor(callback, callbackThis, stack) {\n    this.callback = callback;\n    this.callbackThis = callbackThis;\n    this.stack = stack;\n    this.subscription = new SafeDisposable();\n  }\n  invoke(e) {\n    this.callback.call(this.callbackThis, e);\n  }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n  constructor(options) {\n    var _a, _b;\n    this._disposed = false;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n    this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n    this._deliveryQueue = (_b = this._options) === null || _b === void 0 ? void 0 : _b.deliveryQueue;\n  }\n  dispose() {\n    var _a, _b, _c, _d;\n    if (!this._disposed) {\n      this._disposed = true;\n      // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n      // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n      // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n      // the following programming pattern is very popular:\n      //\n      // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n      // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n      // ...later...\n      // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n      if (this._listeners) {\n        if (_enableDisposeWithListenerWarning) {\n          const listeners = Array.from(this._listeners);\n          queueMicrotask(() => {\n            var _a;\n            for (const listener of listeners) {\n              if (listener.subscription.isset()) {\n                listener.subscription.unset();\n                (_a = listener.stack) === null || _a === void 0 ? void 0 : _a.print();\n              }\n            }\n          });\n        }\n        this._listeners.clear();\n      }\n      (_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.clear(this);\n      (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 ? void 0 : _c.call(_b);\n      (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n  /**\n   * For the public to allow to subscribe\n   * to events from this Emitter\n   */\n  get event() {\n    if (!this._event) {\n      this._event = (callback, thisArgs, disposables) => {\n        var _a, _b, _c;\n        if (!this._listeners) {\n          this._listeners = new LinkedList();\n        }\n        const firstListener = this._listeners.isEmpty();\n        if (firstListener && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onFirstListenerAdd)) {\n          this._options.onFirstListenerAdd(this);\n        }\n        let removeMonitor;\n        let stack;\n        if (this._leakageMon && this._listeners.size >= 30) {\n          // check and record this emitter for potential leakage\n          stack = Stacktrace.create();\n          removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);\n        }\n        if (_enableDisposeWithListenerWarning) {\n          stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n        }\n        const listener = new Listener(callback, thisArgs, stack);\n        const removeListener = this._listeners.push(listener);\n        if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) {\n          this._options.onFirstListenerDidAdd(this);\n        }\n        if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) {\n          this._options.onListenerDidAdd(this, callback, thisArgs);\n        }\n        const result = listener.subscription.set(() => {\n          removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n          if (!this._disposed) {\n            removeListener();\n            if (this._options && this._options.onLastListenerRemove) {\n              const hasListeners = this._listeners && !this._listeners.isEmpty();\n              if (!hasListeners) {\n                this._options.onLastListenerRemove(this);\n              }\n            }\n          }\n        });\n        if (disposables instanceof DisposableStore) {\n          disposables.add(result);\n        } else if (Array.isArray(disposables)) {\n          disposables.push(result);\n        }\n        return result;\n      };\n    }\n    return this._event;\n  }\n  /**\n   * To be kept private to fire an event to\n   * subscribers\n   */\n  fire(event) {\n    var _a, _b;\n    if (this._listeners) {\n      // put all [listener,event]-pairs into delivery queue\n      // then emit all event. an inner/nested event might be\n      // the driver of this\n      if (!this._deliveryQueue) {\n        this._deliveryQueue = new PrivateEventDeliveryQueue();\n      }\n      for (const listener of this._listeners) {\n        this._deliveryQueue.push(this, listener, event);\n      }\n      // start/stop performance insight collection\n      (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n      this._deliveryQueue.deliver();\n      (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n    }\n  }\n}\nexport class EventDeliveryQueue {\n  constructor() {\n    this._queue = new LinkedList();\n  }\n  get size() {\n    return this._queue.size;\n  }\n  push(emitter, listener, event) {\n    this._queue.push(new EventDeliveryQueueElement(emitter, listener, event));\n  }\n  clear(emitter) {\n    const newQueue = new LinkedList();\n    for (const element of this._queue) {\n      if (element.emitter !== emitter) {\n        newQueue.push(element);\n      }\n    }\n    this._queue = newQueue;\n  }\n  deliver() {\n    while (this._queue.size > 0) {\n      const element = this._queue.shift();\n      try {\n        element.listener.invoke(element.event);\n      } catch (e) {\n        onUnexpectedError(e);\n      }\n    }\n  }\n}\n/**\n * An `EventDeliveryQueue` that is guaranteed to be used by a single `Emitter`.\n */\nclass PrivateEventDeliveryQueue extends EventDeliveryQueue {\n  clear(emitter) {\n    // Here we can just clear the entire linked list because\n    // all elements are guaranteed to belong to this emitter\n    this._queue.clear();\n  }\n}\nclass EventDeliveryQueueElement {\n  constructor(emitter, listener, event) {\n    this.emitter = emitter;\n    this.listener = listener;\n    this.event = event;\n  }\n}\nexport class PauseableEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._isPaused = 0;\n    this._eventQueue = new LinkedList();\n    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n  }\n  pause() {\n    this._isPaused++;\n  }\n  resume() {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        // use the merge function to create a single composite\n        // event. make a copy in case firing pauses this emitter\n        const events = Array.from(this._eventQueue);\n        this._eventQueue.clear();\n        super.fire(this._mergeFn(events));\n      } else {\n        // no merging, fire each event individually and test\n        // that this emitter isn't paused halfway through\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          super.fire(this._eventQueue.shift());\n        }\n      }\n    }\n  }\n  fire(event) {\n    if (this._listeners) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        super.fire(event);\n      }\n    }\n  }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n  constructor(options) {\n    var _a;\n    super(options);\n    this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n  }\n  fire(event) {\n    if (!this._handle) {\n      this.pause();\n      this._handle = setTimeout(() => {\n        this._handle = undefined;\n        this.resume();\n      }, this._delay);\n    }\n    super.fire(event);\n  }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n  constructor() {\n    this.buffers = [];\n  }\n  wrapEvent(event) {\n    return (listener, thisArgs, disposables) => {\n      return event(i => {\n        const buffer = this.buffers[this.buffers.length - 1];\n        if (buffer) {\n          buffer.push(() => listener.call(thisArgs, i));\n        } else {\n          listener.call(thisArgs, i);\n        }\n      }, undefined, disposables);\n    };\n  }\n  bufferEvents(fn) {\n    const buffer = [];\n    this.buffers.push(buffer);\n    const r = fn();\n    this.buffers.pop();\n    buffer.forEach(flush => flush());\n    return r;\n  }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n  constructor() {\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onFirstListenerDidAdd: () => {\n        this.listening = true;\n        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n      },\n      onLastListenerRemove: () => {\n        this.listening = false;\n        this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n  set input(event) {\n    this.inputEvent = event;\n    if (this.listening) {\n      this.inputEventListener.dispose();\n      this.inputEventListener = event(this.emitter.fire, this.emitter);\n    }\n  }\n  dispose() {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  }\n}","map":{"version":3,"names":["onUnexpectedError","combinedDisposable","Disposable","DisposableStore","SafeDisposable","toDisposable","LinkedList","StopWatch","_enableDisposeWithListenerWarning","_enableSnapshotPotentialLeakWarning","Event","None","_addLeakageTraceLogic","options","onListenerDidAdd","origListenerDidAdd","stack","Stacktrace","create","count","console","warn","print","once","event","listener","thisArgs","disposables","didFire","result","undefined","e","dispose","call","map","disposable","snapshot","i","forEach","each","filter","signal","any","events","reduce","merge","initial","output","onFirstListenerAdd","emitter","fire","onLastListenerRemove","Emitter","add","debounce","delay","leading","leakWarningThreshold","subscription","handle","numDebouncedCalls","cur","clearTimeout","setTimeout","_output","latch","equals","a","b","firstCall","cache","value","shouldEmit","split","isT","buffer","flushAfterTimeout","_buffer","slice","push","flush","onFirstListenerDidAdd","ChainableEvent","constructor","fn","on","chain","fromNodeEventEmitter","eventName","id","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","runAndSubscribe","handler","runAndSubscribeWithStore","store","run","EmitterObserver","obs","_counter","_hasChanged","addObserver","removeObserver","beginUpdate","_observable","handleChange","_change","endUpdate","get","fromObservable","observer","EventProfiling","name","_listenerCount","_invocationCount","_elapsedOverall","_name","_idPool","start","listenerCount","_stopWatch","stop","elapsed","info","toFixed","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","Math","random","toString","_warnCountdown","_stacks","clear","check","threshold","Map","set","topStack","topCount","_a","Error","join","Listener","callback","callbackThis","invoke","_b","_disposed","_options","_leakageMon","_perfMon","_profName","_deliveryQueue","deliveryQueue","_c","_d","_listeners","listeners","Array","from","queueMicrotask","isset","unset","_event","firstListener","isEmpty","removeMonitor","size","hasListeners","isArray","PrivateEventDeliveryQueue","deliver","EventDeliveryQueue","_queue","EventDeliveryQueueElement","newQueue","element","shift","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","pause","resume","DebounceEmitter","_delay","_handle","EventBufferer","buffers","wrapEvent","length","bufferEvents","r","pop","Relay","listening","inputEvent","inputEventListener","input"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/base/common/event.js"],"sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { combinedDisposable, Disposable, DisposableStore, SafeDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onListenerDidAdd: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onListenerDidAdd = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which only fires once.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onFirstListenerAdd() {\n                listener = event(emitter.fire, emitter);\n            },\n            onLastListenerRemove() {\n                listener === null || listener === void 0 ? void 0 : listener.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        const options = {\n            leakWarningThreshold,\n            onFirstListenerAdd() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    clearTimeout(handle);\n                    handle = setTimeout(() => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    }, delay);\n                });\n            },\n            onLastListenerRemove() {\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onFirstListenerDidAdd() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onLastListenerRemove() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n            this.disposables = new DisposableStore();\n        }\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn, this.disposables));\n        }\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn, this.disposables));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn, this.disposables));\n        }\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));\n        }\n        latch() {\n            return new ChainableEvent(latch(this.event, undefined, this.disposables));\n        }\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold, this.disposables));\n        }\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n        dispose() {\n            this.disposables.dispose();\n        }\n    }\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    function runAndSubscribe(event, handler) {\n        handler(undefined);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    function runAndSubscribeWithStore(event, handler) {\n        let store = null;\n        function run(e) {\n            store === null || store === void 0 ? void 0 : store.dispose();\n            store = new DisposableStore();\n            handler(e, store);\n        }\n        run(undefined);\n        const disposable = event(e => run(e));\n        return toDisposable(() => {\n            disposable.dispose();\n            store === null || store === void 0 ? void 0 : store.dispose();\n        });\n    }\n    Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n    class EmitterObserver {\n        constructor(obs, store) {\n            this.obs = obs;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onFirstListenerAdd: () => {\n                    obs.addObserver(this);\n                },\n                onLastListenerRemove: () => {\n                    obs.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // console.assert(_observable === this.obs);\n            this._counter++;\n        }\n        handleChange(_observable, _change) {\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            if (--this._counter === 0) {\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this.obs.get());\n                }\n            }\n        }\n    }\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n})(Event || (Event = {}));\nclass EventProfiling {\n    constructor(name) {\n        this._listenerCount = 0;\n        this._invocationCount = 0;\n        this._elapsedOverall = 0;\n        this._name = `${name}_${EventProfiling._idPool++}`;\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch(true);\n        this._listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this._elapsedOverall += elapsed;\n            this._invocationCount += 1;\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.customThreshold = customThreshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        if (this._stacks) {\n            this._stacks.clear();\n        }\n    }\n    check(stack, listenerCount) {\n        let threshold = _globalLeakWarningThreshold;\n        if (typeof this.customThreshold === 'number') {\n            threshold = this.customThreshold;\n        }\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n}\nclass Stacktrace {\n    constructor(value) {\n        this.value = value;\n    }\n    static create() {\n        var _a;\n        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\nclass Listener {\n    constructor(callback, callbackThis, stack) {\n        this.callback = callback;\n        this.callbackThis = callbackThis;\n        this.stack = stack;\n        this.subscription = new SafeDisposable();\n    }\n    invoke(e) {\n        this.callback.call(this.callbackThis, e);\n    }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a, _b;\n        this._disposed = false;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = (_b = this._options) === null || _b === void 0 ? void 0 : _b.deliveryQueue;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = Array.from(this._listeners);\n                    queueMicrotask(() => {\n                        var _a;\n                        for (const listener of listeners) {\n                            if (listener.subscription.isset()) {\n                                listener.subscription.unset();\n                                (_a = listener.stack) === null || _a === void 0 ? void 0 : _a.print();\n                            }\n                        }\n                    });\n                }\n                this._listeners.clear();\n            }\n            (_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.clear(this);\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 ? void 0 : _c.call(_b);\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (callback, thisArgs, disposables) => {\n                var _a, _b, _c;\n                if (!this._listeners) {\n                    this._listeners = new LinkedList();\n                }\n                const firstListener = this._listeners.isEmpty();\n                if (firstListener && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onFirstListenerAdd)) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                let removeMonitor;\n                let stack;\n                if (this._leakageMon && this._listeners.size >= 30) {\n                    // check and record this emitter for potential leakage\n                    stack = Stacktrace.create();\n                    removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);\n                }\n                if (_enableDisposeWithListenerWarning) {\n                    stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n                }\n                const listener = new Listener(callback, thisArgs, stack);\n                const removeListener = this._listeners.push(listener);\n                if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) {\n                    this._options.onFirstListenerDidAdd(this);\n                }\n                if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) {\n                    this._options.onListenerDidAdd(this, callback, thisArgs);\n                }\n                const result = listener.subscription.set(() => {\n                    removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n                    if (!this._disposed) {\n                        removeListener();\n                        if (this._options && this._options.onLastListenerRemove) {\n                            const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                            if (!hasListeners) {\n                                this._options.onLastListenerRemove(this);\n                            }\n                        }\n                    }\n                });\n                if (disposables instanceof DisposableStore) {\n                    disposables.add(result);\n                }\n                else if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b;\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = new PrivateEventDeliveryQueue();\n            }\n            for (const listener of this._listeners) {\n                this._deliveryQueue.push(this, listener, event);\n            }\n            // start/stop performance insight collection\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n            this._deliveryQueue.deliver();\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n    }\n}\nexport class EventDeliveryQueue {\n    constructor() {\n        this._queue = new LinkedList();\n    }\n    get size() {\n        return this._queue.size;\n    }\n    push(emitter, listener, event) {\n        this._queue.push(new EventDeliveryQueueElement(emitter, listener, event));\n    }\n    clear(emitter) {\n        const newQueue = new LinkedList();\n        for (const element of this._queue) {\n            if (element.emitter !== emitter) {\n                newQueue.push(element);\n            }\n        }\n        this._queue = newQueue;\n    }\n    deliver() {\n        while (this._queue.size > 0) {\n            const element = this._queue.shift();\n            try {\n                element.listener.invoke(element.event);\n            }\n            catch (e) {\n                onUnexpectedError(e);\n            }\n        }\n    }\n}\n/**\n * An `EventDeliveryQueue` that is guaranteed to be used by a single `Emitter`.\n */\nclass PrivateEventDeliveryQueue extends EventDeliveryQueue {\n    clear(emitter) {\n        // Here we can just clear the entire linked list because\n        // all elements are guaranteed to belong to this emitter\n        this._queue.clear();\n    }\n}\nclass EventDeliveryQueueElement {\n    constructor(emitter, listener, event) {\n        this.emitter = emitter;\n        this.listener = listener;\n        this.event = event;\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                const events = Array.from(this._eventQueue);\n                this._eventQueue.clear();\n                super.fire(this._mergeFn(events));\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._listeners) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onFirstListenerDidAdd: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onLastListenerRemove: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}