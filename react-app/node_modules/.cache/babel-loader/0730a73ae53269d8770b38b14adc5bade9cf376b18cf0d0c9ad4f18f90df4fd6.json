{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel.js';\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground, minimapForegroundOpacity } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { once } from '../../../../base/common/functional.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n  constructor(configuration, theme, tokensColorTracker) {\n    const options = configuration.options;\n    const pixelRatio = options.get(131 /* EditorOption.pixelRatio */);\n    const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n    const minimapLayout = layoutInfo.minimap;\n    const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n    const minimapOpts = options.get(67 /* EditorOption.minimap */);\n    this.renderMinimap = minimapLayout.renderMinimap;\n    this.size = minimapOpts.size;\n    this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n    this.scrollBeyondLastLine = options.get(96 /* EditorOption.scrollBeyondLastLine */);\n    this.showSlider = minimapOpts.showSlider;\n    this.autohide = minimapOpts.autohide;\n    this.pixelRatio = pixelRatio;\n    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this.lineHeight = options.get(61 /* EditorOption.lineHeight */);\n    this.minimapLeft = minimapLayout.minimapLeft;\n    this.minimapWidth = minimapLayout.minimapWidth;\n    this.minimapHeight = layoutInfo.height;\n    this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n    this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n    this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n    this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n    this.isSampling = minimapLayout.minimapIsSampling;\n    this.editorHeight = layoutInfo.height;\n    this.fontScale = minimapLayout.minimapScale;\n    this.minimapLineHeight = minimapLayout.minimapLineHeight;\n    this.minimapCharWidth = 1 /* Constants.BASE_CHAR_WIDTH */ * this.fontScale;\n    this.charRenderer = once(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n    this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* ColorId.DefaultBackground */);\n    this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n    this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n  }\n  static _getMinimapBackground(theme, defaultBackgroundColor) {\n    const themeColor = theme.getColor(minimapBackground);\n    if (themeColor) {\n      return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n    }\n    return defaultBackgroundColor;\n  }\n  static _getMinimapForegroundOpacity(theme) {\n    const themeColor = theme.getColor(minimapForegroundOpacity);\n    if (themeColor) {\n      return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n    }\n    return 255;\n  }\n  equals(other) {\n    return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.showSlider === other.showSlider && this.autohide === other.autohide && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor) && this.foregroundAlpha === other.foregroundAlpha;\n  }\n}\nclass MinimapLayout {\n  constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\n    this.scrollTop = scrollTop;\n    this.scrollHeight = scrollHeight;\n    this.sliderNeeded = sliderNeeded;\n    this._computedSliderRatio = computedSliderRatio;\n    this.sliderTop = sliderTop;\n    this.sliderHeight = sliderHeight;\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n  /**\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n   */\n  getDesiredScrollTopFromDelta(delta) {\n    return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n  }\n  getDesiredScrollTopFromTouchLocation(pageY) {\n    return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n  }\n  static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n    const pixelRatio = options.pixelRatio;\n    const minimapLineHeight = options.minimapLineHeight;\n    const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n    const lineHeight = options.lineHeight;\n    if (options.minimapHeightIsEditorHeight) {\n      const logicalScrollHeight = realLineCount * options.lineHeight + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0);\n      const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n      const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n      // The slider can move from 0 to `maxMinimapSliderTop`\n      // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n      const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n      const sliderTop = scrollTop * computedSliderRatio;\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\n    }\n    // The visible line count in a viewport can change due to a number of reasons:\n    //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n    //    e.g. for a line height of 20, and a viewport height of 600\n    //          * scrollTop = 0  => visible lines are [1, 30]\n    //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n    //          * scrollTop = 20 => visible lines are [2, 31]\n    //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n    //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n    // We must first establish a desirable slider height.\n    let sliderHeight;\n    if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n      // case b) from above: there are whitespace gaps in the viewport.\n      // In this case, the height of the slider directly reflects the visible line count.\n      const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n      sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n    } else {\n      // The slider has a stable height\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n    }\n    let maxMinimapSliderTop;\n    if (options.scrollBeyondLastLine) {\n      // The minimap slider, when dragged all the way down, will contain the last line at its top\n      maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\n    } else {\n      // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n      maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\n    }\n    maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n    // The slider can move from 0 to `maxMinimapSliderTop`\n    // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n    const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n    const sliderTop = scrollTop * computedSliderRatio;\n    let extraLinesAtTheBottom = 0;\n    if (options.scrollBeyondLastLine) {\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      extraLinesAtTheBottom = expectedViewportLineCount - 1;\n    }\n    if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\n      // All lines fit in the minimap\n      const startLineNumber = 1;\n      const endLineNumber = lineCount;\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n    } else {\n      let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n      // Avoid flickering caused by a partial viewport start line\n      // by being consistent w.r.t. the previous layout decision\n      if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n        if (previousLayout.scrollTop > scrollTop) {\n          // Scrolling up => never increase `startLineNumber`\n          startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n        }\n        if (previousLayout.scrollTop < scrollTop) {\n          // Scrolling down => never decrease `startLineNumber`\n          startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n        }\n      }\n      const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\n      const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n      const sliderTopAligned = (viewportStartLineNumber - startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\n      return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, startLineNumber, endLineNumber);\n    }\n  }\n}\nclass MinimapLine {\n  constructor(dy) {\n    this.dy = dy;\n  }\n  onContentChanged() {\n    this.dy = -1;\n  }\n  onTokensChanged() {\n    this.dy = -1;\n  }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n  constructor(renderedLayout, imageData, lines) {\n    this.renderedLayout = renderedLayout;\n    this._imageData = imageData;\n    this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n    this._renderedLines._set(renderedLayout.startLineNumber, lines);\n  }\n  /**\n   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n   */\n  linesEquals(layout) {\n    if (!this.scrollEquals(layout)) {\n      return false;\n    }\n    const tmp = this._renderedLines._get();\n    const lines = tmp.lines;\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].dy === -1) {\n        // This line is invalid\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Check if the current RenderData matches the new layout's scroll position\n   */\n  scrollEquals(layout) {\n    return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;\n  }\n  _get() {\n    const tmp = this._renderedLines._get();\n    return {\n      imageData: this._imageData,\n      rendLineNumberStart: tmp.rendLineNumberStart,\n      lines: tmp.lines\n    };\n  }\n  onLinesChanged(changeFromLineNumber, changeCount) {\n    return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n  }\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n  }\n  onTokensChanged(ranges) {\n    return this._renderedLines.onTokensChanged(ranges);\n  }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n  constructor(ctx, WIDTH, HEIGHT, background) {\n    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n    this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];\n    this._lastUsedBuffer = 0;\n  }\n  getBuffer() {\n    // rotate buffers\n    this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n    const result = this._buffers[this._lastUsedBuffer];\n    // fill with background color\n    result.data.set(this._backgroundFillData);\n    return result;\n  }\n  static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n    const backgroundR = background.r;\n    const backgroundG = background.g;\n    const backgroundB = background.b;\n    const backgroundA = background.a;\n    const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n    let offset = 0;\n    for (let i = 0; i < HEIGHT; i++) {\n      for (let j = 0; j < WIDTH; j++) {\n        result[offset] = backgroundR;\n        result[offset + 1] = backgroundG;\n        result[offset + 2] = backgroundB;\n        result[offset + 3] = backgroundA;\n        offset += 4;\n      }\n    }\n    return result;\n  }\n}\nclass MinimapSamplingState {\n  constructor(samplingRatio, minimapLines) {\n    this.samplingRatio = samplingRatio;\n    this.minimapLines = minimapLines;\n  }\n  static compute(options, viewLineCount, oldSamplingState) {\n    if (options.renderMinimap === 0 /* RenderMinimap.None */ || !options.isSampling) {\n      return [null, []];\n    }\n    // ratio is intentionally not part of the layout to avoid the layout changing all the time\n    // so we need to recompute it again...\n    const pixelRatio = options.pixelRatio;\n    const lineHeight = options.lineHeight;\n    const scrollBeyondLastLine = options.scrollBeyondLastLine;\n    const {\n      minimapLineCount\n    } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n      viewLineCount: viewLineCount,\n      scrollBeyondLastLine: scrollBeyondLastLine,\n      height: options.editorHeight,\n      lineHeight: lineHeight,\n      pixelRatio: pixelRatio\n    });\n    const ratio = viewLineCount / minimapLineCount;\n    const halfRatio = ratio / 2;\n    if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n      const result = [];\n      result[0] = 1;\n      if (minimapLineCount > 1) {\n        for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n          result[i] = Math.round(i * ratio + halfRatio);\n        }\n        result[minimapLineCount - 1] = viewLineCount;\n      }\n      return [new MinimapSamplingState(ratio, result), []];\n    }\n    const oldMinimapLines = oldSamplingState.minimapLines;\n    const oldLength = oldMinimapLines.length;\n    const result = [];\n    let oldIndex = 0;\n    let oldDeltaLineCount = 0;\n    let minViewLineNumber = 1;\n    const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n    let events = [];\n    let lastEvent = null;\n    for (let i = 0; i < minimapLineCount; i++) {\n      const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n      const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n      while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n            lastEvent.deleteToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'deleted',\n              _oldIndex: oldIndex,\n              deleteFromLineNumber: oldMinimapLineNumber,\n              deleteToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount--;\n        }\n        oldIndex++;\n      }\n      let selectedViewLineNumber;\n      if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n        // reuse the old sampled line\n        selectedViewLineNumber = oldMinimapLines[oldIndex];\n        oldIndex++;\n      } else {\n        if (i === 0) {\n          selectedViewLineNumber = 1;\n        } else if (i + 1 === minimapLineCount) {\n          selectedViewLineNumber = viewLineCount;\n        } else {\n          selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n            lastEvent.insertToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'inserted',\n              _i: i,\n              insertFromLineNumber: oldMinimapLineNumber,\n              insertToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount++;\n        }\n      }\n      result[i] = selectedViewLineNumber;\n      minViewLineNumber = selectedViewLineNumber;\n    }\n    if (events.length < MAX_EVENT_COUNT) {\n      while (oldIndex < oldLength) {\n        const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n        if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n          lastEvent.deleteToLineNumber++;\n        } else {\n          lastEvent = {\n            type: 'deleted',\n            _oldIndex: oldIndex,\n            deleteFromLineNumber: oldMinimapLineNumber,\n            deleteToLineNumber: oldMinimapLineNumber\n          };\n          events.push(lastEvent);\n        }\n        oldDeltaLineCount--;\n        oldIndex++;\n      }\n    } else {\n      // too many events, just give up\n      events = [{\n        type: 'flush'\n      }];\n    }\n    return [new MinimapSamplingState(ratio, result), events];\n  }\n  modelLineToMinimapLine(lineNumber) {\n    return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n  }\n  /**\n   * Will return null if the model line ranges are not intersecting with a sampled model line.\n   */\n  modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n    let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n    while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n      fromLineIndex--;\n    }\n    let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n    while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n      toLineIndex++;\n    }\n    if (fromLineIndex === toLineIndex) {\n      const sampledLineNumber = this.minimapLines[fromLineIndex];\n      if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n        // This line is not part of the sampled lines ==> nothing to do\n        return null;\n      }\n    }\n    return [fromLineIndex + 1, toLineIndex + 1];\n  }\n  /**\n   * Will always return a range, even if it is not intersecting with a sampled model line.\n   */\n  decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n    let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n    let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n    if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n      if (minimapLineEnd === this.minimapLines.length) {\n        if (minimapLineStart > 1) {\n          minimapLineStart--;\n        }\n      } else {\n        minimapLineEnd++;\n      }\n    }\n    return [minimapLineStart, minimapLineEnd];\n  }\n  onLinesDeleted(e) {\n    // have the mapping be sticky\n    const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    let changeStartIndex = this.minimapLines.length;\n    let changeEndIndex = 0;\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n      if (this.minimapLines[i] <= e.toLineNumber) {\n        // this line got deleted => move to previous available\n        this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n        changeStartIndex = Math.min(changeStartIndex, i);\n        changeEndIndex = Math.max(changeEndIndex, i);\n      } else {\n        this.minimapLines[i] -= deletedLineCount;\n      }\n    }\n    return [changeStartIndex, changeEndIndex];\n  }\n  onLinesInserted(e) {\n    // have the mapping be sticky\n    const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n      this.minimapLines[i] += insertedLineCount;\n    }\n  }\n}\nexport class Minimap extends ViewPart {\n  constructor(context) {\n    super(context);\n    this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n    this._selections = [];\n    this._minimapSelections = null;\n    this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    const [samplingState] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n    this._samplingState = samplingState;\n    this._shouldCheckSampling = false;\n    this._actual = new InnerMinimap(context.theme, this);\n  }\n  dispose() {\n    this._actual.dispose();\n    super.dispose();\n  }\n  getDomNode() {\n    return this._actual.getDomNode();\n  }\n  _onOptionsMaybeChanged() {\n    const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    if (this.options.equals(opts)) {\n      return false;\n    }\n    this.options = opts;\n    this._recreateLineSampling();\n    this._actual.onDidChangeOptions();\n    return true;\n  }\n  // ---- begin view event handlers\n  onConfigurationChanged(e) {\n    return this._onOptionsMaybeChanged();\n  }\n  onCursorStateChanged(e) {\n    this._selections = e.selections;\n    this._minimapSelections = null;\n    return this._actual.onSelectionChanged();\n  }\n  onDecorationsChanged(e) {\n    if (e.affectsMinimap) {\n      return this._actual.onDecorationsChanged();\n    }\n    return false;\n  }\n  onFlushed(e) {\n    if (this._samplingState) {\n      this._shouldCheckSampling = true;\n    }\n    return this._actual.onFlushed();\n  }\n  onLinesChanged(e) {\n    if (this._samplingState) {\n      const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n      if (minimapLineRange) {\n        return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onLinesChanged(e.fromLineNumber, e.count);\n    }\n  }\n  onLinesDeleted(e) {\n    if (this._samplingState) {\n      const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n      if (changeStartIndex <= changeEndIndex) {\n        this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n      }\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onLinesInserted(e) {\n    if (this._samplingState) {\n      this._samplingState.onLinesInserted(e);\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onScrollChanged(e) {\n    return this._actual.onScrollChanged();\n  }\n  onThemeChanged(e) {\n    this._actual.onThemeChanged();\n    this._onOptionsMaybeChanged();\n    return true;\n  }\n  onTokensChanged(e) {\n    if (this._samplingState) {\n      const ranges = [];\n      for (const range of e.ranges) {\n        const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n        if (minimapLineRange) {\n          ranges.push({\n            fromLineNumber: minimapLineRange[0],\n            toLineNumber: minimapLineRange[1]\n          });\n        }\n      }\n      if (ranges.length) {\n        return this._actual.onTokensChanged(ranges);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onTokensChanged(e.ranges);\n    }\n  }\n  onTokensColorsChanged(e) {\n    this._onOptionsMaybeChanged();\n    return this._actual.onTokensColorsChanged();\n  }\n  onZonesChanged(e) {\n    return this._actual.onZonesChanged();\n  }\n  // --- end event handlers\n  prepareRender(ctx) {\n    if (this._shouldCheckSampling) {\n      this._shouldCheckSampling = false;\n      this._recreateLineSampling();\n    }\n  }\n  render(ctx) {\n    let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n    let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n    if (this._samplingState) {\n      viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n      viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n    }\n    const minimapCtx = {\n      viewportContainsWhitespaceGaps: ctx.viewportData.whitespaceViewportData.length > 0,\n      scrollWidth: ctx.scrollWidth,\n      scrollHeight: ctx.scrollHeight,\n      viewportStartLineNumber: viewportStartLineNumber,\n      viewportEndLineNumber: viewportEndLineNumber,\n      viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n      scrollTop: ctx.scrollTop,\n      scrollLeft: ctx.scrollLeft,\n      viewportWidth: ctx.viewportWidth,\n      viewportHeight: ctx.viewportHeight\n    };\n    this._actual.render(minimapCtx);\n  }\n  //#region IMinimapModel\n  _recreateLineSampling() {\n    this._minimapSelections = null;\n    const wasSampling = Boolean(this._samplingState);\n    const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n    this._samplingState = samplingState;\n    if (wasSampling && this._samplingState) {\n      // was sampling, is sampling\n      for (const event of events) {\n        switch (event.type) {\n          case 'deleted':\n            this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n            break;\n          case 'inserted':\n            this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n            break;\n          case 'flush':\n            this._actual.onFlushed();\n            break;\n        }\n      }\n    }\n  }\n  getLineCount() {\n    if (this._samplingState) {\n      return this._samplingState.minimapLines.length;\n    }\n    return this._context.viewModel.getLineCount();\n  }\n  getRealLineCount() {\n    return this._context.viewModel.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    if (this._samplingState) {\n      return this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n    return this._context.viewModel.getLineContent(lineNumber);\n  }\n  getLineMaxColumn(lineNumber) {\n    if (this._samplingState) {\n      return this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n    return this._context.viewModel.getLineMaxColumn(lineNumber);\n  }\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    if (this._samplingState) {\n      const result = [];\n      for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n        if (needed[lineIndex]) {\n          result[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n        } else {\n          result[lineIndex] = null;\n        }\n      }\n      return result;\n    }\n    return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n  }\n  getSelections() {\n    if (this._minimapSelections === null) {\n      if (this._samplingState) {\n        this._minimapSelections = [];\n        for (const selection of this._selections) {\n          const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n          this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n        }\n      } else {\n        this._minimapSelections = this._selections;\n      }\n    }\n    return this._minimapSelections;\n  }\n  getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n    let visibleRange;\n    if (this._samplingState) {\n      const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n      const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n      visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n    } else {\n      visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n    }\n    const decorations = this._context.viewModel.getDecorationsInViewport(visibleRange);\n    if (this._samplingState) {\n      const result = [];\n      for (const decoration of decorations) {\n        if (!decoration.options.minimap) {\n          continue;\n        }\n        const range = decoration.range;\n        const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n        const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n        result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n      }\n      return result;\n    }\n    return decorations;\n  }\n  getOptions() {\n    return this._context.viewModel.model.getOptions();\n  }\n  revealLineNumber(lineNumber) {\n    if (this._samplingState) {\n      lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n    }\n    this._context.viewModel.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* viewEvents.VerticalRevealType.Center */, 0 /* ScrollType.Smooth */);\n  }\n\n  setScrollTop(scrollTop) {\n    this._context.viewModel.viewLayout.setScrollPosition({\n      scrollTop: scrollTop\n    }, 1 /* ScrollType.Immediate */);\n  }\n}\n\nclass InnerMinimap extends Disposable {\n  constructor(theme, model) {\n    super();\n    this._renderDecorations = false;\n    this._gestureInProgress = false;\n    this._theme = theme;\n    this._model = model;\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this._domNode, 8 /* PartFingerprint.Minimap */);\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    this._domNode.setPosition('absolute');\n    this._domNode.setAttribute('role', 'presentation');\n    this._domNode.setAttribute('aria-hidden', 'true');\n    this._shadow = createFastDomNode(document.createElement('div'));\n    this._shadow.setClassName('minimap-shadow-hidden');\n    this._domNode.appendChild(this._shadow);\n    this._canvas = createFastDomNode(document.createElement('canvas'));\n    this._canvas.setPosition('absolute');\n    this._canvas.setLeft(0);\n    this._domNode.appendChild(this._canvas);\n    this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n    this._decorationsCanvas.setPosition('absolute');\n    this._decorationsCanvas.setClassName('minimap-decorations-layer');\n    this._decorationsCanvas.setLeft(0);\n    this._domNode.appendChild(this._decorationsCanvas);\n    this._slider = createFastDomNode(document.createElement('div'));\n    this._slider.setPosition('absolute');\n    this._slider.setClassName('minimap-slider');\n    this._slider.setLayerHinting(true);\n    this._slider.setContain('strict');\n    this._domNode.appendChild(this._slider);\n    this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n    this._sliderHorizontal.setPosition('absolute');\n    this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n    this._slider.appendChild(this._sliderHorizontal);\n    this._applyLayout();\n    this._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, e => {\n      e.preventDefault();\n      const renderMinimap = this._model.options.renderMinimap;\n      if (renderMinimap === 0 /* RenderMinimap.None */) {\n        return;\n      }\n      if (!this._lastRenderData) {\n        return;\n      }\n      if (this._model.options.size !== 'proportional') {\n        if (e.button === 0 && this._lastRenderData) {\n          // pretend the click occurred in the center of the slider\n          const position = dom.getDomNodePagePosition(this._slider.domNode);\n          const initialPosY = position.top + position.height / 2;\n          this._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n        }\n        return;\n      }\n      const minimapLineHeight = this._model.options.minimapLineHeight;\n      const internalOffsetY = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * e.offsetY;\n      const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n      let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;\n      lineNumber = Math.min(lineNumber, this._model.getLineCount());\n      this._model.revealLineNumber(lineNumber);\n    });\n    this._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n    this._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (e.button === 0 && this._lastRenderData) {\n        this._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n      }\n    });\n    this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n    this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this._lastRenderData) {\n        this._slider.toggleClassName('active', true);\n        this._gestureInProgress = true;\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this._lastRenderData && this._gestureInProgress) {\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      this._gestureInProgress = false;\n      this._slider.toggleClassName('active', false);\n    });\n  }\n  _startSliderDragging(e, initialPosY, initialSliderState) {\n    if (!e.target || !(e.target instanceof Element)) {\n      return;\n    }\n    const initialPosX = e.pageX;\n    this._slider.toggleClassName('active', true);\n    const handlePointerMove = (posy, posx) => {\n      const pointerOrthogonalDelta = Math.abs(posx - initialPosX);\n      if (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n        // The pointer has wondered away from the scrollbar => reset dragging\n        this._model.setScrollTop(initialSliderState.scrollTop);\n        return;\n      }\n      const pointerDelta = posy - initialPosY;\n      this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n    };\n    if (e.pageY !== initialPosY) {\n      handlePointerMove(e.pageY, initialPosX);\n    }\n    this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX), () => {\n      this._slider.toggleClassName('active', false);\n    });\n  }\n  scrollDueToTouchEvent(touch) {\n    const startY = this._domNode.domNode.getBoundingClientRect().top;\n    const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n    this._model.setScrollTop(scrollTop);\n  }\n  dispose() {\n    this._pointerDownListener.dispose();\n    this._sliderPointerMoveMonitor.dispose();\n    this._sliderPointerDownListener.dispose();\n    this._gestureDisposable.dispose();\n    this._sliderTouchStartListener.dispose();\n    this._sliderTouchMoveListener.dispose();\n    this._sliderTouchEndListener.dispose();\n    super.dispose();\n  }\n  _getMinimapDomNodeClassName() {\n    const class_ = ['minimap'];\n    if (this._model.options.showSlider === 'always') {\n      class_.push('slider-always');\n    } else {\n      class_.push('slider-mouseover');\n    }\n    if (this._model.options.autohide) {\n      class_.push('autohide');\n    }\n    return class_.join(' ');\n  }\n  getDomNode() {\n    return this._domNode;\n  }\n  _applyLayout() {\n    this._domNode.setLeft(this._model.options.minimapLeft);\n    this._domNode.setWidth(this._model.options.minimapWidth);\n    this._domNode.setHeight(this._model.options.minimapHeight);\n    this._shadow.setHeight(this._model.options.minimapHeight);\n    this._canvas.setWidth(this._model.options.canvasOuterWidth);\n    this._canvas.setHeight(this._model.options.canvasOuterHeight);\n    this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n    this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n    this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n    this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n    this._slider.setWidth(this._model.options.minimapWidth);\n  }\n  _getBuffer() {\n    if (!this._buffers) {\n      if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n        this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n      }\n    }\n    return this._buffers ? this._buffers.getBuffer() : null;\n  }\n  // ---- begin view event handlers\n  onDidChangeOptions() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._applyLayout();\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n  }\n  onSelectionChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onDecorationsChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onFlushed() {\n    this._lastRenderData = null;\n    return true;\n  }\n  onLinesChanged(changeFromLineNumber, changeCount) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n    }\n    return false;\n  }\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    var _a;\n    (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    return true;\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    var _a;\n    (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    return true;\n  }\n  onScrollChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onThemeChanged() {\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._renderDecorations = true;\n    return true;\n  }\n  onTokensChanged(ranges) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onTokensChanged(ranges);\n    }\n    return false;\n  }\n  onTokensColorsChanged() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    return true;\n  }\n  onZonesChanged() {\n    this._lastRenderData = null;\n    return true;\n  }\n  // --- end event handlers\n  render(renderingCtx) {\n    const renderMinimap = this._model.options.renderMinimap;\n    if (renderMinimap === 0 /* RenderMinimap.None */) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n      this._sliderHorizontal.setWidth(0);\n      this._sliderHorizontal.setHeight(0);\n      return;\n    }\n    if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n    } else {\n      this._shadow.setClassName('minimap-shadow-visible');\n    }\n    const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n    this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n    this._slider.setTop(layout.sliderTop);\n    this._slider.setHeight(layout.sliderHeight);\n    // Compute horizontal slider coordinates\n    this._sliderHorizontal.setLeft(0);\n    this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n    this._sliderHorizontal.setTop(0);\n    this._sliderHorizontal.setHeight(layout.sliderHeight);\n    this.renderDecorations(layout);\n    this._lastRenderData = this.renderLines(layout);\n  }\n  renderDecorations(layout) {\n    if (this._renderDecorations) {\n      this._renderDecorations = false;\n      const selections = this._model.getSelections();\n      selections.sort(Range.compareRangesUsingStarts);\n      const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n      decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n      const {\n        canvasInnerWidth,\n        canvasInnerHeight\n      } = this._model.options;\n      const lineHeight = this._model.options.minimapLineHeight;\n      const characterWidth = this._model.options.minimapCharWidth;\n      const tabSize = this._model.getOptions().tabSize;\n      const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n      canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n      // We first need to render line highlights and then render decorations on top of those.\n      // But we need to pick a single color for each line, and use that as a line highlight.\n      // This needs to be the color of the decoration with the highest `zIndex`, but priority\n      // is given to the selection.\n      const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n      this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, lineHeight);\n      this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, lineHeight);\n      const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n      this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n      this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n    }\n  }\n  _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, lineHeight) {\n    if (!this._selectionColor || this._selectionColor.isTransparent()) {\n      return;\n    }\n    canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n    let y1 = 0;\n    let y2 = 0;\n    for (const selection of selections) {\n      const startLineNumber = Math.max(layout.startLineNumber, selection.startLineNumber);\n      const endLineNumber = Math.min(layout.endLineNumber, selection.endLineNumber);\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        highlightedLines.set(line, true);\n      }\n      const yy1 = (startLineNumber - layout.startLineNumber) * lineHeight;\n      const yy2 = (endLineNumber - layout.startLineNumber) * lineHeight + lineHeight;\n      if (y2 >= yy1) {\n        // merge into previous\n        y2 = yy2;\n      } else {\n        if (y2 > y1) {\n          // flush\n          canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n        y1 = yy1;\n        y2 = yy2;\n      }\n    }\n    if (y2 > y1) {\n      // flush\n      canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n    }\n  }\n  _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, lineHeight) {\n    const highlightColors = new Map();\n    // Loop backwards to hit first decorations with higher `zIndex`\n    for (let i = decorations.length - 1; i >= 0; i--) {\n      const decoration = decorations[i];\n      const minimapOptions = decoration.options.minimap;\n      if (!minimapOptions || minimapOptions.position !== MinimapPosition.Inline) {\n        continue;\n      }\n      const startLineNumber = Math.max(layout.startLineNumber, decoration.range.startLineNumber);\n      const endLineNumber = Math.min(layout.endLineNumber, decoration.range.endLineNumber);\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const decorationColor = minimapOptions.getColor(this._theme.value);\n      if (!decorationColor || decorationColor.isTransparent()) {\n        continue;\n      }\n      let highlightColor = highlightColors.get(decorationColor.toString());\n      if (!highlightColor) {\n        highlightColor = decorationColor.transparent(0.5).toString();\n        highlightColors.set(decorationColor.toString(), highlightColor);\n      }\n      canvasContext.fillStyle = highlightColor;\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        if (highlightedLines.has(line)) {\n          continue;\n        }\n        highlightedLines.set(line, true);\n        const y = (startLineNumber - layout.startLineNumber) * lineHeight;\n        canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, lineHeight);\n      }\n    }\n  }\n  _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n    if (!this._selectionColor || this._selectionColor.isTransparent()) {\n      return;\n    }\n    for (const selection of selections) {\n      const startLineNumber = Math.max(layout.startLineNumber, selection.startLineNumber);\n      const endLineNumber = Math.min(layout.endLineNumber, selection.endLineNumber);\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n      }\n    }\n  }\n  _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n    // Loop forwards to hit first decorations with lower `zIndex`\n    for (const decoration of decorations) {\n      const minimapOptions = decoration.options.minimap;\n      if (!minimapOptions) {\n        continue;\n      }\n      const startLineNumber = Math.max(layout.startLineNumber, decoration.range.startLineNumber);\n      const endLineNumber = Math.min(layout.endLineNumber, decoration.range.endLineNumber);\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n      const decorationColor = minimapOptions.getColor(this._theme.value);\n      if (!decorationColor || decorationColor.isTransparent()) {\n        continue;\n      }\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        switch (minimapOptions.position) {\n          case MinimapPosition.Inline:\n            this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            continue;\n          case MinimapPosition.Gutter:\n            {\n              const y = (line - layout.startLineNumber) * lineHeight;\n              const x = 2;\n              this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\n              continue;\n            }\n        }\n      }\n    }\n  }\n  renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth, canvasInnerWidth) {\n    const y = (lineNumber - layout.startLineNumber) * lineHeight;\n    // Skip rendering the line if it's vertically outside our viewport\n    if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n      return;\n    }\n    const {\n      startLineNumber,\n      endLineNumber\n    } = decorationRange;\n    const startColumn = startLineNumber === lineNumber ? decorationRange.startColumn : 1;\n    const endColumn = endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber);\n    const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n    const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n    this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n  }\n  getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n    if (column === 1) {\n      return MINIMAP_GUTTER_WIDTH;\n    }\n    const minimumXOffset = (column - 1) * charWidth;\n    if (minimumXOffset >= canvasInnerWidth) {\n      // there is no need to look at actual characters,\n      // as this column is certainly after the minimap width\n      return canvasInnerWidth;\n    }\n    // Cache line offset data so that it is only read once per line\n    let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n    if (!lineIndexToXOffset) {\n      const lineData = this._model.getLineContent(lineNumber);\n      lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n      let prevx = MINIMAP_GUTTER_WIDTH;\n      for (let i = 1; i < lineData.length + 1; i++) {\n        const charCode = lineData.charCodeAt(i - 1);\n        const dx = charCode === 9 /* CharCode.Tab */ ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;\n        const x = prevx + dx;\n        if (x >= canvasInnerWidth) {\n          // no need to keep on going, as we've hit the canvas width\n          lineIndexToXOffset[i] = canvasInnerWidth;\n          break;\n        }\n        lineIndexToXOffset[i] = x;\n        prevx = x;\n      }\n      lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n    }\n    if (column - 1 < lineIndexToXOffset.length) {\n      return lineIndexToXOffset[column - 1];\n    }\n    // goes over the canvas width\n    return canvasInnerWidth;\n  }\n  renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n    canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n    canvasContext.fillRect(x, y, width, height);\n  }\n  renderLines(layout) {\n    const startLineNumber = layout.startLineNumber;\n    const endLineNumber = layout.endLineNumber;\n    const minimapLineHeight = this._model.options.minimapLineHeight;\n    // Check if nothing changed w.r.t. lines from last frame\n    if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n      const _lastData = this._lastRenderData._get();\n      // Nice!! Nothing changed from last frame\n      return new RenderData(layout, _lastData.imageData, _lastData.lines);\n    }\n    // Oh well!! We need to repaint some lines...\n    const imageData = this._getBuffer();\n    if (!imageData) {\n      // 0 width or 0 height canvas, nothing to do\n      return null;\n    }\n    // Render untouched lines by using last rendered data.\n    const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n    // Fetch rendering info from view model for rest of lines that need rendering.\n    const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n    const tabSize = this._model.getOptions().tabSize;\n    const defaultBackground = this._model.options.defaultBackgroundColor;\n    const background = this._model.options.backgroundColor;\n    const foregroundAlpha = this._model.options.foregroundAlpha;\n    const tokensColorTracker = this._model.tokensColorTracker;\n    const useLighterFont = tokensColorTracker.backgroundIsLight();\n    const renderMinimap = this._model.options.renderMinimap;\n    const charRenderer = this._model.options.charRenderer();\n    const fontScale = this._model.options.fontScale;\n    const minimapCharWidth = this._model.options.minimapCharWidth;\n    const baseCharHeight = renderMinimap === 1 /* RenderMinimap.Text */ ? 2 /* Constants.BASE_CHAR_HEIGHT */ : 2 /* Constants.BASE_CHAR_HEIGHT */ + 1;\n    const renderMinimapLineHeight = baseCharHeight * fontScale;\n    const innerLinePadding = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0;\n    // Render the rest of lines\n    const backgroundA = background.a / 255;\n    const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n    let dy = 0;\n    const renderedLines = [];\n    for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n      if (needed[lineIndex]) {\n        InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n      }\n      renderedLines[lineIndex] = new MinimapLine(dy);\n      dy += minimapLineHeight;\n    }\n    const dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;\n    const dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;\n    const dirtyHeight = dirtyY2 - dirtyY1;\n    // Finally, paint to the canvas\n    const ctx = this._canvas.domNode.getContext('2d');\n    ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n    // Save rendered data for reuse on next frame if possible\n    return new RenderData(layout, imageData, renderedLines);\n  }\n  static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n    const needed = [];\n    if (!lastRenderData) {\n      for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n        needed[i] = true;\n      }\n      return [-1, -1, needed];\n    }\n    const _lastData = lastRenderData._get();\n    const lastTargetData = _lastData.imageData.data;\n    const lastStartLineNumber = _lastData.rendLineNumberStart;\n    const lastLines = _lastData.lines;\n    const lastLinesLength = lastLines.length;\n    const WIDTH = target.width;\n    const targetData = target.data;\n    const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n    let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n    let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n    let copySourceStart = -1;\n    let copySourceEnd = -1;\n    let copyDestStart = -1;\n    let copyDestEnd = -1;\n    let dest_dy = 0;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - startLineNumber;\n      const lastLineIndex = lineNumber - lastStartLineNumber;\n      const source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;\n      if (source_dy === -1) {\n        needed[lineIndex] = true;\n        dest_dy += minimapLineHeight;\n        continue;\n      }\n      const sourceStart = source_dy * WIDTH * 4;\n      const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n      const destStart = dest_dy * WIDTH * 4;\n      const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n      if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n        // contiguous zone => extend copy request\n        copySourceEnd = sourceEnd;\n        copyDestEnd = destEnd;\n      } else {\n        if (copySourceStart !== -1) {\n          // flush existing copy request\n          targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n          if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n            dirtyPixel1 = copySourceEnd;\n          }\n          if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n            dirtyPixel2 = copySourceStart;\n          }\n        }\n        copySourceStart = sourceStart;\n        copySourceEnd = sourceEnd;\n        copyDestStart = destStart;\n        copyDestEnd = destEnd;\n      }\n      needed[lineIndex] = false;\n      dest_dy += minimapLineHeight;\n    }\n    if (copySourceStart !== -1) {\n      // flush existing copy request\n      targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n      if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n        dirtyPixel1 = copySourceEnd;\n      }\n      if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n        dirtyPixel2 = copySourceStart;\n      }\n    }\n    const dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);\n    const dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);\n    return [dirtyY1, dirtyY2, needed];\n  }\n  static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n    const content = lineData.content;\n    const tokens = lineData.tokens;\n    const maxDx = target.width - charWidth;\n    const force1pxHeight = minimapLineHeight === 1;\n    let dx = MINIMAP_GUTTER_WIDTH;\n    let charIndex = 0;\n    let tabsCharDelta = 0;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n      const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n      const tokenColorId = tokens.getForeground(tokenIndex);\n      const tokenColor = colorTracker.getColor(tokenColorId);\n      for (; charIndex < tokenEndIndex; charIndex++) {\n        if (dx > maxDx) {\n          // hit edge of minimap\n          return;\n        }\n        const charCode = content.charCodeAt(charIndex);\n        if (charCode === 9 /* CharCode.Tab */) {\n          const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n          tabsCharDelta += insertSpacesCount - 1;\n          // No need to render anything since tab is invisible\n          dx += insertSpacesCount * charWidth;\n        } else if (charCode === 32 /* CharCode.Space */) {\n          // No need to render anything since space is invisible\n          dx += charWidth;\n        } else {\n          // Render twice for a full width character\n          const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n          for (let i = 0; i < count; i++) {\n            if (renderMinimap === 2 /* RenderMinimap.Blocks */) {\n              minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n            } else {\n              // RenderMinimap.Text\n              minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n            }\n            dx += charWidth;\n            if (dx > maxDx) {\n              // hit edge of minimap\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n}\nclass ContiguousLineMap {\n  constructor(startLineNumber, endLineNumber, defaultValue) {\n    this._startLineNumber = startLineNumber;\n    this._endLineNumber = endLineNumber;\n    this._defaultValue = defaultValue;\n    this._values = [];\n    for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n      this._values[i] = defaultValue;\n    }\n  }\n  has(lineNumber) {\n    return this.get(lineNumber) !== this._defaultValue;\n  }\n  set(lineNumber, value) {\n    if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n      return;\n    }\n    this._values[lineNumber - this._startLineNumber] = value;\n  }\n  get(lineNumber) {\n    if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n      return this._defaultValue;\n    }\n    return this._values[lineNumber - this._startLineNumber];\n  }\n}\nregisterThemingParticipant((theme, collector) => {\n  const sliderBackground = theme.getColor(minimapSliderBackground);\n  if (sliderBackground) {\n    collector.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${sliderBackground}; }`);\n  }\n  const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\n  if (sliderHoverBackground) {\n    collector.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${sliderHoverBackground}; }`);\n  }\n  const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\n  if (sliderActiveBackground) {\n    collector.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${sliderActiveBackground}; }`);\n  }\n  const shadow = theme.getColor(scrollbarShadow);\n  if (shadow) {\n    collector.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${shadow} -6px 0 6px -6px inset; }`);\n  }\n});","map":{"version":3,"names":["dom","createFastDomNode","GlobalPointerMoveMonitor","Disposable","platform","strings","RenderedLinesCollection","PartFingerprints","ViewPart","MINIMAP_GUTTER_WIDTH","EditorLayoutInfoComputer","Range","RGBA8","MinimapTokensColorTracker","ViewModelDecoration","minimapSelection","scrollbarShadow","minimapBackground","minimapSliderBackground","minimapSliderHoverBackground","minimapSliderActiveBackground","minimapForegroundOpacity","registerThemingParticipant","Selection","EventType","Gesture","MinimapCharRendererFactory","MinimapPosition","once","POINTER_DRAG_RESET_DISTANCE","GUTTER_DECORATION_WIDTH","MinimapOptions","constructor","configuration","theme","tokensColorTracker","options","pixelRatio","get","layoutInfo","minimapLayout","minimap","fontInfo","minimapOpts","renderMinimap","size","minimapHeightIsEditorHeight","scrollBeyondLastLine","showSlider","autohide","typicalHalfwidthCharacterWidth","lineHeight","minimapLeft","minimapWidth","minimapHeight","height","canvasInnerWidth","minimapCanvasInnerWidth","canvasInnerHeight","minimapCanvasInnerHeight","canvasOuterWidth","minimapCanvasOuterWidth","canvasOuterHeight","minimapCanvasOuterHeight","isSampling","minimapIsSampling","editorHeight","fontScale","minimapScale","minimapLineHeight","minimapCharWidth","charRenderer","create","fontFamily","defaultBackgroundColor","getColor","backgroundColor","_getMinimapBackground","foregroundAlpha","_getMinimapForegroundOpacity","themeColor","rgba","r","g","b","Math","round","a","_clamp","equals","other","MinimapLayout","scrollTop","scrollHeight","sliderNeeded","computedSliderRatio","sliderTop","sliderHeight","startLineNumber","endLineNumber","_computedSliderRatio","getDesiredScrollTopFromDelta","delta","getDesiredScrollTopFromTouchLocation","pageY","viewportStartLineNumber","viewportEndLineNumber","viewportStartLineNumberVerticalOffset","viewportHeight","viewportContainsWhitespaceGaps","lineCount","realLineCount","previousLayout","minimapLinesFitting","floor","logicalScrollHeight","max","maxMinimapSliderTop","maxLinesFitting","min","viewportLineCount","expectedViewportLineCount","extraLinesAtTheBottom","partialLine","sliderTopAligned","MinimapLine","dy","onContentChanged","onTokensChanged","INVALID","RenderData","renderedLayout","imageData","lines","_imageData","_renderedLines","_set","linesEquals","layout","scrollEquals","tmp","_get","i","len","length","rendLineNumberStart","onLinesChanged","changeFromLineNumber","changeCount","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","onLinesInserted","insertFromLineNumber","insertToLineNumber","ranges","MinimapBuffers","ctx","WIDTH","HEIGHT","background","_backgroundFillData","_createBackgroundFillData","_buffers","createImageData","_lastUsedBuffer","getBuffer","result","data","set","backgroundR","backgroundG","backgroundB","backgroundA","Uint8ClampedArray","offset","j","MinimapSamplingState","samplingRatio","minimapLines","compute","viewLineCount","oldSamplingState","minimapLineCount","computeContainedMinimapLineCount","ratio","halfRatio","lastIndex","oldMinimapLines","oldLength","oldIndex","oldDeltaLineCount","minViewLineNumber","MAX_EVENT_COUNT","events","lastEvent","fromViewLineNumber","toViewLineNumber","oldMinimapLineNumber","type","_oldIndex","push","selectedViewLineNumber","_i","modelLineToMinimapLine","lineNumber","modelLineRangeToMinimapLineRange","fromLineNumber","toLineNumber","fromLineIndex","toLineIndex","sampledLineNumber","decorationLineRangeToMinimapLineRange","minimapLineStart","minimapLineEnd","e","deletedLineCount","changeStartIndex","changeEndIndex","insertedLineCount","Minimap","context","getInstance","_selections","_minimapSelections","_context","samplingState","viewModel","getLineCount","_samplingState","_shouldCheckSampling","_actual","InnerMinimap","dispose","getDomNode","_onOptionsMaybeChanged","opts","_recreateLineSampling","onDidChangeOptions","onConfigurationChanged","onCursorStateChanged","selections","onSelectionChanged","onDecorationsChanged","affectsMinimap","onFlushed","minimapLineRange","count","onScrollChanged","onThemeChanged","range","onTokensColorsChanged","onZonesChanged","prepareRender","render","visibleRange","minimapCtx","viewportData","whitespaceViewportData","scrollWidth","getVerticalOffsetForLineNumber","scrollLeft","viewportWidth","wasSampling","Boolean","event","getRealLineCount","getLineContent","getLineMaxColumn","getMinimapLinesRenderingData","needed","lineIndex","getViewLineData","getSelections","selection","startColumn","endColumn","getMinimapDecorationsInViewport","modelStartLineNumber","modelEndLineNumber","decorations","getDecorationsInViewport","decoration","minimapStartLineNumber","minimapEndLineNumber","getOptions","model","revealLineNumber","revealRange","setScrollTop","viewLayout","setScrollPosition","_renderDecorations","_gestureInProgress","_theme","_model","_lastRenderData","_selectionColor","_domNode","document","createElement","write","setClassName","_getMinimapDomNodeClassName","setPosition","setAttribute","_shadow","appendChild","_canvas","setLeft","_decorationsCanvas","_slider","setLayerHinting","setContain","_sliderHorizontal","_applyLayout","_pointerDownListener","addStandardDisposableListener","domNode","POINTER_DOWN","preventDefault","button","position","getDomNodePagePosition","initialPosY","top","_startSliderDragging","internalOffsetY","offsetY","_sliderPointerMoveMonitor","_sliderPointerDownListener","stopPropagation","_gestureDisposable","addTarget","_sliderTouchStartListener","addDisposableListener","Start","toggleClassName","scrollDueToTouchEvent","passive","_sliderTouchMoveListener","Change","_sliderTouchEndListener","End","initialSliderState","target","Element","initialPosX","pageX","handlePointerMove","posy","posx","pointerOrthogonalDelta","abs","isWindows","pointerDelta","startMonitoring","pointerId","buttons","pointerMoveData","touch","startY","getBoundingClientRect","class_","join","setWidth","setHeight","width","_getBuffer","getContext","_a","renderingCtx","setDisplay","setTop","renderDecorations","renderLines","sort","compareRangesUsingStarts","zIndex","characterWidth","tabSize","canvasContext","clearRect","highlightedLines","ContiguousLineMap","_renderSelectionLineHighlights","_renderDecorationsLineHighlights","lineOffsetMap","_renderSelectionsHighlights","_renderDecorationsHighlights","isTransparent","fillStyle","transparent","toString","y1","y2","line","yy1","yy2","fillRect","canvas","highlightColors","Map","minimapOptions","Inline","decorationColor","value","highlightColor","has","y","renderDecorationOnLine","Gutter","x","renderDecoration","decorationRange","charWidth","x1","getXOffsetForPosition","x2","column","minimumXOffset","lineIndexToXOffset","lineData","prevx","charCode","charCodeAt","dx","isFullWidthCharacter","_lastData","_dirtyY1","_dirtyY2","_renderUntouchedLines","lineInfo","defaultBackground","useLighterFont","backgroundIsLight","baseCharHeight","renderMinimapLineHeight","innerLinePadding","renderBackground","renderedLines","_renderLine","dirtyY1","dirtyY2","dirtyHeight","putImageData","lastRenderData","lastTargetData","lastStartLineNumber","lastLines","lastLinesLength","targetData","maxDestPixel","dirtyPixel1","dirtyPixel2","copySourceStart","copySourceEnd","copyDestStart","copyDestEnd","dest_dy","lastLineIndex","source_dy","sourceStart","sourceEnd","destStart","destEnd","subarray","backgroundAlpha","colorTracker","minimapCharRenderer","content","tokens","maxDx","force1pxHeight","charIndex","tabsCharDelta","tokenIndex","tokensLen","getCount","tokenEndIndex","getEndOffset","tokenColorId","getForeground","tokenColor","insertSpacesCount","blockRenderChar","renderChar","defaultValue","_startLineNumber","_endLineNumber","_defaultValue","_values","collector","sliderBackground","addRule","sliderHoverBackground","sliderActiveBackground","shadow"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel.js';\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground, minimapForegroundOpacity } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { once } from '../../../../base/common/functional.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n    constructor(configuration, theme, tokensColorTracker) {\n        const options = configuration.options;\n        const pixelRatio = options.get(131 /* EditorOption.pixelRatio */);\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        const minimapLayout = layoutInfo.minimap;\n        const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        const minimapOpts = options.get(67 /* EditorOption.minimap */);\n        this.renderMinimap = minimapLayout.renderMinimap;\n        this.size = minimapOpts.size;\n        this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n        this.scrollBeyondLastLine = options.get(96 /* EditorOption.scrollBeyondLastLine */);\n        this.showSlider = minimapOpts.showSlider;\n        this.autohide = minimapOpts.autohide;\n        this.pixelRatio = pixelRatio;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this.minimapLeft = minimapLayout.minimapLeft;\n        this.minimapWidth = minimapLayout.minimapWidth;\n        this.minimapHeight = layoutInfo.height;\n        this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n        this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n        this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n        this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n        this.isSampling = minimapLayout.minimapIsSampling;\n        this.editorHeight = layoutInfo.height;\n        this.fontScale = minimapLayout.minimapScale;\n        this.minimapLineHeight = minimapLayout.minimapLineHeight;\n        this.minimapCharWidth = 1 /* Constants.BASE_CHAR_WIDTH */ * this.fontScale;\n        this.charRenderer = once(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n        this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* ColorId.DefaultBackground */);\n        this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n        this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n    }\n    static _getMinimapBackground(theme, defaultBackgroundColor) {\n        const themeColor = theme.getColor(minimapBackground);\n        if (themeColor) {\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n        }\n        return defaultBackgroundColor;\n    }\n    static _getMinimapForegroundOpacity(theme) {\n        const themeColor = theme.getColor(minimapForegroundOpacity);\n        if (themeColor) {\n            return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n        }\n        return 255;\n    }\n    equals(other) {\n        return (this.renderMinimap === other.renderMinimap\n            && this.size === other.size\n            && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\n            && this.scrollBeyondLastLine === other.scrollBeyondLastLine\n            && this.showSlider === other.showSlider\n            && this.autohide === other.autohide\n            && this.pixelRatio === other.pixelRatio\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n            && this.lineHeight === other.lineHeight\n            && this.minimapLeft === other.minimapLeft\n            && this.minimapWidth === other.minimapWidth\n            && this.minimapHeight === other.minimapHeight\n            && this.canvasInnerWidth === other.canvasInnerWidth\n            && this.canvasInnerHeight === other.canvasInnerHeight\n            && this.canvasOuterWidth === other.canvasOuterWidth\n            && this.canvasOuterHeight === other.canvasOuterHeight\n            && this.isSampling === other.isSampling\n            && this.editorHeight === other.editorHeight\n            && this.fontScale === other.fontScale\n            && this.minimapLineHeight === other.minimapLineHeight\n            && this.minimapCharWidth === other.minimapCharWidth\n            && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor)\n            && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor)\n            && this.foregroundAlpha === other.foregroundAlpha);\n    }\n}\nclass MinimapLayout {\n    constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\n        this.scrollTop = scrollTop;\n        this.scrollHeight = scrollHeight;\n        this.sliderNeeded = sliderNeeded;\n        this._computedSliderRatio = computedSliderRatio;\n        this.sliderTop = sliderTop;\n        this.sliderHeight = sliderHeight;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollTopFromDelta(delta) {\n        return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n    }\n    getDesiredScrollTopFromTouchLocation(pageY) {\n        return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n    }\n    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n        const pixelRatio = options.pixelRatio;\n        const minimapLineHeight = options.minimapLineHeight;\n        const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n        const lineHeight = options.lineHeight;\n        if (options.minimapHeightIsEditorHeight) {\n            const logicalScrollHeight = (realLineCount * options.lineHeight\n                + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0));\n            const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n            const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n            // The slider can move from 0 to `maxMinimapSliderTop`\n            // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n            const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n            const sliderTop = (scrollTop * computedSliderRatio);\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\n        }\n        // The visible line count in a viewport can change due to a number of reasons:\n        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n        //    e.g. for a line height of 20, and a viewport height of 600\n        //          * scrollTop = 0  => visible lines are [1, 30]\n        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n        //          * scrollTop = 20 => visible lines are [2, 31]\n        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n        // We must first establish a desirable slider height.\n        let sliderHeight;\n        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n            // case b) from above: there are whitespace gaps in the viewport.\n            // In this case, the height of the slider directly reflects the visible line count.\n            const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        else {\n            // The slider has a stable height\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        let maxMinimapSliderTop;\n        if (options.scrollBeyondLastLine) {\n            // The minimap slider, when dragged all the way down, will contain the last line at its top\n            maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\n        }\n        else {\n            // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n            maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\n        }\n        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n        // The slider can move from 0 to `maxMinimapSliderTop`\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n        const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n        const sliderTop = (scrollTop * computedSliderRatio);\n        let extraLinesAtTheBottom = 0;\n        if (options.scrollBeyondLastLine) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            extraLinesAtTheBottom = expectedViewportLineCount - 1;\n        }\n        if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\n            // All lines fit in the minimap\n            const startLineNumber = 1;\n            const endLineNumber = lineCount;\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n        }\n        else {\n            let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n            // Avoid flickering caused by a partial viewport start line\n            // by being consistent w.r.t. the previous layout decision\n            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n                if (previousLayout.scrollTop > scrollTop) {\n                    // Scrolling up => never increase `startLineNumber`\n                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n                }\n                if (previousLayout.scrollTop < scrollTop) {\n                    // Scrolling down => never decrease `startLineNumber`\n                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n                }\n            }\n            const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\n            const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n            const sliderTopAligned = (viewportStartLineNumber - startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\n            return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, startLineNumber, endLineNumber);\n        }\n    }\n}\nclass MinimapLine {\n    constructor(dy) {\n        this.dy = dy;\n    }\n    onContentChanged() {\n        this.dy = -1;\n    }\n    onTokensChanged() {\n        this.dy = -1;\n    }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n    constructor(renderedLayout, imageData, lines) {\n        this.renderedLayout = renderedLayout;\n        this._imageData = imageData;\n        this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n        this._renderedLines._set(renderedLayout.startLineNumber, lines);\n    }\n    /**\n     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n     */\n    linesEquals(layout) {\n        if (!this.scrollEquals(layout)) {\n            return false;\n        }\n        const tmp = this._renderedLines._get();\n        const lines = tmp.lines;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].dy === -1) {\n                // This line is invalid\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if the current RenderData matches the new layout's scroll position\n     */\n    scrollEquals(layout) {\n        return this.renderedLayout.startLineNumber === layout.startLineNumber\n            && this.renderedLayout.endLineNumber === layout.endLineNumber;\n    }\n    _get() {\n        const tmp = this._renderedLines._get();\n        return {\n            imageData: this._imageData,\n            rendLineNumberStart: tmp.rendLineNumberStart,\n            lines: tmp.lines\n        };\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n    onTokensChanged(ranges) {\n        return this._renderedLines.onTokensChanged(ranges);\n    }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n    constructor(ctx, WIDTH, HEIGHT, background) {\n        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n        this._buffers = [\n            ctx.createImageData(WIDTH, HEIGHT),\n            ctx.createImageData(WIDTH, HEIGHT)\n        ];\n        this._lastUsedBuffer = 0;\n    }\n    getBuffer() {\n        // rotate buffers\n        this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n        const result = this._buffers[this._lastUsedBuffer];\n        // fill with background color\n        result.data.set(this._backgroundFillData);\n        return result;\n    }\n    static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n        const backgroundR = background.r;\n        const backgroundG = background.g;\n        const backgroundB = background.b;\n        const backgroundA = background.a;\n        const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n        let offset = 0;\n        for (let i = 0; i < HEIGHT; i++) {\n            for (let j = 0; j < WIDTH; j++) {\n                result[offset] = backgroundR;\n                result[offset + 1] = backgroundG;\n                result[offset + 2] = backgroundB;\n                result[offset + 3] = backgroundA;\n                offset += 4;\n            }\n        }\n        return result;\n    }\n}\nclass MinimapSamplingState {\n    constructor(samplingRatio, minimapLines) {\n        this.samplingRatio = samplingRatio;\n        this.minimapLines = minimapLines;\n    }\n    static compute(options, viewLineCount, oldSamplingState) {\n        if (options.renderMinimap === 0 /* RenderMinimap.None */ || !options.isSampling) {\n            return [null, []];\n        }\n        // ratio is intentionally not part of the layout to avoid the layout changing all the time\n        // so we need to recompute it again...\n        const pixelRatio = options.pixelRatio;\n        const lineHeight = options.lineHeight;\n        const scrollBeyondLastLine = options.scrollBeyondLastLine;\n        const { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n            viewLineCount: viewLineCount,\n            scrollBeyondLastLine: scrollBeyondLastLine,\n            height: options.editorHeight,\n            lineHeight: lineHeight,\n            pixelRatio: pixelRatio\n        });\n        const ratio = viewLineCount / minimapLineCount;\n        const halfRatio = ratio / 2;\n        if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n            const result = [];\n            result[0] = 1;\n            if (minimapLineCount > 1) {\n                for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n                    result[i] = Math.round(i * ratio + halfRatio);\n                }\n                result[minimapLineCount - 1] = viewLineCount;\n            }\n            return [new MinimapSamplingState(ratio, result), []];\n        }\n        const oldMinimapLines = oldSamplingState.minimapLines;\n        const oldLength = oldMinimapLines.length;\n        const result = [];\n        let oldIndex = 0;\n        let oldDeltaLineCount = 0;\n        let minViewLineNumber = 1;\n        const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n        let events = [];\n        let lastEvent = null;\n        for (let i = 0; i < minimapLineCount; i++) {\n            const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n            const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n            while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                        lastEvent.deleteToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount--;\n                }\n                oldIndex++;\n            }\n            let selectedViewLineNumber;\n            if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n                // reuse the old sampled line\n                selectedViewLineNumber = oldMinimapLines[oldIndex];\n                oldIndex++;\n            }\n            else {\n                if (i === 0) {\n                    selectedViewLineNumber = 1;\n                }\n                else if (i + 1 === minimapLineCount) {\n                    selectedViewLineNumber = viewLineCount;\n                }\n                else {\n                    selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n                }\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n                        lastEvent.insertToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount++;\n                }\n            }\n            result[i] = selectedViewLineNumber;\n            minViewLineNumber = selectedViewLineNumber;\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n            while (oldIndex < oldLength) {\n                const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                    lastEvent.deleteToLineNumber++;\n                }\n                else {\n                    lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                    events.push(lastEvent);\n                }\n                oldDeltaLineCount--;\n                oldIndex++;\n            }\n        }\n        else {\n            // too many events, just give up\n            events = [{ type: 'flush' }];\n        }\n        return [new MinimapSamplingState(ratio, result), events];\n    }\n    modelLineToMinimapLine(lineNumber) {\n        return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n    }\n    /**\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\n     */\n    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n        let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n        while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n            fromLineIndex--;\n        }\n        let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n        while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n            toLineIndex++;\n        }\n        if (fromLineIndex === toLineIndex) {\n            const sampledLineNumber = this.minimapLines[fromLineIndex];\n            if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n                // This line is not part of the sampled lines ==> nothing to do\n                return null;\n            }\n        }\n        return [fromLineIndex + 1, toLineIndex + 1];\n    }\n    /**\n     * Will always return a range, even if it is not intersecting with a sampled model line.\n     */\n    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n        let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n        let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n        if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n            if (minimapLineEnd === this.minimapLines.length) {\n                if (minimapLineStart > 1) {\n                    minimapLineStart--;\n                }\n            }\n            else {\n                minimapLineEnd++;\n            }\n        }\n        return [minimapLineStart, minimapLineEnd];\n    }\n    onLinesDeleted(e) {\n        // have the mapping be sticky\n        const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        let changeStartIndex = this.minimapLines.length;\n        let changeEndIndex = 0;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            if (this.minimapLines[i] <= e.toLineNumber) {\n                // this line got deleted => move to previous available\n                this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n                changeStartIndex = Math.min(changeStartIndex, i);\n                changeEndIndex = Math.max(changeEndIndex, i);\n            }\n            else {\n                this.minimapLines[i] -= deletedLineCount;\n            }\n        }\n        return [changeStartIndex, changeEndIndex];\n    }\n    onLinesInserted(e) {\n        // have the mapping be sticky\n        const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            this.minimapLines[i] += insertedLineCount;\n        }\n    }\n}\nexport class Minimap extends ViewPart {\n    constructor(context) {\n        super(context);\n        this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n        this._selections = [];\n        this._minimapSelections = null;\n        this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        const [samplingState,] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n        this._samplingState = samplingState;\n        this._shouldCheckSampling = false;\n        this._actual = new InnerMinimap(context.theme, this);\n    }\n    dispose() {\n        this._actual.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this._actual.getDomNode();\n    }\n    _onOptionsMaybeChanged() {\n        const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        if (this.options.equals(opts)) {\n            return false;\n        }\n        this.options = opts;\n        this._recreateLineSampling();\n        this._actual.onDidChangeOptions();\n        return true;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections;\n        this._minimapSelections = null;\n        return this._actual.onSelectionChanged();\n    }\n    onDecorationsChanged(e) {\n        if (e.affectsMinimap) {\n            return this._actual.onDecorationsChanged();\n        }\n        return false;\n    }\n    onFlushed(e) {\n        if (this._samplingState) {\n            this._shouldCheckSampling = true;\n        }\n        return this._actual.onFlushed();\n    }\n    onLinesChanged(e) {\n        if (this._samplingState) {\n            const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n            if (minimapLineRange) {\n                return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onLinesChanged(e.fromLineNumber, e.count);\n        }\n    }\n    onLinesDeleted(e) {\n        if (this._samplingState) {\n            const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n            if (changeStartIndex <= changeEndIndex) {\n                this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n            }\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onLinesInserted(e) {\n        if (this._samplingState) {\n            this._samplingState.onLinesInserted(e);\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onScrollChanged(e) {\n        return this._actual.onScrollChanged();\n    }\n    onThemeChanged(e) {\n        this._actual.onThemeChanged();\n        this._onOptionsMaybeChanged();\n        return true;\n    }\n    onTokensChanged(e) {\n        if (this._samplingState) {\n            const ranges = [];\n            for (const range of e.ranges) {\n                const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n                if (minimapLineRange) {\n                    ranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\n                }\n            }\n            if (ranges.length) {\n                return this._actual.onTokensChanged(ranges);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onTokensChanged(e.ranges);\n        }\n    }\n    onTokensColorsChanged(e) {\n        this._onOptionsMaybeChanged();\n        return this._actual.onTokensColorsChanged();\n    }\n    onZonesChanged(e) {\n        return this._actual.onZonesChanged();\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        if (this._shouldCheckSampling) {\n            this._shouldCheckSampling = false;\n            this._recreateLineSampling();\n        }\n    }\n    render(ctx) {\n        let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n        let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n        if (this._samplingState) {\n            viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n            viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n        }\n        const minimapCtx = {\n            viewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\n            scrollWidth: ctx.scrollWidth,\n            scrollHeight: ctx.scrollHeight,\n            viewportStartLineNumber: viewportStartLineNumber,\n            viewportEndLineNumber: viewportEndLineNumber,\n            viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n            scrollTop: ctx.scrollTop,\n            scrollLeft: ctx.scrollLeft,\n            viewportWidth: ctx.viewportWidth,\n            viewportHeight: ctx.viewportHeight,\n        };\n        this._actual.render(minimapCtx);\n    }\n    //#region IMinimapModel\n    _recreateLineSampling() {\n        this._minimapSelections = null;\n        const wasSampling = Boolean(this._samplingState);\n        const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n        this._samplingState = samplingState;\n        if (wasSampling && this._samplingState) {\n            // was sampling, is sampling\n            for (const event of events) {\n                switch (event.type) {\n                    case 'deleted':\n                        this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n                        break;\n                    case 'inserted':\n                        this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n                        break;\n                    case 'flush':\n                        this._actual.onFlushed();\n                        break;\n                }\n            }\n        }\n    }\n    getLineCount() {\n        if (this._samplingState) {\n            return this._samplingState.minimapLines.length;\n        }\n        return this._context.viewModel.getLineCount();\n    }\n    getRealLineCount() {\n        return this._context.viewModel.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        if (this._samplingState) {\n            return this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.viewModel.getLineContent(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        if (this._samplingState) {\n            return this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.viewModel.getLineMaxColumn(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        if (this._samplingState) {\n            const result = [];\n            for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n                if (needed[lineIndex]) {\n                    result[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n                }\n                else {\n                    result[lineIndex] = null;\n                }\n            }\n            return result;\n        }\n        return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n    }\n    getSelections() {\n        if (this._minimapSelections === null) {\n            if (this._samplingState) {\n                this._minimapSelections = [];\n                for (const selection of this._selections) {\n                    const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n                    this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n                }\n            }\n            else {\n                this._minimapSelections = this._selections;\n            }\n        }\n        return this._minimapSelections;\n    }\n    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n        let visibleRange;\n        if (this._samplingState) {\n            const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n            const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n            visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n        }\n        else {\n            visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n        }\n        const decorations = this._context.viewModel.getDecorationsInViewport(visibleRange);\n        if (this._samplingState) {\n            const result = [];\n            for (const decoration of decorations) {\n                if (!decoration.options.minimap) {\n                    continue;\n                }\n                const range = decoration.range;\n                const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n                const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n                result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n            }\n            return result;\n        }\n        return decorations;\n    }\n    getOptions() {\n        return this._context.viewModel.model.getOptions();\n    }\n    revealLineNumber(lineNumber) {\n        if (this._samplingState) {\n            lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n        }\n        this._context.viewModel.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* viewEvents.VerticalRevealType.Center */, 0 /* ScrollType.Smooth */);\n    }\n    setScrollTop(scrollTop) {\n        this._context.viewModel.viewLayout.setScrollPosition({\n            scrollTop: scrollTop\n        }, 1 /* ScrollType.Immediate */);\n    }\n}\nclass InnerMinimap extends Disposable {\n    constructor(theme, model) {\n        super();\n        this._renderDecorations = false;\n        this._gestureInProgress = false;\n        this._theme = theme;\n        this._model = model;\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this._domNode, 8 /* PartFingerprint.Minimap */);\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n        this._domNode.setPosition('absolute');\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._shadow = createFastDomNode(document.createElement('div'));\n        this._shadow.setClassName('minimap-shadow-hidden');\n        this._domNode.appendChild(this._shadow);\n        this._canvas = createFastDomNode(document.createElement('canvas'));\n        this._canvas.setPosition('absolute');\n        this._canvas.setLeft(0);\n        this._domNode.appendChild(this._canvas);\n        this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n        this._decorationsCanvas.setPosition('absolute');\n        this._decorationsCanvas.setClassName('minimap-decorations-layer');\n        this._decorationsCanvas.setLeft(0);\n        this._domNode.appendChild(this._decorationsCanvas);\n        this._slider = createFastDomNode(document.createElement('div'));\n        this._slider.setPosition('absolute');\n        this._slider.setClassName('minimap-slider');\n        this._slider.setLayerHinting(true);\n        this._slider.setContain('strict');\n        this._domNode.appendChild(this._slider);\n        this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n        this._sliderHorizontal.setPosition('absolute');\n        this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n        this._slider.appendChild(this._sliderHorizontal);\n        this._applyLayout();\n        this._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, (e) => {\n            e.preventDefault();\n            const renderMinimap = this._model.options.renderMinimap;\n            if (renderMinimap === 0 /* RenderMinimap.None */) {\n                return;\n            }\n            if (!this._lastRenderData) {\n                return;\n            }\n            if (this._model.options.size !== 'proportional') {\n                if (e.button === 0 && this._lastRenderData) {\n                    // pretend the click occurred in the center of the slider\n                    const position = dom.getDomNodePagePosition(this._slider.domNode);\n                    const initialPosY = position.top + position.height / 2;\n                    this._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n                }\n                return;\n            }\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.offsetY;\n            const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n            let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;\n            lineNumber = Math.min(lineNumber, this._model.getLineCount());\n            this._model.revealLineNumber(lineNumber);\n        });\n        this._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n        this._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (e.button === 0 && this._lastRenderData) {\n                this._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n            }\n        });\n        this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n        this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData) {\n                this._slider.toggleClassName('active', true);\n                this._gestureInProgress = true;\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData && this._gestureInProgress) {\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            this._gestureInProgress = false;\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    _startSliderDragging(e, initialPosY, initialSliderState) {\n        if (!e.target || !(e.target instanceof Element)) {\n            return;\n        }\n        const initialPosX = e.pageX;\n        this._slider.toggleClassName('active', true);\n        const handlePointerMove = (posy, posx) => {\n            const pointerOrthogonalDelta = Math.abs(posx - initialPosX);\n            if (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n                // The pointer has wondered away from the scrollbar => reset dragging\n                this._model.setScrollTop(initialSliderState.scrollTop);\n                return;\n            }\n            const pointerDelta = posy - initialPosY;\n            this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n        };\n        if (e.pageY !== initialPosY) {\n            handlePointerMove(e.pageY, initialPosX);\n        }\n        this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX), () => {\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    scrollDueToTouchEvent(touch) {\n        const startY = this._domNode.domNode.getBoundingClientRect().top;\n        const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n        this._model.setScrollTop(scrollTop);\n    }\n    dispose() {\n        this._pointerDownListener.dispose();\n        this._sliderPointerMoveMonitor.dispose();\n        this._sliderPointerDownListener.dispose();\n        this._gestureDisposable.dispose();\n        this._sliderTouchStartListener.dispose();\n        this._sliderTouchMoveListener.dispose();\n        this._sliderTouchEndListener.dispose();\n        super.dispose();\n    }\n    _getMinimapDomNodeClassName() {\n        const class_ = ['minimap'];\n        if (this._model.options.showSlider === 'always') {\n            class_.push('slider-always');\n        }\n        else {\n            class_.push('slider-mouseover');\n        }\n        if (this._model.options.autohide) {\n            class_.push('autohide');\n        }\n        return class_.join(' ');\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    _applyLayout() {\n        this._domNode.setLeft(this._model.options.minimapLeft);\n        this._domNode.setWidth(this._model.options.minimapWidth);\n        this._domNode.setHeight(this._model.options.minimapHeight);\n        this._shadow.setHeight(this._model.options.minimapHeight);\n        this._canvas.setWidth(this._model.options.canvasOuterWidth);\n        this._canvas.setHeight(this._model.options.canvasOuterHeight);\n        this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n        this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n        this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._slider.setWidth(this._model.options.minimapWidth);\n    }\n    _getBuffer() {\n        if (!this._buffers) {\n            if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n                this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n            }\n        }\n        return this._buffers ? this._buffers.getBuffer() : null;\n    }\n    // ---- begin view event handlers\n    onDidChangeOptions() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._applyLayout();\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    }\n    onSelectionChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onDecorationsChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onFlushed() {\n        this._lastRenderData = null;\n        return true;\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n        }\n        return false;\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        var _a;\n        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n        return true;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        var _a;\n        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n        return true;\n    }\n    onScrollChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onThemeChanged() {\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._renderDecorations = true;\n        return true;\n    }\n    onTokensChanged(ranges) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onTokensChanged(ranges);\n        }\n        return false;\n    }\n    onTokensColorsChanged() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        return true;\n    }\n    onZonesChanged() {\n        this._lastRenderData = null;\n        return true;\n    }\n    // --- end event handlers\n    render(renderingCtx) {\n        const renderMinimap = this._model.options.renderMinimap;\n        if (renderMinimap === 0 /* RenderMinimap.None */) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n            this._sliderHorizontal.setWidth(0);\n            this._sliderHorizontal.setHeight(0);\n            return;\n        }\n        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n        }\n        else {\n            this._shadow.setClassName('minimap-shadow-visible');\n        }\n        const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n        this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n        this._slider.setTop(layout.sliderTop);\n        this._slider.setHeight(layout.sliderHeight);\n        // Compute horizontal slider coordinates\n        this._sliderHorizontal.setLeft(0);\n        this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n        this._sliderHorizontal.setTop(0);\n        this._sliderHorizontal.setHeight(layout.sliderHeight);\n        this.renderDecorations(layout);\n        this._lastRenderData = this.renderLines(layout);\n    }\n    renderDecorations(layout) {\n        if (this._renderDecorations) {\n            this._renderDecorations = false;\n            const selections = this._model.getSelections();\n            selections.sort(Range.compareRangesUsingStarts);\n            const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n            decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n            const { canvasInnerWidth, canvasInnerHeight } = this._model.options;\n            const lineHeight = this._model.options.minimapLineHeight;\n            const characterWidth = this._model.options.minimapCharWidth;\n            const tabSize = this._model.getOptions().tabSize;\n            const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n            canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n            // We first need to render line highlights and then render decorations on top of those.\n            // But we need to pick a single color for each line, and use that as a line highlight.\n            // This needs to be the color of the decoration with the highest `zIndex`, but priority\n            // is given to the selection.\n            const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n            this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, lineHeight);\n            this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, lineHeight);\n            const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n            this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n        }\n    }\n    _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, lineHeight) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n        let y1 = 0;\n        let y2 = 0;\n        for (const selection of selections) {\n            const startLineNumber = Math.max(layout.startLineNumber, selection.startLineNumber);\n            const endLineNumber = Math.min(layout.endLineNumber, selection.endLineNumber);\n            if (startLineNumber > endLineNumber) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                highlightedLines.set(line, true);\n            }\n            const yy1 = (startLineNumber - layout.startLineNumber) * lineHeight;\n            const yy2 = (endLineNumber - layout.startLineNumber) * lineHeight + lineHeight;\n            if (y2 >= yy1) {\n                // merge into previous\n                y2 = yy2;\n            }\n            else {\n                if (y2 > y1) {\n                    // flush\n                    canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n                }\n                y1 = yy1;\n                y2 = yy2;\n            }\n        }\n        if (y2 > y1) {\n            // flush\n            canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n    }\n    _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, lineHeight) {\n        const highlightColors = new Map();\n        // Loop backwards to hit first decorations with higher `zIndex`\n        for (let i = decorations.length - 1; i >= 0; i--) {\n            const decoration = decorations[i];\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions || minimapOptions.position !== MinimapPosition.Inline) {\n                continue;\n            }\n            const startLineNumber = Math.max(layout.startLineNumber, decoration.range.startLineNumber);\n            const endLineNumber = Math.min(layout.endLineNumber, decoration.range.endLineNumber);\n            if (startLineNumber > endLineNumber) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            let highlightColor = highlightColors.get(decorationColor.toString());\n            if (!highlightColor) {\n                highlightColor = decorationColor.transparent(0.5).toString();\n                highlightColors.set(decorationColor.toString(), highlightColor);\n            }\n            canvasContext.fillStyle = highlightColor;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                if (highlightedLines.has(line)) {\n                    continue;\n                }\n                highlightedLines.set(line, true);\n                const y = (startLineNumber - layout.startLineNumber) * lineHeight;\n                canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, lineHeight);\n            }\n        }\n    }\n    _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        for (const selection of selections) {\n            const startLineNumber = Math.max(layout.startLineNumber, selection.startLineNumber);\n            const endLineNumber = Math.min(layout.endLineNumber, selection.endLineNumber);\n            if (startLineNumber > endLineNumber) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            }\n        }\n    }\n    _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        // Loop forwards to hit first decorations with lower `zIndex`\n        for (const decoration of decorations) {\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions) {\n                continue;\n            }\n            const startLineNumber = Math.max(layout.startLineNumber, decoration.range.startLineNumber);\n            const endLineNumber = Math.min(layout.endLineNumber, decoration.range.endLineNumber);\n            if (startLineNumber > endLineNumber) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                switch (minimapOptions.position) {\n                    case MinimapPosition.Inline:\n                        this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n                        continue;\n                    case MinimapPosition.Gutter: {\n                        const y = (line - layout.startLineNumber) * lineHeight;\n                        const x = 2;\n                        this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\n                        continue;\n                    }\n                }\n            }\n        }\n    }\n    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth, canvasInnerWidth) {\n        const y = (lineNumber - layout.startLineNumber) * lineHeight;\n        // Skip rendering the line if it's vertically outside our viewport\n        if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n            return;\n        }\n        const { startLineNumber, endLineNumber } = decorationRange;\n        const startColumn = (startLineNumber === lineNumber ? decorationRange.startColumn : 1);\n        const endColumn = (endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber));\n        const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n        const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n        this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n    }\n    getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n        if (column === 1) {\n            return MINIMAP_GUTTER_WIDTH;\n        }\n        const minimumXOffset = (column - 1) * charWidth;\n        if (minimumXOffset >= canvasInnerWidth) {\n            // there is no need to look at actual characters,\n            // as this column is certainly after the minimap width\n            return canvasInnerWidth;\n        }\n        // Cache line offset data so that it is only read once per line\n        let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n        if (!lineIndexToXOffset) {\n            const lineData = this._model.getLineContent(lineNumber);\n            lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n            let prevx = MINIMAP_GUTTER_WIDTH;\n            for (let i = 1; i < lineData.length + 1; i++) {\n                const charCode = lineData.charCodeAt(i - 1);\n                const dx = charCode === 9 /* CharCode.Tab */\n                    ? tabSize * charWidth\n                    : strings.isFullWidthCharacter(charCode)\n                        ? 2 * charWidth\n                        : charWidth;\n                const x = prevx + dx;\n                if (x >= canvasInnerWidth) {\n                    // no need to keep on going, as we've hit the canvas width\n                    lineIndexToXOffset[i] = canvasInnerWidth;\n                    break;\n                }\n                lineIndexToXOffset[i] = x;\n                prevx = x;\n            }\n            lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n        }\n        if (column - 1 < lineIndexToXOffset.length) {\n            return lineIndexToXOffset[column - 1];\n        }\n        // goes over the canvas width\n        return canvasInnerWidth;\n    }\n    renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n        canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n        canvasContext.fillRect(x, y, width, height);\n    }\n    renderLines(layout) {\n        const startLineNumber = layout.startLineNumber;\n        const endLineNumber = layout.endLineNumber;\n        const minimapLineHeight = this._model.options.minimapLineHeight;\n        // Check if nothing changed w.r.t. lines from last frame\n        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n            const _lastData = this._lastRenderData._get();\n            // Nice!! Nothing changed from last frame\n            return new RenderData(layout, _lastData.imageData, _lastData.lines);\n        }\n        // Oh well!! We need to repaint some lines...\n        const imageData = this._getBuffer();\n        if (!imageData) {\n            // 0 width or 0 height canvas, nothing to do\n            return null;\n        }\n        // Render untouched lines by using last rendered data.\n        const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n        // Fetch rendering info from view model for rest of lines that need rendering.\n        const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n        const tabSize = this._model.getOptions().tabSize;\n        const defaultBackground = this._model.options.defaultBackgroundColor;\n        const background = this._model.options.backgroundColor;\n        const foregroundAlpha = this._model.options.foregroundAlpha;\n        const tokensColorTracker = this._model.tokensColorTracker;\n        const useLighterFont = tokensColorTracker.backgroundIsLight();\n        const renderMinimap = this._model.options.renderMinimap;\n        const charRenderer = this._model.options.charRenderer();\n        const fontScale = this._model.options.fontScale;\n        const minimapCharWidth = this._model.options.minimapCharWidth;\n        const baseCharHeight = (renderMinimap === 1 /* RenderMinimap.Text */ ? 2 /* Constants.BASE_CHAR_HEIGHT */ : 2 /* Constants.BASE_CHAR_HEIGHT */ + 1);\n        const renderMinimapLineHeight = baseCharHeight * fontScale;\n        const innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\n        // Render the rest of lines\n        const backgroundA = background.a / 255;\n        const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n        let dy = 0;\n        const renderedLines = [];\n        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n            if (needed[lineIndex]) {\n                InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n            }\n            renderedLines[lineIndex] = new MinimapLine(dy);\n            dy += minimapLineHeight;\n        }\n        const dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\n        const dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\n        const dirtyHeight = dirtyY2 - dirtyY1;\n        // Finally, paint to the canvas\n        const ctx = this._canvas.domNode.getContext('2d');\n        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n        // Save rendered data for reuse on next frame if possible\n        return new RenderData(layout, imageData, renderedLines);\n    }\n    static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n        const needed = [];\n        if (!lastRenderData) {\n            for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n                needed[i] = true;\n            }\n            return [-1, -1, needed];\n        }\n        const _lastData = lastRenderData._get();\n        const lastTargetData = _lastData.imageData.data;\n        const lastStartLineNumber = _lastData.rendLineNumberStart;\n        const lastLines = _lastData.lines;\n        const lastLinesLength = lastLines.length;\n        const WIDTH = target.width;\n        const targetData = target.data;\n        const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n        let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n        let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n        let copySourceStart = -1;\n        let copySourceEnd = -1;\n        let copyDestStart = -1;\n        let copyDestEnd = -1;\n        let dest_dy = 0;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - startLineNumber;\n            const lastLineIndex = lineNumber - lastStartLineNumber;\n            const source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\n            if (source_dy === -1) {\n                needed[lineIndex] = true;\n                dest_dy += minimapLineHeight;\n                continue;\n            }\n            const sourceStart = source_dy * WIDTH * 4;\n            const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n            const destStart = dest_dy * WIDTH * 4;\n            const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n                // contiguous zone => extend copy request\n                copySourceEnd = sourceEnd;\n                copyDestEnd = destEnd;\n            }\n            else {\n                if (copySourceStart !== -1) {\n                    // flush existing copy request\n                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                        dirtyPixel1 = copySourceEnd;\n                    }\n                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                        dirtyPixel2 = copySourceStart;\n                    }\n                }\n                copySourceStart = sourceStart;\n                copySourceEnd = sourceEnd;\n                copyDestStart = destStart;\n                copyDestEnd = destEnd;\n            }\n            needed[lineIndex] = false;\n            dest_dy += minimapLineHeight;\n        }\n        if (copySourceStart !== -1) {\n            // flush existing copy request\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                dirtyPixel1 = copySourceEnd;\n            }\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                dirtyPixel2 = copySourceStart;\n            }\n        }\n        const dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\n        const dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\n        return [dirtyY1, dirtyY2, needed];\n    }\n    static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n        const content = lineData.content;\n        const tokens = lineData.tokens;\n        const maxDx = target.width - charWidth;\n        const force1pxHeight = (minimapLineHeight === 1);\n        let dx = MINIMAP_GUTTER_WIDTH;\n        let charIndex = 0;\n        let tabsCharDelta = 0;\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n            const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n            const tokenColorId = tokens.getForeground(tokenIndex);\n            const tokenColor = colorTracker.getColor(tokenColorId);\n            for (; charIndex < tokenEndIndex; charIndex++) {\n                if (dx > maxDx) {\n                    // hit edge of minimap\n                    return;\n                }\n                const charCode = content.charCodeAt(charIndex);\n                if (charCode === 9 /* CharCode.Tab */) {\n                    const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    // No need to render anything since tab is invisible\n                    dx += insertSpacesCount * charWidth;\n                }\n                else if (charCode === 32 /* CharCode.Space */) {\n                    // No need to render anything since space is invisible\n                    dx += charWidth;\n                }\n                else {\n                    // Render twice for a full width character\n                    const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n                    for (let i = 0; i < count; i++) {\n                        if (renderMinimap === 2 /* RenderMinimap.Blocks */) {\n                            minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n                        }\n                        else { // RenderMinimap.Text\n                            minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n                        }\n                        dx += charWidth;\n                        if (dx > maxDx) {\n                            // hit edge of minimap\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nclass ContiguousLineMap {\n    constructor(startLineNumber, endLineNumber, defaultValue) {\n        this._startLineNumber = startLineNumber;\n        this._endLineNumber = endLineNumber;\n        this._defaultValue = defaultValue;\n        this._values = [];\n        for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n            this._values[i] = defaultValue;\n        }\n    }\n    has(lineNumber) {\n        return (this.get(lineNumber) !== this._defaultValue);\n    }\n    set(lineNumber, value) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return;\n        }\n        this._values[lineNumber - this._startLineNumber] = value;\n    }\n    get(lineNumber) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return this._defaultValue;\n        }\n        return this._values[lineNumber - this._startLineNumber];\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const sliderBackground = theme.getColor(minimapSliderBackground);\n    if (sliderBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${sliderBackground}; }`);\n    }\n    const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\n    if (sliderHoverBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${sliderHoverBackground}; }`);\n    }\n    const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\n    if (sliderActiveBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${sliderActiveBackground}; }`);\n    }\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${shadow} -6px 0 6px -6px inset; }`);\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}