{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthToObj, toLength } from './length.js';\nexport class TextEditInfo {\n  constructor(startOffset, endOffset, newLength) {\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.newLength = newLength;\n  }\n}\nexport class BeforeEditPositionMapper {\n  /**\n   * @param edits Must be sorted by offset in ascending order.\n  */\n  constructor(edits, documentLength) {\n    this.documentLength = documentLength;\n    this.nextEditIdx = 0;\n    this.deltaOldToNewLineCount = 0;\n    this.deltaOldToNewColumnCount = 0;\n    this.deltaLineIdxInOld = -1;\n    this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n  }\n  /**\n   * @param offset Must be equal to or greater than the last offset this method has been called with.\n  */\n  getOffsetBeforeChange(offset) {\n    this.adjustNextEdit(offset);\n    return this.translateCurToOld(offset);\n  }\n  /**\n   * @param offset Must be equal to or greater than the last offset this method has been called with.\n  */\n  getDistanceToNextChange(offset) {\n    this.adjustNextEdit(offset);\n    const nextEdit = this.edits[this.nextEditIdx];\n    const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : this.documentLength;\n    return lengthDiffNonNegative(offset, nextChangeOffset);\n  }\n  translateOldToCur(oldOffsetObj) {\n    if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n      return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n    } else {\n      return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n    }\n  }\n  translateCurToOld(newOffset) {\n    const offsetObj = lengthToObj(newOffset);\n    if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n      return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n    } else {\n      return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n    }\n  }\n  adjustNextEdit(offset) {\n    while (this.nextEditIdx < this.edits.length) {\n      const nextEdit = this.edits[this.nextEditIdx];\n      // After applying the edit, what is its end offset (considering all previous edits)?\n      const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n      if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n        // We are after the edit, skip it\n        this.nextEditIdx++;\n        const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n        // Before applying the edit, what is its end offset (considering all previous edits)?\n        const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n        const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n        this.deltaOldToNewLineCount += lineDelta;\n        const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n        const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n        this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n        this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n      } else {\n        // We are in or before the edit.\n        break;\n      }\n    }\n  }\n}\nclass TextEditInfoCache {\n  constructor(startOffset, endOffset, textLength) {\n    this.endOffsetBeforeObj = lengthToObj(endOffset);\n    this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n    this.offsetObj = lengthToObj(startOffset);\n  }\n  static from(edit) {\n    return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n  }\n}","map":{"version":3,"names":["lengthAdd","lengthDiffNonNegative","lengthLessThanEqual","lengthToObj","toLength","TextEditInfo","constructor","startOffset","endOffset","newLength","BeforeEditPositionMapper","edits","documentLength","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","map","edit","TextEditInfoCache","from","getOffsetBeforeChange","offset","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","lineCount","columnCount","newOffset","length","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthToObj, toLength } from './length.js';\nexport class TextEditInfo {\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits, documentLength) {\n        this.documentLength = documentLength;\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : this.documentLength;\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,SAAS,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,WAAW,EAAEC,QAAQ,QAAQ,aAAa;AAC1G,OAAO,MAAMC,YAAY,CAAC;EACtBC,WAAW,CAACC,WAAW,EAAEC,SAAS,EAAEC,SAAS,EAAE;IAC3C,IAAI,CAACF,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,SAAS,GAAGA,SAAS;EAC9B;AACJ;AACA,OAAO,MAAMC,wBAAwB,CAAC;EAClC;AACJ;AACA;EACIJ,WAAW,CAACK,KAAK,EAAEC,cAAc,EAAE;IAC/B,IAAI,CAACA,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,sBAAsB,GAAG,CAAC;IAC/B,IAAI,CAACC,wBAAwB,GAAG,CAAC;IACjC,IAAI,CAACC,iBAAiB,GAAG,CAAC,CAAC;IAC3B,IAAI,CAACL,KAAK,GAAGA,KAAK,CAACM,GAAG,CAACC,IAAI,IAAIC,iBAAiB,CAACC,IAAI,CAACF,IAAI,CAAC,CAAC;EAChE;EACA;AACJ;AACA;EACIG,qBAAqB,CAACC,MAAM,EAAE;IAC1B,IAAI,CAACC,cAAc,CAACD,MAAM,CAAC;IAC3B,OAAO,IAAI,CAACE,iBAAiB,CAACF,MAAM,CAAC;EACzC;EACA;AACJ;AACA;EACIG,uBAAuB,CAACH,MAAM,EAAE;IAC5B,IAAI,CAACC,cAAc,CAACD,MAAM,CAAC;IAC3B,MAAMI,QAAQ,GAAG,IAAI,CAACf,KAAK,CAAC,IAAI,CAACE,WAAW,CAAC;IAC7C,MAAMc,gBAAgB,GAAGD,QAAQ,GAAG,IAAI,CAACE,iBAAiB,CAACF,QAAQ,CAACG,SAAS,CAAC,GAAG,IAAI,CAACjB,cAAc;IACpG,OAAOX,qBAAqB,CAACqB,MAAM,EAAEK,gBAAgB,CAAC;EAC1D;EACAC,iBAAiB,CAACE,YAAY,EAAE;IAC5B,IAAIA,YAAY,CAACC,SAAS,KAAK,IAAI,CAACf,iBAAiB,EAAE;MACnD,OAAOZ,QAAQ,CAAC0B,YAAY,CAACC,SAAS,GAAG,IAAI,CAACjB,sBAAsB,EAAEgB,YAAY,CAACE,WAAW,GAAG,IAAI,CAACjB,wBAAwB,CAAC;IACnI,CAAC,MACI;MACD,OAAOX,QAAQ,CAAC0B,YAAY,CAACC,SAAS,GAAG,IAAI,CAACjB,sBAAsB,EAAEgB,YAAY,CAACE,WAAW,CAAC;IACnG;EACJ;EACAR,iBAAiB,CAACS,SAAS,EAAE;IACzB,MAAMJ,SAAS,GAAG1B,WAAW,CAAC8B,SAAS,CAAC;IACxC,IAAIJ,SAAS,CAACE,SAAS,GAAG,IAAI,CAACjB,sBAAsB,KAAK,IAAI,CAACE,iBAAiB,EAAE;MAC9E,OAAOZ,QAAQ,CAACyB,SAAS,CAACE,SAAS,GAAG,IAAI,CAACjB,sBAAsB,EAAEe,SAAS,CAACG,WAAW,GAAG,IAAI,CAACjB,wBAAwB,CAAC;IAC7H,CAAC,MACI;MACD,OAAOX,QAAQ,CAACyB,SAAS,CAACE,SAAS,GAAG,IAAI,CAACjB,sBAAsB,EAAEe,SAAS,CAACG,WAAW,CAAC;IAC7F;EACJ;EACAT,cAAc,CAACD,MAAM,EAAE;IACnB,OAAO,IAAI,CAACT,WAAW,GAAG,IAAI,CAACF,KAAK,CAACuB,MAAM,EAAE;MACzC,MAAMR,QAAQ,GAAG,IAAI,CAACf,KAAK,CAAC,IAAI,CAACE,WAAW,CAAC;MAC7C;MACA,MAAMsB,sBAAsB,GAAG,IAAI,CAACP,iBAAiB,CAACF,QAAQ,CAACU,iBAAiB,CAAC;MACjF,IAAIlC,mBAAmB,CAACiC,sBAAsB,EAAEb,MAAM,CAAC,EAAE;QACrD;QACA,IAAI,CAACT,WAAW,EAAE;QAClB,MAAMwB,yBAAyB,GAAGlC,WAAW,CAACgC,sBAAsB,CAAC;QACrE;QACA,MAAMG,+BAA+B,GAAGnC,WAAW,CAAC,IAAI,CAACyB,iBAAiB,CAACF,QAAQ,CAACa,kBAAkB,CAAC,CAAC;QACxG,MAAMC,SAAS,GAAGH,yBAAyB,CAACN,SAAS,GAAGO,+BAA+B,CAACP,SAAS;QACjG,IAAI,CAACjB,sBAAsB,IAAI0B,SAAS;QACxC,MAAMC,mBAAmB,GAAG,IAAI,CAACzB,iBAAiB,KAAKU,QAAQ,CAACa,kBAAkB,CAACR,SAAS,GAAG,IAAI,CAAChB,wBAAwB,GAAG,CAAC;QAChI,MAAM2B,WAAW,GAAGL,yBAAyB,CAACL,WAAW,GAAGM,+BAA+B,CAACN,WAAW;QACvG,IAAI,CAACjB,wBAAwB,GAAG0B,mBAAmB,GAAGC,WAAW;QACjE,IAAI,CAAC1B,iBAAiB,GAAGU,QAAQ,CAACa,kBAAkB,CAACR,SAAS;MAClE,CAAC,MACI;QACD;QACA;MACJ;IACJ;EACJ;AACJ;AACA,MAAMZ,iBAAiB,CAAC;EACpBb,WAAW,CAACC,WAAW,EAAEC,SAAS,EAAEmC,UAAU,EAAE;IAC5C,IAAI,CAACJ,kBAAkB,GAAGpC,WAAW,CAACK,SAAS,CAAC;IAChD,IAAI,CAAC4B,iBAAiB,GAAGjC,WAAW,CAACH,SAAS,CAACO,WAAW,EAAEoC,UAAU,CAAC,CAAC;IACxE,IAAI,CAACd,SAAS,GAAG1B,WAAW,CAACI,WAAW,CAAC;EAC7C;EACA,OAAOa,IAAI,CAACF,IAAI,EAAE;IACd,OAAO,IAAIC,iBAAiB,CAACD,IAAI,CAACX,WAAW,EAAEW,IAAI,CAACV,SAAS,EAAEU,IAAI,CAACT,SAAS,CAAC;EAClF;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}