{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport * as languages from '../../../common/languages.js';\nimport { NullState, nullTokenizeEncoded, nullTokenize } from '../../../common/languages/nullTokenize.js';\nimport * as monarchCommon from './monarchCommon.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\nclass MonarchStackElementFactory {\n  constructor(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n  static create(parent, state) {\n    return this._INSTANCE.create(parent, state);\n  }\n  create(parent, state) {\n    if (parent !== null && parent.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchStackElement(parent, state);\n    }\n    let stackElementId = MonarchStackElement.getStackElementId(parent);\n    if (stackElementId.length > 0) {\n      stackElementId += '|';\n    }\n    stackElementId += state;\n    let result = this._entries[stackElementId];\n    if (result) {\n      return result;\n    }\n    result = new MonarchStackElement(parent, state);\n    this._entries[stackElementId] = result;\n    return result;\n  }\n}\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\nclass MonarchStackElement {\n  constructor(parent, state) {\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n  static getStackElementId(element) {\n    let result = '';\n    while (element !== null) {\n      if (result.length > 0) {\n        result += '|';\n      }\n      result += element.state;\n      element = element.parent;\n    }\n    return result;\n  }\n  static _equals(a, b) {\n    while (a !== null && b !== null) {\n      if (a === b) {\n        return true;\n      }\n      if (a.state !== b.state) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    }\n    if (a === null && b === null) {\n      return true;\n    }\n    return false;\n  }\n  equals(other) {\n    return MonarchStackElement._equals(this, other);\n  }\n  push(state) {\n    return MonarchStackElementFactory.create(this, state);\n  }\n  pop() {\n    return this.parent;\n  }\n  popall() {\n    let result = this;\n    while (result.parent) {\n      result = result.parent;\n    }\n    return result;\n  }\n  switchTo(state) {\n    return MonarchStackElementFactory.create(this.parent, state);\n  }\n}\nclass EmbeddedLanguageData {\n  constructor(languageId, state) {\n    this.languageId = languageId;\n    this.state = state;\n  }\n  equals(other) {\n    return this.languageId === other.languageId && this.state.equals(other.state);\n  }\n  clone() {\n    const stateClone = this.state.clone();\n    // save an object\n    if (stateClone === this.state) {\n      return this;\n    }\n    return new EmbeddedLanguageData(this.languageId, this.state);\n  }\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\nclass MonarchLineStateFactory {\n  constructor(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n  static create(stack, embeddedLanguageData) {\n    return this._INSTANCE.create(stack, embeddedLanguageData);\n  }\n  create(stack, embeddedLanguageData) {\n    if (embeddedLanguageData !== null) {\n      // no caching when embedding\n      return new MonarchLineState(stack, embeddedLanguageData);\n    }\n    if (stack !== null && stack.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchLineState(stack, embeddedLanguageData);\n    }\n    const stackElementId = MonarchStackElement.getStackElementId(stack);\n    let result = this._entries[stackElementId];\n    if (result) {\n      return result;\n    }\n    result = new MonarchLineState(stack, null);\n    this._entries[stackElementId] = result;\n    return result;\n  }\n}\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\nclass MonarchLineState {\n  constructor(stack, embeddedLanguageData) {\n    this.stack = stack;\n    this.embeddedLanguageData = embeddedLanguageData;\n  }\n  clone() {\n    const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;\n    // save an object\n    if (embeddedlanguageDataClone === this.embeddedLanguageData) {\n      return this;\n    }\n    return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);\n  }\n  equals(other) {\n    if (!(other instanceof MonarchLineState)) {\n      return false;\n    }\n    if (!this.stack.equals(other.stack)) {\n      return false;\n    }\n    if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {\n      return true;\n    }\n    if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {\n      return false;\n    }\n    return this.embeddedLanguageData.equals(other.embeddedLanguageData);\n  }\n}\nclass MonarchClassicTokensCollector {\n  constructor() {\n    this._tokens = [];\n    this._languageId = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n  enterLanguage(languageId) {\n    this._languageId = languageId;\n  }\n  emit(startOffset, type) {\n    if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n      return;\n    }\n    this._lastTokenType = type;\n    this._lastTokenLanguage = this._languageId;\n    this._tokens.push(new languages.Token(startOffset, type, this._languageId));\n  }\n  nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n    const nestedLanguageId = embeddedLanguageData.languageId;\n    const embeddedModeState = embeddedLanguageData.state;\n    const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n    if (!nestedLanguageTokenizationSupport) {\n      this.enterLanguage(nestedLanguageId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n    const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);\n    if (offsetDelta !== 0) {\n      for (const token of nestedResult.tokens) {\n        this._tokens.push(new languages.Token(token.offset + offsetDelta, token.type, token.language));\n      }\n    } else {\n      this._tokens = this._tokens.concat(nestedResult.tokens);\n    }\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n    this._languageId = null;\n    return nestedResult.endState;\n  }\n  finalize(endState) {\n    return new languages.TokenizationResult(this._tokens, endState);\n  }\n}\nclass MonarchModernTokensCollector {\n  constructor(languageService, theme) {\n    this._languageService = languageService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0 /* LanguageId.Null */;\n    this._lastTokenMetadata = 0;\n  }\n  enterLanguage(languageId) {\n    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n  }\n  emit(startOffset, type) {\n    const metadata = this._theme.match(this._currentLanguageId, type);\n    if (this._lastTokenMetadata === metadata) {\n      return;\n    }\n    this._lastTokenMetadata = metadata;\n    this._tokens.push(startOffset);\n    this._tokens.push(metadata);\n  }\n  static _merge(a, b, c) {\n    const aLen = a !== null ? a.length : 0;\n    const bLen = b.length;\n    const cLen = c !== null ? c.length : 0;\n    if (aLen === 0 && bLen === 0 && cLen === 0) {\n      return new Uint32Array(0);\n    }\n    if (aLen === 0 && bLen === 0) {\n      return c;\n    }\n    if (bLen === 0 && cLen === 0) {\n      return a;\n    }\n    const result = new Uint32Array(aLen + bLen + cLen);\n    if (a !== null) {\n      result.set(a);\n    }\n    for (let i = 0; i < bLen; i++) {\n      result[aLen + i] = b[i];\n    }\n    if (c !== null) {\n      result.set(c, aLen + bLen);\n    }\n    return result;\n  }\n  nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n    const nestedLanguageId = embeddedLanguageData.languageId;\n    const embeddedModeState = embeddedLanguageData.state;\n    const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n    if (!nestedLanguageTokenizationSupport) {\n      this.enterLanguage(nestedLanguageId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n    const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);\n    if (offsetDelta !== 0) {\n      for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {\n        nestedResult.tokens[i] += offsetDelta;\n      }\n    }\n    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n    this._tokens = [];\n    this._currentLanguageId = 0;\n    this._lastTokenMetadata = 0;\n    return nestedResult.endState;\n  }\n  finalize(endState) {\n    return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n  }\n}\nlet MonarchTokenizer = class MonarchTokenizer {\n  constructor(languageService, standaloneThemeService, languageId, lexer, _configurationService) {\n    this._configurationService = _configurationService;\n    this._languageService = languageService;\n    this._standaloneThemeService = standaloneThemeService;\n    this._languageId = languageId;\n    this._lexer = lexer;\n    this._embeddedLanguages = Object.create(null);\n    this.embeddedLoaded = Promise.resolve(undefined);\n    // Set up listening for embedded modes\n    let emitting = false;\n    this._tokenizationRegistryListener = languages.TokenizationRegistry.onDidChange(e => {\n      if (emitting) {\n        return;\n      }\n      let isOneOfMyEmbeddedModes = false;\n      for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n        const language = e.changedLanguages[i];\n        if (this._embeddedLanguages[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        languages.TokenizationRegistry.fire([this._languageId]);\n        emitting = false;\n      }\n    });\n    this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n      overrideIdentifier: this._languageId\n    });\n    this._configurationService.onDidChangeConfiguration(e => {\n      if (e.affectsConfiguration('editor.maxTokenizationLineLength')) {\n        this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n          overrideIdentifier: this._languageId\n        });\n      }\n    });\n  }\n  dispose() {\n    this._tokenizationRegistryListener.dispose();\n  }\n  getLoadStatus() {\n    const promises = [];\n    for (const nestedLanguageId in this._embeddedLanguages) {\n      const tokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n      if (tokenizationSupport) {\n        // The nested language is already loaded\n        if (tokenizationSupport instanceof MonarchTokenizer) {\n          const nestedModeStatus = tokenizationSupport.getLoadStatus();\n          if (nestedModeStatus.loaded === false) {\n            promises.push(nestedModeStatus.promise);\n          }\n        }\n        continue;\n      }\n      if (!languages.TokenizationRegistry.isResolved(nestedLanguageId)) {\n        // The nested language is in the process of being loaded\n        promises.push(languages.TokenizationRegistry.getOrCreate(nestedLanguageId));\n      }\n    }\n    if (promises.length === 0) {\n      return {\n        loaded: true\n      };\n    }\n    return {\n      loaded: false,\n      promise: Promise.all(promises).then(_ => undefined)\n    };\n  }\n  getInitialState() {\n    const rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n    return MonarchLineStateFactory.create(rootState, null);\n  }\n  tokenize(line, hasEOL, lineState) {\n    if (line.length >= this._maxTokenizationLineLength) {\n      return nullTokenize(this._languageId, lineState);\n    }\n    const tokensCollector = new MonarchClassicTokensCollector();\n    const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n    return tokensCollector.finalize(endLineState);\n  }\n  tokenizeEncoded(line, hasEOL, lineState) {\n    if (line.length >= this._maxTokenizationLineLength) {\n      return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), lineState);\n    }\n    const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);\n    const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n    return tokensCollector.finalize(endLineState);\n  }\n  _tokenize(line, hasEOL, lineState, collector) {\n    if (lineState.embeddedLanguageData) {\n      return this._nestedTokenize(line, hasEOL, lineState, 0, collector);\n    } else {\n      return this._myTokenize(line, hasEOL, lineState, 0, collector);\n    }\n  }\n  _findLeavingNestedLanguageOffset(line, state) {\n    let rules = this._lexer.tokenizer[state.stack.state];\n    if (!rules) {\n      rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n      if (!rules) {\n        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n      }\n    }\n    let popOffset = -1;\n    let hasEmbeddedPopRule = false;\n    for (const rule of rules) {\n      if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n        continue;\n      }\n      hasEmbeddedPopRule = true;\n      let regex = rule.regex;\n      const regexSource = rule.regex.source;\n      if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n        const flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n      }\n      const result = line.search(regex);\n      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {\n        continue;\n      }\n      if (popOffset === -1 || result < popOffset) {\n        popOffset = result;\n      }\n    }\n    if (!hasEmbeddedPopRule) {\n      throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n    }\n    return popOffset;\n  }\n  _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n    const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);\n    if (popOffset === -1) {\n      // tokenization will not leave nested language\n      const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);\n      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));\n    }\n    const nestedLanguageLine = line.substring(0, popOffset);\n    if (nestedLanguageLine.length > 0) {\n      // tokenize with the nested language\n      tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);\n    }\n    const restOfTheLine = line.substring(popOffset);\n    return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n  }\n  _safeRuleName(rule) {\n    if (rule) {\n      return rule.name;\n    }\n    return '(unknown)';\n  }\n  _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n    tokensCollector.enterLanguage(this._languageId);\n    const lineWithoutLFLength = lineWithoutLF.length;\n    const line = hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF;\n    const lineLength = line.length;\n    let embeddedLanguageData = lineState.embeddedLanguageData;\n    let stack = lineState.stack;\n    let pos = 0;\n    let groupMatching = null;\n    // See https://github.com/microsoft/monaco-editor/issues/1235\n    // Evaluate rules at least once for an empty line\n    let forceEvaluation = true;\n    while (forceEvaluation || pos < lineLength) {\n      const pos0 = pos;\n      const stackLen0 = stack.depth;\n      const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n      const state = stack.state;\n      let matches = null;\n      let matched = null;\n      let action = null;\n      let rule = null;\n      let enteringEmbeddedLanguage = null;\n      // check if we need to process group matches first\n      if (groupMatching) {\n        matches = groupMatching.matches;\n        const groupEntry = groupMatching.groups.shift();\n        matched = groupEntry.matched;\n        action = groupEntry.action;\n        rule = groupMatching.rule;\n        // cleanup if necessary\n        if (groupMatching.groups.length === 0) {\n          groupMatching = null;\n        }\n      } else {\n        // otherwise we match on the token stream\n        if (!forceEvaluation && pos >= lineLength) {\n          // nothing to do\n          break;\n        }\n        forceEvaluation = false;\n        // get the rules for this state\n        let rules = this._lexer.tokenizer[state];\n        if (!rules) {\n          rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n          if (!rules) {\n            throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n          }\n        }\n        // try each rule until we match\n        const restOfLine = line.substr(pos);\n        for (const rule of rules) {\n          if (pos === 0 || !rule.matchOnlyAtLineStart) {\n            matches = restOfLine.match(rule.regex);\n            if (matches) {\n              matched = matches[0];\n              action = rule.action;\n              break;\n            }\n          }\n        }\n      }\n      // We matched 'rule' with 'matches' and 'action'\n      if (!matches) {\n        matches = [''];\n        matched = '';\n      }\n      if (!action) {\n        // bad: we didn't match anything, and there is no action to take\n        // we need to advance the stream or we get progress trouble\n        if (pos < lineLength) {\n          matches = [line.charAt(pos)];\n          matched = matches[0];\n        }\n        action = this._lexer.defaultToken;\n      }\n      if (matched === null) {\n        // should never happen, needed for strict null checking\n        break;\n      }\n      // advance stream\n      pos += matched.length;\n      // maybe call action function (used for 'cases')\n      while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n        action = action.test(matched, matches, state, pos === lineLength);\n      }\n      let result = null;\n      // set the result: either a string or an array of actions\n      if (typeof action === 'string' || Array.isArray(action)) {\n        result = action;\n      } else if (action.group) {\n        result = action.group;\n      } else if (action.token !== null && action.token !== undefined) {\n        // do $n replacements?\n        if (action.tokenSubst) {\n          result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n        } else {\n          result = action.token;\n        }\n        // enter embedded language?\n        if (action.nextEmbedded) {\n          if (action.nextEmbedded === '@pop') {\n            if (!embeddedLanguageData) {\n              throw monarchCommon.createError(this._lexer, 'cannot pop embedded language if not inside one');\n            }\n            embeddedLanguageData = null;\n          } else if (embeddedLanguageData) {\n            throw monarchCommon.createError(this._lexer, 'cannot enter embedded language from within an embedded language');\n          } else {\n            enteringEmbeddedLanguage = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n          }\n        }\n        // state transformations\n        if (action.goBack) {\n          // back up the stream..\n          pos = Math.max(0, pos - action.goBack);\n        }\n        if (action.switchTo && typeof action.switchTo === 'string') {\n          let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n          if (nextState[0] === '@') {\n            nextState = nextState.substr(1); // peel off starting '@'\n          }\n\n          if (!monarchCommon.findRules(this._lexer, nextState)) {\n            throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n          } else {\n            stack = stack.switchTo(nextState);\n          }\n        } else if (action.transform && typeof action.transform === 'function') {\n          throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n        } else if (action.next) {\n          if (action.next === '@push') {\n            if (stack.depth >= this._lexer.maxStack) {\n              throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n            } else {\n              stack = stack.push(state);\n            }\n          } else if (action.next === '@pop') {\n            if (stack.depth <= 1) {\n              throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.pop();\n            }\n          } else if (action.next === '@popall') {\n            stack = stack.popall();\n          } else {\n            let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.push(nextState);\n            }\n          }\n        }\n        if (action.log && typeof action.log === 'string') {\n          monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n        }\n      }\n      // check result\n      if (result === null) {\n        throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n      }\n      const computeNewStateForEmbeddedLanguage = enteringEmbeddedLanguage => {\n        // support language names, mime types, and language ids\n        const languageId = this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage) || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage) || enteringEmbeddedLanguage;\n        const embeddedLanguageData = this._getNestedEmbeddedLanguageData(languageId);\n        if (pos < lineLength) {\n          // there is content from the embedded language on this line\n          const restOfLine = lineWithoutLF.substr(pos);\n          return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData), offsetDelta + pos, tokensCollector);\n        } else {\n          return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n        }\n      };\n      // is the result a group match?\n      if (Array.isArray(result)) {\n        if (groupMatching && groupMatching.groups.length > 0) {\n          throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n        }\n        if (matches.length !== result.length + 1) {\n          throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n        }\n        let totalLen = 0;\n        for (let i = 1; i < matches.length; i++) {\n          totalLen += matches[i].length;\n        }\n        if (totalLen !== matched.length) {\n          throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n        }\n        groupMatching = {\n          rule: rule,\n          matches: matches,\n          groups: []\n        };\n        for (let i = 0; i < result.length; i++) {\n          groupMatching.groups[i] = {\n            action: result[i],\n            matched: matches[i + 1]\n          };\n        }\n        pos -= matched.length;\n        // call recursively to initiate first result match\n        continue;\n      } else {\n        // regular result\n        // check for '@rematch'\n        if (result === '@rematch') {\n          pos -= matched.length;\n          matched = ''; // better set the next state too..\n          matches = null;\n          result = '';\n          // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n          // a state transition should occur.\n          if (enteringEmbeddedLanguage !== null) {\n            return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n          }\n        }\n        // check progress\n        if (matched.length === 0) {\n          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n            continue;\n          } else {\n            throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n          }\n        }\n        // return the result (and check for brace matching)\n        // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n        let tokenType = null;\n        if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n          const rest = result.substr('@brackets'.length);\n          const bracket = findBracket(this._lexer, matched);\n          if (!bracket) {\n            throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n          }\n          tokenType = monarchCommon.sanitize(bracket.token + rest);\n        } else {\n          const token = result === '' ? '' : result + this._lexer.tokenPostfix;\n          tokenType = monarchCommon.sanitize(token);\n        }\n        if (pos0 < lineWithoutLFLength) {\n          tokensCollector.emit(pos0 + offsetDelta, tokenType);\n        }\n      }\n      if (enteringEmbeddedLanguage !== null) {\n        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n      }\n    }\n    return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n  }\n  _getNestedEmbeddedLanguageData(languageId) {\n    if (!this._languageService.isRegisteredLanguageId(languageId)) {\n      return new EmbeddedLanguageData(languageId, NullState);\n    }\n    if (languageId !== this._languageId) {\n      // Fire language loading event\n      languages.TokenizationRegistry.getOrCreate(languageId);\n      this._embeddedLanguages[languageId] = true;\n    }\n    const tokenizationSupport = languages.TokenizationRegistry.get(languageId);\n    if (tokenizationSupport) {\n      return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());\n    }\n    return new EmbeddedLanguageData(languageId, NullState);\n  }\n};\nMonarchTokenizer = __decorate([__param(4, IConfigurationService)], MonarchTokenizer);\nexport { MonarchTokenizer };\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n  matched = monarchCommon.fixCase(lexer, matched);\n  const brackets = lexer.brackets;\n  for (const bracket of brackets) {\n    if (bracket.open === matched) {\n      return {\n        token: bracket.token,\n        bracketType: 1 /* monarchCommon.MonarchBracket.Open */\n      };\n    } else if (bracket.close === matched) {\n      return {\n        token: bracket.token,\n        bracketType: -1 /* monarchCommon.MonarchBracket.Close */\n      };\n    }\n  }\n\n  return null;\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","languages","NullState","nullTokenizeEncoded","nullTokenize","monarchCommon","IConfigurationService","CACHE_STACK_DEPTH","MonarchStackElementFactory","constructor","maxCacheDepth","_maxCacheDepth","_entries","create","parent","state","_INSTANCE","depth","MonarchStackElement","stackElementId","getStackElementId","result","element","_equals","a","b","equals","other","push","pop","popall","switchTo","EmbeddedLanguageData","languageId","clone","stateClone","MonarchLineStateFactory","stack","embeddedLanguageData","MonarchLineState","embeddedlanguageDataClone","MonarchClassicTokensCollector","_tokens","_languageId","_lastTokenType","_lastTokenLanguage","enterLanguage","emit","startOffset","type","Token","nestedLanguageTokenize","embeddedLanguageLine","hasEOL","offsetDelta","nestedLanguageId","embeddedModeState","nestedLanguageTokenizationSupport","TokenizationRegistry","get","nestedResult","tokenize","token","tokens","offset","language","concat","endState","finalize","TokenizationResult","MonarchModernTokensCollector","languageService","theme","_languageService","_theme","_prependTokens","_currentLanguageId","_lastTokenMetadata","languageIdCodec","encodeLanguageId","metadata","match","_merge","aLen","bLen","cLen","Uint32Array","set","tokenizeEncoded","len","EncodedTokenizationResult","MonarchTokenizer","standaloneThemeService","lexer","_configurationService","_standaloneThemeService","_lexer","_embeddedLanguages","embeddedLoaded","Promise","resolve","undefined","emitting","_tokenizationRegistryListener","onDidChange","e","isOneOfMyEmbeddedModes","changedLanguages","fire","_maxTokenizationLineLength","getValue","overrideIdentifier","onDidChangeConfiguration","affectsConfiguration","dispose","getLoadStatus","promises","tokenizationSupport","nestedModeStatus","loaded","promise","isResolved","getOrCreate","all","then","_","getInitialState","rootState","start","line","lineState","tokensCollector","endLineState","_tokenize","getColorTheme","tokenTheme","collector","_nestedTokenize","_myTokenize","_findLeavingNestedLanguageOffset","rules","tokenizer","findRules","createError","popOffset","hasEmbeddedPopRule","rule","isIAction","action","nextEmbedded","regex","regexSource","source","substr","flags","ignoreCase","unicode","RegExp","search","matchOnlyAtLineStart","nestedEndState","nestedLanguageLine","substring","restOfTheLine","_safeRuleName","name","lineWithoutLF","lineWithoutLFLength","includeLF","lineLength","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","groups","matches","matched","enteringEmbeddedLanguage","groupEntry","shift","restOfLine","charAt","defaultToken","isFuzzyAction","test","Array","isArray","group","tokenSubst","substituteMatches","goBack","Math","max","nextState","transform","next","maxStack","log","computeNewStateForEmbeddedLanguage","getLanguageIdByLanguageName","getLanguageIdByMimeType","_getNestedEmbeddedLanguageData","totalLen","tokenType","isString","indexOf","rest","bracket","findBracket","sanitize","tokenPostfix","isRegisteredLanguageId","fixCase","brackets","open","bracketType","close"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as languages from '../../../common/languages.js';\nimport { NullState, nullTokenizeEncoded, nullTokenize } from '../../../common/languages/nullTokenize.js';\nimport * as monarchCommon from './monarchCommon.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\nclass MonarchStackElementFactory {\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    static create(parent, state) {\n        return this._INSTANCE.create(parent, state);\n    }\n    create(parent, state) {\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchStackElement(parent, state);\n        }\n        let stackElementId = MonarchStackElement.getStackElementId(parent);\n        if (stackElementId.length > 0) {\n            stackElementId += '|';\n        }\n        stackElementId += state;\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchStackElement(parent, state);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\nclass MonarchStackElement {\n    constructor(parent, state) {\n        this.parent = parent;\n        this.state = state;\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\n    }\n    static getStackElementId(element) {\n        let result = '';\n        while (element !== null) {\n            if (result.length > 0) {\n                result += '|';\n            }\n            result += element.state;\n            element = element.parent;\n        }\n        return result;\n    }\n    static _equals(a, b) {\n        while (a !== null && b !== null) {\n            if (a === b) {\n                return true;\n            }\n            if (a.state !== b.state) {\n                return false;\n            }\n            a = a.parent;\n            b = b.parent;\n        }\n        if (a === null && b === null) {\n            return true;\n        }\n        return false;\n    }\n    equals(other) {\n        return MonarchStackElement._equals(this, other);\n    }\n    push(state) {\n        return MonarchStackElementFactory.create(this, state);\n    }\n    pop() {\n        return this.parent;\n    }\n    popall() {\n        let result = this;\n        while (result.parent) {\n            result = result.parent;\n        }\n        return result;\n    }\n    switchTo(state) {\n        return MonarchStackElementFactory.create(this.parent, state);\n    }\n}\nclass EmbeddedLanguageData {\n    constructor(languageId, state) {\n        this.languageId = languageId;\n        this.state = state;\n    }\n    equals(other) {\n        return (this.languageId === other.languageId\n            && this.state.equals(other.state));\n    }\n    clone() {\n        const stateClone = this.state.clone();\n        // save an object\n        if (stateClone === this.state) {\n            return this;\n        }\n        return new EmbeddedLanguageData(this.languageId, this.state);\n    }\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\nclass MonarchLineStateFactory {\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    static create(stack, embeddedLanguageData) {\n        return this._INSTANCE.create(stack, embeddedLanguageData);\n    }\n    create(stack, embeddedLanguageData) {\n        if (embeddedLanguageData !== null) {\n            // no caching when embedding\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        const stackElementId = MonarchStackElement.getStackElementId(stack);\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchLineState(stack, null);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\nclass MonarchLineState {\n    constructor(stack, embeddedLanguageData) {\n        this.stack = stack;\n        this.embeddedLanguageData = embeddedLanguageData;\n    }\n    clone() {\n        const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;\n        // save an object\n        if (embeddedlanguageDataClone === this.embeddedLanguageData) {\n            return this;\n        }\n        return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);\n    }\n    equals(other) {\n        if (!(other instanceof MonarchLineState)) {\n            return false;\n        }\n        if (!this.stack.equals(other.stack)) {\n            return false;\n        }\n        if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {\n            return true;\n        }\n        if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {\n            return false;\n        }\n        return this.embeddedLanguageData.equals(other.embeddedLanguageData);\n    }\n}\nclass MonarchClassicTokensCollector {\n    constructor() {\n        this._tokens = [];\n        this._languageId = null;\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n    }\n    enterLanguage(languageId) {\n        this._languageId = languageId;\n    }\n    emit(startOffset, type) {\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n            return;\n        }\n        this._lastTokenType = type;\n        this._lastTokenLanguage = this._languageId;\n        this._tokens.push(new languages.Token(startOffset, type, this._languageId));\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (const token of nestedResult.tokens) {\n                this._tokens.push(new languages.Token(token.offset + offsetDelta, token.type, token.language));\n            }\n        }\n        else {\n            this._tokens = this._tokens.concat(nestedResult.tokens);\n        }\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n        this._languageId = null;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.TokenizationResult(this._tokens, endState);\n    }\n}\nclass MonarchModernTokensCollector {\n    constructor(languageService, theme) {\n        this._languageService = languageService;\n        this._theme = theme;\n        this._prependTokens = null;\n        this._tokens = [];\n        this._currentLanguageId = 0 /* LanguageId.Null */;\n        this._lastTokenMetadata = 0;\n    }\n    enterLanguage(languageId) {\n        this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n    }\n    emit(startOffset, type) {\n        const metadata = this._theme.match(this._currentLanguageId, type);\n        if (this._lastTokenMetadata === metadata) {\n            return;\n        }\n        this._lastTokenMetadata = metadata;\n        this._tokens.push(startOffset);\n        this._tokens.push(metadata);\n    }\n    static _merge(a, b, c) {\n        const aLen = (a !== null ? a.length : 0);\n        const bLen = b.length;\n        const cLen = (c !== null ? c.length : 0);\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\n            return new Uint32Array(0);\n        }\n        if (aLen === 0 && bLen === 0) {\n            return c;\n        }\n        if (bLen === 0 && cLen === 0) {\n            return a;\n        }\n        const result = new Uint32Array(aLen + bLen + cLen);\n        if (a !== null) {\n            result.set(a);\n        }\n        for (let i = 0; i < bLen; i++) {\n            result[aLen + i] = b[i];\n        }\n        if (c !== null) {\n            result.set(c, aLen + bLen);\n        }\n        return result;\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {\n                nestedResult.tokens[i] += offsetDelta;\n            }\n        }\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n        this._tokens = [];\n        this._currentLanguageId = 0;\n        this._lastTokenMetadata = 0;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n    }\n}\nlet MonarchTokenizer = class MonarchTokenizer {\n    constructor(languageService, standaloneThemeService, languageId, lexer, _configurationService) {\n        this._configurationService = _configurationService;\n        this._languageService = languageService;\n        this._standaloneThemeService = standaloneThemeService;\n        this._languageId = languageId;\n        this._lexer = lexer;\n        this._embeddedLanguages = Object.create(null);\n        this.embeddedLoaded = Promise.resolve(undefined);\n        // Set up listening for embedded modes\n        let emitting = false;\n        this._tokenizationRegistryListener = languages.TokenizationRegistry.onDidChange((e) => {\n            if (emitting) {\n                return;\n            }\n            let isOneOfMyEmbeddedModes = false;\n            for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n                const language = e.changedLanguages[i];\n                if (this._embeddedLanguages[language]) {\n                    isOneOfMyEmbeddedModes = true;\n                    break;\n                }\n            }\n            if (isOneOfMyEmbeddedModes) {\n                emitting = true;\n                languages.TokenizationRegistry.fire([this._languageId]);\n                emitting = false;\n            }\n        });\n        this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n            overrideIdentifier: this._languageId\n        });\n        this._configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('editor.maxTokenizationLineLength')) {\n                this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n                    overrideIdentifier: this._languageId\n                });\n            }\n        });\n    }\n    dispose() {\n        this._tokenizationRegistryListener.dispose();\n    }\n    getLoadStatus() {\n        const promises = [];\n        for (const nestedLanguageId in this._embeddedLanguages) {\n            const tokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n            if (tokenizationSupport) {\n                // The nested language is already loaded\n                if (tokenizationSupport instanceof MonarchTokenizer) {\n                    const nestedModeStatus = tokenizationSupport.getLoadStatus();\n                    if (nestedModeStatus.loaded === false) {\n                        promises.push(nestedModeStatus.promise);\n                    }\n                }\n                continue;\n            }\n            if (!languages.TokenizationRegistry.isResolved(nestedLanguageId)) {\n                // The nested language is in the process of being loaded\n                promises.push(languages.TokenizationRegistry.getOrCreate(nestedLanguageId));\n            }\n        }\n        if (promises.length === 0) {\n            return {\n                loaded: true\n            };\n        }\n        return {\n            loaded: false,\n            promise: Promise.all(promises).then(_ => undefined)\n        };\n    }\n    getInitialState() {\n        const rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n        return MonarchLineStateFactory.create(rootState, null);\n    }\n    tokenize(line, hasEOL, lineState) {\n        if (line.length >= this._maxTokenizationLineLength) {\n            return nullTokenize(this._languageId, lineState);\n        }\n        const tokensCollector = new MonarchClassicTokensCollector();\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    tokenizeEncoded(line, hasEOL, lineState) {\n        if (line.length >= this._maxTokenizationLineLength) {\n            return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), lineState);\n        }\n        const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    _tokenize(line, hasEOL, lineState, collector) {\n        if (lineState.embeddedLanguageData) {\n            return this._nestedTokenize(line, hasEOL, lineState, 0, collector);\n        }\n        else {\n            return this._myTokenize(line, hasEOL, lineState, 0, collector);\n        }\n    }\n    _findLeavingNestedLanguageOffset(line, state) {\n        let rules = this._lexer.tokenizer[state.stack.state];\n        if (!rules) {\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n            if (!rules) {\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n            }\n        }\n        let popOffset = -1;\n        let hasEmbeddedPopRule = false;\n        for (const rule of rules) {\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n                continue;\n            }\n            hasEmbeddedPopRule = true;\n            let regex = rule.regex;\n            const regexSource = rule.regex.source;\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n                const flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n            }\n            const result = line.search(regex);\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\n                continue;\n            }\n            if (popOffset === -1 || result < popOffset) {\n                popOffset = result;\n            }\n        }\n        if (!hasEmbeddedPopRule) {\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n        }\n        return popOffset;\n    }\n    _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n        const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);\n        if (popOffset === -1) {\n            // tokenization will not leave nested language\n            const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));\n        }\n        const nestedLanguageLine = line.substring(0, popOffset);\n        if (nestedLanguageLine.length > 0) {\n            // tokenize with the nested language\n            tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);\n        }\n        const restOfTheLine = line.substring(popOffset);\n        return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n    }\n    _safeRuleName(rule) {\n        if (rule) {\n            return rule.name;\n        }\n        return '(unknown)';\n    }\n    _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n        tokensCollector.enterLanguage(this._languageId);\n        const lineWithoutLFLength = lineWithoutLF.length;\n        const line = (hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF);\n        const lineLength = line.length;\n        let embeddedLanguageData = lineState.embeddedLanguageData;\n        let stack = lineState.stack;\n        let pos = 0;\n        let groupMatching = null;\n        // See https://github.com/microsoft/monaco-editor/issues/1235\n        // Evaluate rules at least once for an empty line\n        let forceEvaluation = true;\n        while (forceEvaluation || pos < lineLength) {\n            const pos0 = pos;\n            const stackLen0 = stack.depth;\n            const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n            const state = stack.state;\n            let matches = null;\n            let matched = null;\n            let action = null;\n            let rule = null;\n            let enteringEmbeddedLanguage = null;\n            // check if we need to process group matches first\n            if (groupMatching) {\n                matches = groupMatching.matches;\n                const groupEntry = groupMatching.groups.shift();\n                matched = groupEntry.matched;\n                action = groupEntry.action;\n                rule = groupMatching.rule;\n                // cleanup if necessary\n                if (groupMatching.groups.length === 0) {\n                    groupMatching = null;\n                }\n            }\n            else {\n                // otherwise we match on the token stream\n                if (!forceEvaluation && pos >= lineLength) {\n                    // nothing to do\n                    break;\n                }\n                forceEvaluation = false;\n                // get the rules for this state\n                let rules = this._lexer.tokenizer[state];\n                if (!rules) {\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n                    if (!rules) {\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n                    }\n                }\n                // try each rule until we match\n                const restOfLine = line.substr(pos);\n                for (const rule of rules) {\n                    if (pos === 0 || !rule.matchOnlyAtLineStart) {\n                        matches = restOfLine.match(rule.regex);\n                        if (matches) {\n                            matched = matches[0];\n                            action = rule.action;\n                            break;\n                        }\n                    }\n                }\n            }\n            // We matched 'rule' with 'matches' and 'action'\n            if (!matches) {\n                matches = [''];\n                matched = '';\n            }\n            if (!action) {\n                // bad: we didn't match anything, and there is no action to take\n                // we need to advance the stream or we get progress trouble\n                if (pos < lineLength) {\n                    matches = [line.charAt(pos)];\n                    matched = matches[0];\n                }\n                action = this._lexer.defaultToken;\n            }\n            if (matched === null) {\n                // should never happen, needed for strict null checking\n                break;\n            }\n            // advance stream\n            pos += matched.length;\n            // maybe call action function (used for 'cases')\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n                action = action.test(matched, matches, state, pos === lineLength);\n            }\n            let result = null;\n            // set the result: either a string or an array of actions\n            if (typeof action === 'string' || Array.isArray(action)) {\n                result = action;\n            }\n            else if (action.group) {\n                result = action.group;\n            }\n            else if (action.token !== null && action.token !== undefined) {\n                // do $n replacements?\n                if (action.tokenSubst) {\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n                }\n                else {\n                    result = action.token;\n                }\n                // enter embedded language?\n                if (action.nextEmbedded) {\n                    if (action.nextEmbedded === '@pop') {\n                        if (!embeddedLanguageData) {\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded language if not inside one');\n                        }\n                        embeddedLanguageData = null;\n                    }\n                    else if (embeddedLanguageData) {\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded language from within an embedded language');\n                    }\n                    else {\n                        enteringEmbeddedLanguage = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n                    }\n                }\n                // state transformations\n                if (action.goBack) { // back up the stream..\n                    pos = Math.max(0, pos - action.goBack);\n                }\n                if (action.switchTo && typeof action.switchTo === 'string') {\n                    let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n                    if (nextState[0] === '@') {\n                        nextState = nextState.substr(1); // peel off starting '@'\n                    }\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                    }\n                    else {\n                        stack = stack.switchTo(nextState);\n                    }\n                }\n                else if (action.transform && typeof action.transform === 'function') {\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n                }\n                else if (action.next) {\n                    if (action.next === '@push') {\n                        if (stack.depth >= this._lexer.maxStack) {\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\n                                stack.state + ',' + stack.parent.state + ',...]');\n                        }\n                        else {\n                            stack = stack.push(state);\n                        }\n                    }\n                    else if (action.next === '@pop') {\n                        if (stack.depth <= 1) {\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.pop();\n                        }\n                    }\n                    else if (action.next === '@popall') {\n                        stack = stack.popall();\n                    }\n                    else {\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n                        if (nextState[0] === '@') {\n                            nextState = nextState.substr(1); // peel off starting '@'\n                        }\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.push(nextState);\n                        }\n                    }\n                }\n                if (action.log && typeof (action.log) === 'string') {\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n                }\n            }\n            // check result\n            if (result === null) {\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n            }\n            const computeNewStateForEmbeddedLanguage = (enteringEmbeddedLanguage) => {\n                // support language names, mime types, and language ids\n                const languageId = (this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage)\n                    || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage)\n                    || enteringEmbeddedLanguage);\n                const embeddedLanguageData = this._getNestedEmbeddedLanguageData(languageId);\n                if (pos < lineLength) {\n                    // there is content from the embedded language on this line\n                    const restOfLine = lineWithoutLF.substr(pos);\n                    return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData), offsetDelta + pos, tokensCollector);\n                }\n                else {\n                    return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n                }\n            };\n            // is the result a group match?\n            if (Array.isArray(result)) {\n                if (groupMatching && groupMatching.groups.length > 0) {\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n                }\n                if (matches.length !== result.length + 1) {\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n                }\n                let totalLen = 0;\n                for (let i = 1; i < matches.length; i++) {\n                    totalLen += matches[i].length;\n                }\n                if (totalLen !== matched.length) {\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n                }\n                groupMatching = {\n                    rule: rule,\n                    matches: matches,\n                    groups: []\n                };\n                for (let i = 0; i < result.length; i++) {\n                    groupMatching.groups[i] = {\n                        action: result[i],\n                        matched: matches[i + 1]\n                    };\n                }\n                pos -= matched.length;\n                // call recursively to initiate first result match\n                continue;\n            }\n            else {\n                // regular result\n                // check for '@rematch'\n                if (result === '@rematch') {\n                    pos -= matched.length;\n                    matched = ''; // better set the next state too..\n                    matches = null;\n                    result = '';\n                    // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n                    // a state transition should occur.\n                    if (enteringEmbeddedLanguage !== null) {\n                        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n                    }\n                }\n                // check progress\n                if (matched.length === 0) {\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n                        continue;\n                    }\n                    else {\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n                    }\n                }\n                // return the result (and check for brace matching)\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n                let tokenType = null;\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n                    const rest = result.substr('@brackets'.length);\n                    const bracket = findBracket(this._lexer, matched);\n                    if (!bracket) {\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n                    }\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\n                }\n                else {\n                    const token = (result === '' ? '' : result + this._lexer.tokenPostfix);\n                    tokenType = monarchCommon.sanitize(token);\n                }\n                if (pos0 < lineWithoutLFLength) {\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\n                }\n            }\n            if (enteringEmbeddedLanguage !== null) {\n                return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n            }\n        }\n        return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n    }\n    _getNestedEmbeddedLanguageData(languageId) {\n        if (!this._languageService.isRegisteredLanguageId(languageId)) {\n            return new EmbeddedLanguageData(languageId, NullState);\n        }\n        if (languageId !== this._languageId) {\n            // Fire language loading event\n            languages.TokenizationRegistry.getOrCreate(languageId);\n            this._embeddedLanguages[languageId] = true;\n        }\n        const tokenizationSupport = languages.TokenizationRegistry.get(languageId);\n        if (tokenizationSupport) {\n            return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());\n        }\n        return new EmbeddedLanguageData(languageId, NullState);\n    }\n};\nMonarchTokenizer = __decorate([\n    __param(4, IConfigurationService)\n], MonarchTokenizer);\nexport { MonarchTokenizer };\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\nfunction findBracket(lexer, matched) {\n    if (!matched) {\n        return null;\n    }\n    matched = monarchCommon.fixCase(lexer, matched);\n    const brackets = lexer.brackets;\n    for (const bracket of brackets) {\n        if (bracket.open === matched) {\n            return { token: bracket.token, bracketType: 1 /* monarchCommon.MonarchBracket.Open */ };\n        }\n        else if (bracket.close === matched) {\n            return { token: bracket.token, bracketType: -1 /* monarchCommon.MonarchBracket.Close */ };\n        }\n    }\n    return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}