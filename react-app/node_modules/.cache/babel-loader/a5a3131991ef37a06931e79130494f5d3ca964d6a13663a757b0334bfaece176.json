{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n  return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n  constructor(lines) {\n    const startColumns = [];\n    const endColumns = [];\n    for (let i = 0, length = lines.length; i < length; i++) {\n      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n      endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n    }\n    this.lines = lines;\n    this._startColumns = startColumns;\n    this._endColumns = endColumns;\n  }\n  getElements() {\n    const elements = [];\n    for (let i = 0, len = this.lines.length; i < len; i++) {\n      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n    }\n    return elements;\n  }\n  getStrictElement(index) {\n    return this.lines[index];\n  }\n  getStartLineNumber(i) {\n    return i + 1;\n  }\n  getEndLineNumber(i) {\n    return i + 1;\n  }\n  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n    const charCodes = [];\n    const lineNumbers = [];\n    const columns = [];\n    let len = 0;\n    for (let index = startIndex; index <= endIndex; index++) {\n      const lineContent = this.lines[index];\n      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;\n      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;\n      for (let col = startColumn; col < endColumn; col++) {\n        charCodes[len] = lineContent.charCodeAt(col - 1);\n        lineNumbers[len] = index + 1;\n        columns[len] = col;\n        len++;\n      }\n      if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n        // Add \\n if trim whitespace is not ignored\n        charCodes[len] = 10 /* CharCode.LineFeed */;\n        lineNumbers[len] = index + 1;\n        columns[len] = lineContent.length + 1;\n        len++;\n      }\n    }\n    return new CharSequence(charCodes, lineNumbers, columns);\n  }\n}\nclass CharSequence {\n  constructor(charCodes, lineNumbers, columns) {\n    this._charCodes = charCodes;\n    this._lineNumbers = lineNumbers;\n    this._columns = columns;\n  }\n  toString() {\n    return '[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']';\n  }\n  _assertIndex(index, arr) {\n    if (index < 0 || index >= arr.length) {\n      throw new Error(`Illegal index`);\n    }\n  }\n  getElements() {\n    return this._charCodes;\n  }\n  getStartLineNumber(i) {\n    if (i > 0 && i === this._lineNumbers.length) {\n      // the start line number of the element after the last element\n      // is the end line number of the last element\n      return this.getEndLineNumber(i - 1);\n    }\n    this._assertIndex(i, this._lineNumbers);\n    return this._lineNumbers[i];\n  }\n  getEndLineNumber(i) {\n    if (i === -1) {\n      // the end line number of the element before the first element\n      // is the start line number of the first element\n      return this.getStartLineNumber(i + 1);\n    }\n    this._assertIndex(i, this._lineNumbers);\n    if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n      return this._lineNumbers[i] + 1;\n    }\n    return this._lineNumbers[i];\n  }\n  getStartColumn(i) {\n    if (i > 0 && i === this._columns.length) {\n      // the start column of the element after the last element\n      // is the end column of the last element\n      return this.getEndColumn(i - 1);\n    }\n    this._assertIndex(i, this._columns);\n    return this._columns[i];\n  }\n  getEndColumn(i) {\n    if (i === -1) {\n      // the end column of the element before the first element\n      // is the start column of the first element\n      return this.getStartColumn(i + 1);\n    }\n    this._assertIndex(i, this._columns);\n    if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n      return 1;\n    }\n    return this._columns[i] + 1;\n  }\n}\nclass CharChange {\n  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalStartColumn = originalStartColumn;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.originalEndColumn = originalEndColumn;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedStartColumn = modifiedStartColumn;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.modifiedEndColumn = modifiedEndColumn;\n  }\n  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n    const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n    const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n    const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n    const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n    const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n    const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n  }\n}\nfunction postProcessCharChanges(rawChanges) {\n  if (rawChanges.length <= 1) {\n    return rawChanges;\n  }\n  const result = [rawChanges[0]];\n  let prevChange = result[0];\n  for (let i = 1, len = rawChanges.length; i < len; i++) {\n    const currChange = rawChanges[i];\n    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n    // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n      // Merge the current change into the previous one\n      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;\n      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;\n    } else {\n      // Add the current change\n      result.push(currChange);\n      prevChange = currChange;\n    }\n  }\n  return result;\n}\nclass LineChange {\n  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.charChanges = charChanges;\n  }\n  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n    let originalStartLineNumber;\n    let originalEndLineNumber;\n    let modifiedStartLineNumber;\n    let modifiedEndLineNumber;\n    let charChanges = undefined;\n    if (diffChange.originalLength === 0) {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n      originalEndLineNumber = 0;\n    } else {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    }\n    if (diffChange.modifiedLength === 0) {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n      modifiedEndLineNumber = 0;\n    } else {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    }\n    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n      // Compute character changes for diff chunks of at most 20 lines...\n      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n        let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n        if (shouldPostProcessCharChanges) {\n          rawChanges = postProcessCharChanges(rawChanges);\n        }\n        charChanges = [];\n        for (let i = 0, length = rawChanges.length; i < length; i++) {\n          charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n        }\n      }\n    }\n    return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n  }\n}\nexport class DiffComputer {\n  constructor(originalLines, modifiedLines, opts) {\n    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n    this.originalLines = originalLines;\n    this.modifiedLines = modifiedLines;\n    this.original = new LineSequence(originalLines);\n    this.modified = new LineSequence(modifiedLines);\n    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n  }\n\n  computeDiff() {\n    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n      // empty original => fast path\n      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n        return {\n          quitEarly: false,\n          changes: []\n        };\n      }\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: 1,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: this.modified.lines.length,\n          charChanges: [{\n            modifiedEndColumn: 0,\n            modifiedEndLineNumber: 0,\n            modifiedStartColumn: 0,\n            modifiedStartLineNumber: 0,\n            originalEndColumn: 0,\n            originalEndLineNumber: 0,\n            originalStartColumn: 0,\n            originalStartLineNumber: 0\n          }]\n        }]\n      };\n    }\n    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n      // empty modified => fast path\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: this.original.lines.length,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: 1,\n          charChanges: [{\n            modifiedEndColumn: 0,\n            modifiedEndLineNumber: 0,\n            modifiedStartColumn: 0,\n            modifiedStartLineNumber: 0,\n            originalEndColumn: 0,\n            originalEndLineNumber: 0,\n            originalStartColumn: 0,\n            originalStartLineNumber: 0\n          }]\n        }]\n      };\n    }\n    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n    const rawChanges = diffResult.changes;\n    const quitEarly = diffResult.quitEarly;\n    // The diff is always computed with ignoring trim whitespace\n    // This ensures we get the prettiest diff\n    if (this.shouldIgnoreTrimWhitespace) {\n      const lineChanges = [];\n      for (let i = 0, length = rawChanges.length; i < length; i++) {\n        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n      }\n      return {\n        quitEarly: quitEarly,\n        changes: lineChanges\n      };\n    }\n    // Need to post-process and introduce changes where the trim whitespace is different\n    // Note that we are looping starting at -1 to also cover the lines before the first change\n    const result = [];\n    let originalLineIndex = 0;\n    let modifiedLineIndex = 0;\n    for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;\n      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;\n      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;\n      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n        const originalLine = this.originalLines[originalLineIndex];\n        const modifiedLine = this.modifiedLines[modifiedLineIndex];\n        if (originalLine !== modifiedLine) {\n          // These lines differ only in trim whitespace\n          // Check the leading whitespace\n          {\n            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n            while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalStartColumn--;\n              modifiedStartColumn--;\n            }\n            if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n            }\n          }\n          // Check the trailing whitespace\n          {\n            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n            const originalMaxColumn = originalLine.length + 1;\n            const modifiedMaxColumn = modifiedLine.length + 1;\n            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalEndColumn++;\n              modifiedEndColumn++;\n            }\n            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n            }\n          }\n        }\n        originalLineIndex++;\n        modifiedLineIndex++;\n      }\n      if (nextChange) {\n        // Emit the actual change\n        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n        originalLineIndex += nextChange.originalLength;\n        modifiedLineIndex += nextChange.modifiedLength;\n      }\n    }\n    return {\n      quitEarly: quitEarly,\n      changes: result\n    };\n  }\n  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n      // Merged into previous\n      return;\n    }\n    let charChanges = undefined;\n    if (this.shouldComputeCharChanges) {\n      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n    }\n    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n  }\n  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    const len = result.length;\n    if (len === 0) {\n      return false;\n    }\n    const prevChange = result[len - 1];\n    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n      // Don't merge with inserts/deletes\n      return false;\n    }\n    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n      prevChange.originalEndLineNumber = originalLineNumber;\n      prevChange.modifiedEndLineNumber = modifiedLineNumber;\n      if (this.shouldComputeCharChanges && prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n      return true;\n    }\n    return false;\n  }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n  const r = strings.firstNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n  const r = strings.lastNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n  if (maximumRuntime === 0) {\n    return () => true;\n  }\n  const startTime = Date.now();\n  return () => {\n    return Date.now() - startTime < maximumRuntime;\n  };\n}","map":{"version":3,"names":["LcsDiff","strings","MINIMUM_MATCHING_CHARACTER_LENGTH","computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","diffAlgo","ComputeDiff","LineSequence","constructor","lines","startColumns","endColumns","i","length","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","elements","len","substring","getStrictElement","index","getStartLineNumber","getEndLineNumber","createCharSequence","shouldIgnoreTrimWhitespace","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","toString","map","s","idx","String","fromCharCode","join","_assertIndex","arr","Error","getStartColumn","getEndColumn","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","postProcessCharChanges","rawChanges","result","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","matchingLength","Math","min","push","LineChange","charChanges","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","undefined","changes","DiffComputer","originalLines","modifiedLines","opts","shouldMakePrettyDiff","original","modified","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","quitEarly","diffResult","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","originalChar","modifiedChar","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","firstNonWhitespaceIndex","lastNonWhitespaceIndex","maximumRuntime","startTime","Date","now"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,mCAAmC;AAC3D,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,MAAMC,iCAAiC,GAAG,CAAC;AAC3C,SAASC,WAAW,CAACC,gBAAgB,EAAEC,gBAAgB,EAAEC,2BAA2B,EAAEC,MAAM,EAAE;EAC1F,MAAMC,QAAQ,GAAG,IAAIR,OAAO,CAACI,gBAAgB,EAAEC,gBAAgB,EAAEC,2BAA2B,CAAC;EAC7F,OAAOE,QAAQ,CAACC,WAAW,CAACF,MAAM,CAAC;AACvC;AACA,MAAMG,YAAY,CAAC;EACfC,WAAW,CAACC,KAAK,EAAE;IACf,MAAMC,YAAY,GAAG,EAAE;IACvB,MAAMC,UAAU,GAAG,EAAE;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAGJ,KAAK,CAACI,MAAM,EAAED,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;MACpDF,YAAY,CAACE,CAAC,CAAC,GAAGE,sBAAsB,CAACL,KAAK,CAACG,CAAC,CAAC,EAAE,CAAC,CAAC;MACrDD,UAAU,CAACC,CAAC,CAAC,GAAGG,qBAAqB,CAACN,KAAK,CAACG,CAAC,CAAC,EAAE,CAAC,CAAC;IACtD;IACA,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACO,aAAa,GAAGN,YAAY;IACjC,IAAI,CAACO,WAAW,GAAGN,UAAU;EACjC;EACAO,WAAW,GAAG;IACV,MAAMC,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEQ,GAAG,GAAG,IAAI,CAACX,KAAK,CAACI,MAAM,EAAED,CAAC,GAAGQ,GAAG,EAAER,CAAC,EAAE,EAAE;MACnDO,QAAQ,CAACP,CAAC,CAAC,GAAG,IAAI,CAACH,KAAK,CAACG,CAAC,CAAC,CAACS,SAAS,CAAC,IAAI,CAACL,aAAa,CAACJ,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAACK,WAAW,CAACL,CAAC,CAAC,GAAG,CAAC,CAAC;IAC7F;IACA,OAAOO,QAAQ;EACnB;EACAG,gBAAgB,CAACC,KAAK,EAAE;IACpB,OAAO,IAAI,CAACd,KAAK,CAACc,KAAK,CAAC;EAC5B;EACAC,kBAAkB,CAACZ,CAAC,EAAE;IAClB,OAAOA,CAAC,GAAG,CAAC;EAChB;EACAa,gBAAgB,CAACb,CAAC,EAAE;IAChB,OAAOA,CAAC,GAAG,CAAC;EAChB;EACAc,kBAAkB,CAACC,0BAA0B,EAAEC,UAAU,EAAEC,QAAQ,EAAE;IACjE,MAAMC,SAAS,GAAG,EAAE;IACpB,MAAMC,WAAW,GAAG,EAAE;IACtB,MAAMC,OAAO,GAAG,EAAE;IAClB,IAAIZ,GAAG,GAAG,CAAC;IACX,KAAK,IAAIG,KAAK,GAAGK,UAAU,EAAEL,KAAK,IAAIM,QAAQ,EAAEN,KAAK,EAAE,EAAE;MACrD,MAAMU,WAAW,GAAG,IAAI,CAACxB,KAAK,CAACc,KAAK,CAAC;MACrC,MAAMW,WAAW,GAAIP,0BAA0B,GAAG,IAAI,CAACX,aAAa,CAACO,KAAK,CAAC,GAAG,CAAE;MAChF,MAAMY,SAAS,GAAIR,0BAA0B,GAAG,IAAI,CAACV,WAAW,CAACM,KAAK,CAAC,GAAGU,WAAW,CAACpB,MAAM,GAAG,CAAE;MACjG,KAAK,IAAIuB,GAAG,GAAGF,WAAW,EAAEE,GAAG,GAAGD,SAAS,EAAEC,GAAG,EAAE,EAAE;QAChDN,SAAS,CAACV,GAAG,CAAC,GAAGa,WAAW,CAACI,UAAU,CAACD,GAAG,GAAG,CAAC,CAAC;QAChDL,WAAW,CAACX,GAAG,CAAC,GAAGG,KAAK,GAAG,CAAC;QAC5BS,OAAO,CAACZ,GAAG,CAAC,GAAGgB,GAAG;QAClBhB,GAAG,EAAE;MACT;MACA,IAAI,CAACO,0BAA0B,IAAIJ,KAAK,GAAGM,QAAQ,EAAE;QACjD;QACAC,SAAS,CAACV,GAAG,CAAC,GAAG,EAAE,CAAC;QACpBW,WAAW,CAACX,GAAG,CAAC,GAAGG,KAAK,GAAG,CAAC;QAC5BS,OAAO,CAACZ,GAAG,CAAC,GAAGa,WAAW,CAACpB,MAAM,GAAG,CAAC;QACrCO,GAAG,EAAE;MACT;IACJ;IACA,OAAO,IAAIkB,YAAY,CAACR,SAAS,EAAEC,WAAW,EAAEC,OAAO,CAAC;EAC5D;AACJ;AACA,MAAMM,YAAY,CAAC;EACf9B,WAAW,CAACsB,SAAS,EAAEC,WAAW,EAAEC,OAAO,EAAE;IACzC,IAAI,CAACO,UAAU,GAAGT,SAAS;IAC3B,IAAI,CAACU,YAAY,GAAGT,WAAW;IAC/B,IAAI,CAACU,QAAQ,GAAGT,OAAO;EAC3B;EACAU,QAAQ,GAAG;IACP,OAAQ,GAAG,GAAG,IAAI,CAACH,UAAU,CAACI,GAAG,CAAC,CAACC,CAAC,EAAEC,GAAG,KAAK,CAACD,CAAC,KAAK,EAAE,CAAC,0BAA0B,KAAK,GAAGE,MAAM,CAACC,YAAY,CAACH,CAAC,CAAC,IAAK,KAAI,IAAI,CAACJ,YAAY,CAACK,GAAG,CAAE,IAAG,IAAI,CAACJ,QAAQ,CAACI,GAAG,CAAE,GAAE,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG;EAC9L;EACAC,YAAY,CAAC1B,KAAK,EAAE2B,GAAG,EAAE;IACrB,IAAI3B,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI2B,GAAG,CAACrC,MAAM,EAAE;MAClC,MAAM,IAAIsC,KAAK,CAAE,eAAc,CAAC;IACpC;EACJ;EACAjC,WAAW,GAAG;IACV,OAAO,IAAI,CAACqB,UAAU;EAC1B;EACAf,kBAAkB,CAACZ,CAAC,EAAE;IAClB,IAAIA,CAAC,GAAG,CAAC,IAAIA,CAAC,KAAK,IAAI,CAAC4B,YAAY,CAAC3B,MAAM,EAAE;MACzC;MACA;MACA,OAAO,IAAI,CAACY,gBAAgB,CAACb,CAAC,GAAG,CAAC,CAAC;IACvC;IACA,IAAI,CAACqC,YAAY,CAACrC,CAAC,EAAE,IAAI,CAAC4B,YAAY,CAAC;IACvC,OAAO,IAAI,CAACA,YAAY,CAAC5B,CAAC,CAAC;EAC/B;EACAa,gBAAgB,CAACb,CAAC,EAAE;IAChB,IAAIA,CAAC,KAAK,CAAC,CAAC,EAAE;MACV;MACA;MACA,OAAO,IAAI,CAACY,kBAAkB,CAACZ,CAAC,GAAG,CAAC,CAAC;IACzC;IACA,IAAI,CAACqC,YAAY,CAACrC,CAAC,EAAE,IAAI,CAAC4B,YAAY,CAAC;IACvC,IAAI,IAAI,CAACD,UAAU,CAAC3B,CAAC,CAAC,KAAK,EAAE,CAAC,yBAAyB;MACnD,OAAO,IAAI,CAAC4B,YAAY,CAAC5B,CAAC,CAAC,GAAG,CAAC;IACnC;IACA,OAAO,IAAI,CAAC4B,YAAY,CAAC5B,CAAC,CAAC;EAC/B;EACAwC,cAAc,CAACxC,CAAC,EAAE;IACd,IAAIA,CAAC,GAAG,CAAC,IAAIA,CAAC,KAAK,IAAI,CAAC6B,QAAQ,CAAC5B,MAAM,EAAE;MACrC;MACA;MACA,OAAO,IAAI,CAACwC,YAAY,CAACzC,CAAC,GAAG,CAAC,CAAC;IACnC;IACA,IAAI,CAACqC,YAAY,CAACrC,CAAC,EAAE,IAAI,CAAC6B,QAAQ,CAAC;IACnC,OAAO,IAAI,CAACA,QAAQ,CAAC7B,CAAC,CAAC;EAC3B;EACAyC,YAAY,CAACzC,CAAC,EAAE;IACZ,IAAIA,CAAC,KAAK,CAAC,CAAC,EAAE;MACV;MACA;MACA,OAAO,IAAI,CAACwC,cAAc,CAACxC,CAAC,GAAG,CAAC,CAAC;IACrC;IACA,IAAI,CAACqC,YAAY,CAACrC,CAAC,EAAE,IAAI,CAAC6B,QAAQ,CAAC;IACnC,IAAI,IAAI,CAACF,UAAU,CAAC3B,CAAC,CAAC,KAAK,EAAE,CAAC,yBAAyB;MACnD,OAAO,CAAC;IACZ;IACA,OAAO,IAAI,CAAC6B,QAAQ,CAAC7B,CAAC,CAAC,GAAG,CAAC;EAC/B;AACJ;AACA,MAAM0C,UAAU,CAAC;EACb9C,WAAW,CAAC+C,uBAAuB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAEC,uBAAuB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAE;IACxL,IAAI,CAACP,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACC,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;EAC9C;EACA,OAAOC,oBAAoB,CAACC,UAAU,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAE;IAChF,MAAMX,uBAAuB,GAAGU,oBAAoB,CAACzC,kBAAkB,CAACwC,UAAU,CAACG,aAAa,CAAC;IACjG,MAAMX,mBAAmB,GAAGS,oBAAoB,CAACb,cAAc,CAACY,UAAU,CAACG,aAAa,CAAC;IACzF,MAAMV,qBAAqB,GAAGQ,oBAAoB,CAACxC,gBAAgB,CAACuC,UAAU,CAACG,aAAa,GAAGH,UAAU,CAACI,cAAc,GAAG,CAAC,CAAC;IAC7H,MAAMV,iBAAiB,GAAGO,oBAAoB,CAACZ,YAAY,CAACW,UAAU,CAACG,aAAa,GAAGH,UAAU,CAACI,cAAc,GAAG,CAAC,CAAC;IACrH,MAAMT,uBAAuB,GAAGO,oBAAoB,CAAC1C,kBAAkB,CAACwC,UAAU,CAACK,aAAa,CAAC;IACjG,MAAMT,mBAAmB,GAAGM,oBAAoB,CAACd,cAAc,CAACY,UAAU,CAACK,aAAa,CAAC;IACzF,MAAMR,qBAAqB,GAAGK,oBAAoB,CAACzC,gBAAgB,CAACuC,UAAU,CAACK,aAAa,GAAGL,UAAU,CAACM,cAAc,GAAG,CAAC,CAAC;IAC7H,MAAMR,iBAAiB,GAAGI,oBAAoB,CAACb,YAAY,CAACW,UAAU,CAACK,aAAa,GAAGL,UAAU,CAACM,cAAc,GAAG,CAAC,CAAC;IACrH,OAAO,IAAIhB,UAAU,CAACC,uBAAuB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAEC,uBAAuB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,iBAAiB,CAAC;EACzM;AACJ;AACA,SAASS,sBAAsB,CAACC,UAAU,EAAE;EACxC,IAAIA,UAAU,CAAC3D,MAAM,IAAI,CAAC,EAAE;IACxB,OAAO2D,UAAU;EACrB;EACA,MAAMC,MAAM,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC,CAAC;EAC9B,IAAIE,UAAU,GAAGD,MAAM,CAAC,CAAC,CAAC;EAC1B,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEQ,GAAG,GAAGoD,UAAU,CAAC3D,MAAM,EAAED,CAAC,GAAGQ,GAAG,EAAER,CAAC,EAAE,EAAE;IACnD,MAAM+D,UAAU,GAAGH,UAAU,CAAC5D,CAAC,CAAC;IAChC,MAAMgE,sBAAsB,GAAGD,UAAU,CAACR,aAAa,IAAIO,UAAU,CAACP,aAAa,GAAGO,UAAU,CAACN,cAAc,CAAC;IAChH,MAAMS,sBAAsB,GAAGF,UAAU,CAACN,aAAa,IAAIK,UAAU,CAACL,aAAa,GAAGK,UAAU,CAACJ,cAAc,CAAC;IAChH;IACA,MAAMQ,cAAc,GAAGC,IAAI,CAACC,GAAG,CAACJ,sBAAsB,EAAEC,sBAAsB,CAAC;IAC/E,IAAIC,cAAc,GAAG/E,iCAAiC,EAAE;MACpD;MACA2E,UAAU,CAACN,cAAc,GAAIO,UAAU,CAACR,aAAa,GAAGQ,UAAU,CAACP,cAAc,GAAIM,UAAU,CAACP,aAAa;MAC7GO,UAAU,CAACJ,cAAc,GAAIK,UAAU,CAACN,aAAa,GAAGM,UAAU,CAACL,cAAc,GAAII,UAAU,CAACL,aAAa;IACjH,CAAC,MACI;MACD;MACAI,MAAM,CAACQ,IAAI,CAACN,UAAU,CAAC;MACvBD,UAAU,GAAGC,UAAU;IAC3B;EACJ;EACA,OAAOF,MAAM;AACjB;AACA,MAAMS,UAAU,CAAC;EACb1E,WAAW,CAAC+C,uBAAuB,EAAEE,qBAAqB,EAAEE,uBAAuB,EAAEE,qBAAqB,EAAEsB,WAAW,EAAE;IACrH,IAAI,CAAC5B,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACE,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACE,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACE,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACsB,WAAW,GAAGA,WAAW;EAClC;EACA,OAAOC,oBAAoB,CAACzD,0BAA0B,EAAEqC,UAAU,EAAEqB,oBAAoB,EAAEC,oBAAoB,EAAEC,gBAAgB,EAAEC,wBAAwB,EAAEC,4BAA4B,EAAE;IACtL,IAAIlC,uBAAuB;IAC3B,IAAIE,qBAAqB;IACzB,IAAIE,uBAAuB;IAC3B,IAAIE,qBAAqB;IACzB,IAAIsB,WAAW,GAAGO,SAAS;IAC3B,IAAI1B,UAAU,CAACI,cAAc,KAAK,CAAC,EAAE;MACjCb,uBAAuB,GAAG8B,oBAAoB,CAAC7D,kBAAkB,CAACwC,UAAU,CAACG,aAAa,CAAC,GAAG,CAAC;MAC/FV,qBAAqB,GAAG,CAAC;IAC7B,CAAC,MACI;MACDF,uBAAuB,GAAG8B,oBAAoB,CAAC7D,kBAAkB,CAACwC,UAAU,CAACG,aAAa,CAAC;MAC3FV,qBAAqB,GAAG4B,oBAAoB,CAAC5D,gBAAgB,CAACuC,UAAU,CAACG,aAAa,GAAGH,UAAU,CAACI,cAAc,GAAG,CAAC,CAAC;IAC3H;IACA,IAAIJ,UAAU,CAACM,cAAc,KAAK,CAAC,EAAE;MACjCX,uBAAuB,GAAG2B,oBAAoB,CAAC9D,kBAAkB,CAACwC,UAAU,CAACK,aAAa,CAAC,GAAG,CAAC;MAC/FR,qBAAqB,GAAG,CAAC;IAC7B,CAAC,MACI;MACDF,uBAAuB,GAAG2B,oBAAoB,CAAC9D,kBAAkB,CAACwC,UAAU,CAACK,aAAa,CAAC;MAC3FR,qBAAqB,GAAGyB,oBAAoB,CAAC7D,gBAAgB,CAACuC,UAAU,CAACK,aAAa,GAAGL,UAAU,CAACM,cAAc,GAAG,CAAC,CAAC;IAC3H;IACA,IAAIkB,wBAAwB,IAAIxB,UAAU,CAACI,cAAc,GAAG,CAAC,IAAIJ,UAAU,CAACI,cAAc,GAAG,EAAE,IAAIJ,UAAU,CAACM,cAAc,GAAG,CAAC,IAAIN,UAAU,CAACM,cAAc,GAAG,EAAE,IAAIiB,gBAAgB,EAAE,EAAE;MACtL;MACA,MAAMtB,oBAAoB,GAAGoB,oBAAoB,CAAC3D,kBAAkB,CAACC,0BAA0B,EAAEqC,UAAU,CAACG,aAAa,EAAEH,UAAU,CAACG,aAAa,GAAGH,UAAU,CAACI,cAAc,GAAG,CAAC,CAAC;MACpL,MAAMF,oBAAoB,GAAGoB,oBAAoB,CAAC5D,kBAAkB,CAACC,0BAA0B,EAAEqC,UAAU,CAACK,aAAa,EAAEL,UAAU,CAACK,aAAa,GAAGL,UAAU,CAACM,cAAc,GAAG,CAAC,CAAC;MACpL,IAAIL,oBAAoB,CAAC/C,WAAW,EAAE,CAACL,MAAM,GAAG,CAAC,IAAIqD,oBAAoB,CAAChD,WAAW,EAAE,CAACL,MAAM,GAAG,CAAC,EAAE;QAChG,IAAI2D,UAAU,GAAGxE,WAAW,CAACiE,oBAAoB,EAAEC,oBAAoB,EAAEqB,gBAAgB,EAAE,IAAI,CAAC,CAACI,OAAO;QACxG,IAAIF,4BAA4B,EAAE;UAC9BjB,UAAU,GAAGD,sBAAsB,CAACC,UAAU,CAAC;QACnD;QACAW,WAAW,GAAG,EAAE;QAChB,KAAK,IAAIvE,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAG2D,UAAU,CAAC3D,MAAM,EAAED,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;UACzDuE,WAAW,CAACF,IAAI,CAAC3B,UAAU,CAACS,oBAAoB,CAACS,UAAU,CAAC5D,CAAC,CAAC,EAAEqD,oBAAoB,EAAEC,oBAAoB,CAAC,CAAC;QAChH;MACJ;IACJ;IACA,OAAO,IAAIgB,UAAU,CAAC3B,uBAAuB,EAAEE,qBAAqB,EAAEE,uBAAuB,EAAEE,qBAAqB,EAAEsB,WAAW,CAAC;EACtI;AACJ;AACA,OAAO,MAAMS,YAAY,CAAC;EACtBpF,WAAW,CAACqF,aAAa,EAAEC,aAAa,EAAEC,IAAI,EAAE;IAC5C,IAAI,CAACP,wBAAwB,GAAGO,IAAI,CAACP,wBAAwB;IAC7D,IAAI,CAACC,4BAA4B,GAAGM,IAAI,CAACN,4BAA4B;IACrE,IAAI,CAAC9D,0BAA0B,GAAGoE,IAAI,CAACpE,0BAA0B;IACjE,IAAI,CAACqE,oBAAoB,GAAGD,IAAI,CAACC,oBAAoB;IACrD,IAAI,CAACH,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACG,QAAQ,GAAG,IAAI1F,YAAY,CAACsF,aAAa,CAAC;IAC/C,IAAI,CAACK,QAAQ,GAAG,IAAI3F,YAAY,CAACuF,aAAa,CAAC;IAC/C,IAAI,CAACK,gBAAgB,GAAGC,iCAAiC,CAACL,IAAI,CAACM,kBAAkB,CAAC;IAClF,IAAI,CAACd,gBAAgB,GAAGa,iCAAiC,CAACL,IAAI,CAACM,kBAAkB,KAAK,CAAC,GAAG,CAAC,GAAGtB,IAAI,CAACC,GAAG,CAACe,IAAI,CAACM,kBAAkB,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;EAC5I;;EACArG,WAAW,GAAG;IACV,IAAI,IAAI,CAACiG,QAAQ,CAACxF,KAAK,CAACI,MAAM,KAAK,CAAC,IAAI,IAAI,CAACoF,QAAQ,CAACxF,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,KAAK,CAAC,EAAE;MACzE;MACA,IAAI,IAAI,CAACqF,QAAQ,CAACzF,KAAK,CAACI,MAAM,KAAK,CAAC,IAAI,IAAI,CAACqF,QAAQ,CAACzF,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,KAAK,CAAC,EAAE;QACzE,OAAO;UACHyF,SAAS,EAAE,KAAK;UAChBX,OAAO,EAAE;QACb,CAAC;MACL;MACA,OAAO;QACHW,SAAS,EAAE,KAAK;QAChBX,OAAO,EAAE,CAAC;UACFpC,uBAAuB,EAAE,CAAC;UAC1BE,qBAAqB,EAAE,CAAC;UACxBE,uBAAuB,EAAE,CAAC;UAC1BE,qBAAqB,EAAE,IAAI,CAACqC,QAAQ,CAACzF,KAAK,CAACI,MAAM;UACjDsE,WAAW,EAAE,CAAC;YACNrB,iBAAiB,EAAE,CAAC;YACpBD,qBAAqB,EAAE,CAAC;YACxBD,mBAAmB,EAAE,CAAC;YACtBD,uBAAuB,EAAE,CAAC;YAC1BD,iBAAiB,EAAE,CAAC;YACpBD,qBAAqB,EAAE,CAAC;YACxBD,mBAAmB,EAAE,CAAC;YACtBD,uBAAuB,EAAE;UAC7B,CAAC;QACT,CAAC;MACT,CAAC;IACL;IACA,IAAI,IAAI,CAAC2C,QAAQ,CAACzF,KAAK,CAACI,MAAM,KAAK,CAAC,IAAI,IAAI,CAACqF,QAAQ,CAACzF,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,KAAK,CAAC,EAAE;MACzE;MACA,OAAO;QACHyF,SAAS,EAAE,KAAK;QAChBX,OAAO,EAAE,CAAC;UACFpC,uBAAuB,EAAE,CAAC;UAC1BE,qBAAqB,EAAE,IAAI,CAACwC,QAAQ,CAACxF,KAAK,CAACI,MAAM;UACjD8C,uBAAuB,EAAE,CAAC;UAC1BE,qBAAqB,EAAE,CAAC;UACxBsB,WAAW,EAAE,CAAC;YACNrB,iBAAiB,EAAE,CAAC;YACpBD,qBAAqB,EAAE,CAAC;YACxBD,mBAAmB,EAAE,CAAC;YACtBD,uBAAuB,EAAE,CAAC;YAC1BD,iBAAiB,EAAE,CAAC;YACpBD,qBAAqB,EAAE,CAAC;YACxBD,mBAAmB,EAAE,CAAC;YACtBD,uBAAuB,EAAE;UAC7B,CAAC;QACT,CAAC;MACT,CAAC;IACL;IACA,MAAMgD,UAAU,GAAGvG,WAAW,CAAC,IAAI,CAACiG,QAAQ,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACC,gBAAgB,EAAE,IAAI,CAACH,oBAAoB,CAAC;IAC9G,MAAMxB,UAAU,GAAG+B,UAAU,CAACZ,OAAO;IACrC,MAAMW,SAAS,GAAGC,UAAU,CAACD,SAAS;IACtC;IACA;IACA,IAAI,IAAI,CAAC3E,0BAA0B,EAAE;MACjC,MAAM6E,WAAW,GAAG,EAAE;MACtB,KAAK,IAAI5F,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAG2D,UAAU,CAAC3D,MAAM,EAAED,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;QACzD4F,WAAW,CAACvB,IAAI,CAACC,UAAU,CAACE,oBAAoB,CAAC,IAAI,CAACzD,0BAA0B,EAAE6C,UAAU,CAAC5D,CAAC,CAAC,EAAE,IAAI,CAACqF,QAAQ,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACX,gBAAgB,EAAE,IAAI,CAACC,wBAAwB,EAAE,IAAI,CAACC,4BAA4B,CAAC,CAAC;MAC5N;MACA,OAAO;QACHa,SAAS,EAAEA,SAAS;QACpBX,OAAO,EAAEa;MACb,CAAC;IACL;IACA;IACA;IACA,MAAM/B,MAAM,GAAG,EAAE;IACjB,IAAIgC,iBAAiB,GAAG,CAAC;IACzB,IAAIC,iBAAiB,GAAG,CAAC;IACzB,KAAK,IAAI9F,CAAC,GAAG,CAAC,CAAC,CAAC,YAAYQ,GAAG,GAAGoD,UAAU,CAAC3D,MAAM,EAAED,CAAC,GAAGQ,GAAG,EAAER,CAAC,EAAE,EAAE;MAC/D,MAAM+F,UAAU,GAAI/F,CAAC,GAAG,CAAC,GAAGQ,GAAG,GAAGoD,UAAU,CAAC5D,CAAC,GAAG,CAAC,CAAC,GAAG,IAAK;MAC3D,MAAMgG,YAAY,GAAID,UAAU,GAAGA,UAAU,CAACxC,aAAa,GAAG,IAAI,CAAC0B,aAAa,CAAChF,MAAO;MACxF,MAAMgG,YAAY,GAAIF,UAAU,GAAGA,UAAU,CAACtC,aAAa,GAAG,IAAI,CAACyB,aAAa,CAACjF,MAAO;MACxF,OAAO4F,iBAAiB,GAAGG,YAAY,IAAIF,iBAAiB,GAAGG,YAAY,EAAE;QACzE,MAAMC,YAAY,GAAG,IAAI,CAACjB,aAAa,CAACY,iBAAiB,CAAC;QAC1D,MAAMM,YAAY,GAAG,IAAI,CAACjB,aAAa,CAACY,iBAAiB,CAAC;QAC1D,IAAII,YAAY,KAAKC,YAAY,EAAE;UAC/B;UACA;UACA;YACI,IAAIvD,mBAAmB,GAAG1C,sBAAsB,CAACgG,YAAY,EAAE,CAAC,CAAC;YACjE,IAAIlD,mBAAmB,GAAG9C,sBAAsB,CAACiG,YAAY,EAAE,CAAC,CAAC;YACjE,OAAOvD,mBAAmB,GAAG,CAAC,IAAII,mBAAmB,GAAG,CAAC,EAAE;cACvD,MAAMoD,YAAY,GAAGF,YAAY,CAACzE,UAAU,CAACmB,mBAAmB,GAAG,CAAC,CAAC;cACrE,MAAMyD,YAAY,GAAGF,YAAY,CAAC1E,UAAU,CAACuB,mBAAmB,GAAG,CAAC,CAAC;cACrE,IAAIoD,YAAY,KAAKC,YAAY,EAAE;gBAC/B;cACJ;cACAzD,mBAAmB,EAAE;cACrBI,mBAAmB,EAAE;YACzB;YACA,IAAIJ,mBAAmB,GAAG,CAAC,IAAII,mBAAmB,GAAG,CAAC,EAAE;cACpD,IAAI,CAACsD,6BAA6B,CAACzC,MAAM,EAAEgC,iBAAiB,GAAG,CAAC,EAAE,CAAC,EAAEjD,mBAAmB,EAAEkD,iBAAiB,GAAG,CAAC,EAAE,CAAC,EAAE9C,mBAAmB,CAAC;YAC5I;UACJ;UACA;UACA;YACI,IAAIF,iBAAiB,GAAG3C,qBAAqB,CAAC+F,YAAY,EAAE,CAAC,CAAC;YAC9D,IAAIhD,iBAAiB,GAAG/C,qBAAqB,CAACgG,YAAY,EAAE,CAAC,CAAC;YAC9D,MAAMI,iBAAiB,GAAGL,YAAY,CAACjG,MAAM,GAAG,CAAC;YACjD,MAAMuG,iBAAiB,GAAGL,YAAY,CAAClG,MAAM,GAAG,CAAC;YACjD,OAAO6C,iBAAiB,GAAGyD,iBAAiB,IAAIrD,iBAAiB,GAAGsD,iBAAiB,EAAE;cACnF,MAAMJ,YAAY,GAAGF,YAAY,CAACzE,UAAU,CAACqB,iBAAiB,GAAG,CAAC,CAAC;cACnE,MAAMuD,YAAY,GAAGH,YAAY,CAACzE,UAAU,CAACyB,iBAAiB,GAAG,CAAC,CAAC;cACnE,IAAIkD,YAAY,KAAKC,YAAY,EAAE;gBAC/B;cACJ;cACAvD,iBAAiB,EAAE;cACnBI,iBAAiB,EAAE;YACvB;YACA,IAAIJ,iBAAiB,GAAGyD,iBAAiB,IAAIrD,iBAAiB,GAAGsD,iBAAiB,EAAE;cAChF,IAAI,CAACF,6BAA6B,CAACzC,MAAM,EAAEgC,iBAAiB,GAAG,CAAC,EAAE/C,iBAAiB,EAAEyD,iBAAiB,EAAET,iBAAiB,GAAG,CAAC,EAAE5C,iBAAiB,EAAEsD,iBAAiB,CAAC;YACxK;UACJ;QACJ;QACAX,iBAAiB,EAAE;QACnBC,iBAAiB,EAAE;MACvB;MACA,IAAIC,UAAU,EAAE;QACZ;QACAlC,MAAM,CAACQ,IAAI,CAACC,UAAU,CAACE,oBAAoB,CAAC,IAAI,CAACzD,0BAA0B,EAAEgF,UAAU,EAAE,IAAI,CAACV,QAAQ,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACX,gBAAgB,EAAE,IAAI,CAACC,wBAAwB,EAAE,IAAI,CAACC,4BAA4B,CAAC,CAAC;QAChNgB,iBAAiB,IAAIE,UAAU,CAACvC,cAAc;QAC9CsC,iBAAiB,IAAIC,UAAU,CAACrC,cAAc;MAClD;IACJ;IACA,OAAO;MACHgC,SAAS,EAAEA,SAAS;MACpBX,OAAO,EAAElB;IACb,CAAC;EACL;EACAyC,6BAA6B,CAACzC,MAAM,EAAE4C,kBAAkB,EAAE7D,mBAAmB,EAAEE,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAEE,iBAAiB,EAAE;IAC1J,IAAI,IAAI,CAACyD,8BAA8B,CAAC9C,MAAM,EAAE4C,kBAAkB,EAAE7D,mBAAmB,EAAEE,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAEE,iBAAiB,CAAC,EAAE;MACrK;MACA;IACJ;IACA,IAAIqB,WAAW,GAAGO,SAAS;IAC3B,IAAI,IAAI,CAACF,wBAAwB,EAAE;MAC/BL,WAAW,GAAG,CAAC,IAAI7B,UAAU,CAAC+D,kBAAkB,EAAE7D,mBAAmB,EAAE6D,kBAAkB,EAAE3D,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAE0D,kBAAkB,EAAExD,iBAAiB,CAAC,CAAC;IAClM;IACAW,MAAM,CAACQ,IAAI,CAAC,IAAIC,UAAU,CAACmC,kBAAkB,EAAEA,kBAAkB,EAAEC,kBAAkB,EAAEA,kBAAkB,EAAEnC,WAAW,CAAC,CAAC;EAC5H;EACAoC,8BAA8B,CAAC9C,MAAM,EAAE4C,kBAAkB,EAAE7D,mBAAmB,EAAEE,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAEE,iBAAiB,EAAE;IAC3J,MAAM1C,GAAG,GAAGqD,MAAM,CAAC5D,MAAM;IACzB,IAAIO,GAAG,KAAK,CAAC,EAAE;MACX,OAAO,KAAK;IAChB;IACA,MAAMsD,UAAU,GAAGD,MAAM,CAACrD,GAAG,GAAG,CAAC,CAAC;IAClC,IAAIsD,UAAU,CAACjB,qBAAqB,KAAK,CAAC,IAAIiB,UAAU,CAACb,qBAAqB,KAAK,CAAC,EAAE;MAClF;MACA,OAAO,KAAK;IAChB;IACA,IAAIa,UAAU,CAACjB,qBAAqB,GAAG,CAAC,KAAK4D,kBAAkB,IAAI3C,UAAU,CAACb,qBAAqB,GAAG,CAAC,KAAKyD,kBAAkB,EAAE;MAC5H5C,UAAU,CAACjB,qBAAqB,GAAG4D,kBAAkB;MACrD3C,UAAU,CAACb,qBAAqB,GAAGyD,kBAAkB;MACrD,IAAI,IAAI,CAAC9B,wBAAwB,IAAId,UAAU,CAACS,WAAW,EAAE;QACzDT,UAAU,CAACS,WAAW,CAACF,IAAI,CAAC,IAAI3B,UAAU,CAAC+D,kBAAkB,EAAE7D,mBAAmB,EAAE6D,kBAAkB,EAAE3D,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAE0D,kBAAkB,EAAExD,iBAAiB,CAAC,CAAC;MAC/M;MACA,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;AACJ;AACA,SAAShD,sBAAsB,CAAC0G,GAAG,EAAEC,YAAY,EAAE;EAC/C,MAAMC,CAAC,GAAG5H,OAAO,CAAC6H,uBAAuB,CAACH,GAAG,CAAC;EAC9C,IAAIE,CAAC,KAAK,CAAC,CAAC,EAAE;IACV,OAAOD,YAAY;EACvB;EACA,OAAOC,CAAC,GAAG,CAAC;AAChB;AACA,SAAS3G,qBAAqB,CAACyG,GAAG,EAAEC,YAAY,EAAE;EAC9C,MAAMC,CAAC,GAAG5H,OAAO,CAAC8H,sBAAsB,CAACJ,GAAG,CAAC;EAC7C,IAAIE,CAAC,KAAK,CAAC,CAAC,EAAE;IACV,OAAOD,YAAY;EACvB;EACA,OAAOC,CAAC,GAAG,CAAC;AAChB;AACA,SAAStB,iCAAiC,CAACyB,cAAc,EAAE;EACvD,IAAIA,cAAc,KAAK,CAAC,EAAE;IACtB,OAAO,MAAM,IAAI;EACrB;EACA,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAG,EAAE;EAC5B,OAAO,MAAM;IACT,OAAOD,IAAI,CAACC,GAAG,EAAE,GAAGF,SAAS,GAAGD,cAAc;EAClD,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}