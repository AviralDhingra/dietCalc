{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nexport class KeybindingResolver {\n  constructor(defaultKeybindings, overrides, log) {\n    this._log = log;\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n    for (const defaultKeybinding of defaultKeybindings) {\n      const command = defaultKeybinding.command;\n      if (command && command.charAt(0) !== '-') {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));\n    for (let i = 0, len = this._keybindings.length; i < len; i++) {\n      const k = this._keybindings[i];\n      if (k.keypressParts.length === 0) {\n        // unbound\n        continue;\n      }\n      if (k.when && k.when.type === 0 /* ContextKeyExprType.False */) {\n        // when condition is false\n        continue;\n      }\n      // TODO@chords\n      this._addKeyPress(k.keypressParts[0], k);\n    }\n  }\n  static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, when) {\n    // TODO@chords\n    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n      return false;\n    }\n    // TODO@chords\n    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n      return false;\n    }\n    if (when) {\n      if (!defaultKb.when) {\n        return false;\n      }\n      if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Looks for rules containing \"-commandId\" and removes them.\n   */\n  static handleRemovals(rules) {\n    // Do a first pass and construct a hash-map for removals\n    const removals = new Map();\n    for (let i = 0, len = rules.length; i < len; i++) {\n      const rule = rules[i];\n      if (rule.command && rule.command.charAt(0) === '-') {\n        const command = rule.command.substring(1);\n        if (!removals.has(command)) {\n          removals.set(command, [rule]);\n        } else {\n          removals.get(command).push(rule);\n        }\n      }\n    }\n    if (removals.size === 0) {\n      // There are no removals\n      return rules;\n    }\n    // Do a second pass and keep only non-removed keybindings\n    const result = [];\n    for (let i = 0, len = rules.length; i < len; i++) {\n      const rule = rules[i];\n      if (!rule.command || rule.command.length === 0) {\n        result.push(rule);\n        continue;\n      }\n      if (rule.command.charAt(0) === '-') {\n        continue;\n      }\n      const commandRemovals = removals.get(rule.command);\n      if (!commandRemovals || !rule.isDefault) {\n        result.push(rule);\n        continue;\n      }\n      let isRemoved = false;\n      for (const commandRemoval of commandRemovals) {\n        // TODO@chords\n        const keypressFirstPart = commandRemoval.keypressParts[0];\n        const keypressChordPart = commandRemoval.keypressParts[1];\n        const when = commandRemoval.when;\n        if (this._isTargetedForRemoval(rule, keypressFirstPart, keypressChordPart, when)) {\n          isRemoved = true;\n          break;\n        }\n      }\n      if (!isRemoved) {\n        result.push(rule);\n        continue;\n      }\n    }\n    return result;\n  }\n  _addKeyPress(keypress, item) {\n    const conflicts = this._map.get(keypress);\n    if (typeof conflicts === 'undefined') {\n      // There is no conflict so far\n      this._map.set(keypress, [item]);\n      this._addToLookupMap(item);\n      return;\n    }\n    for (let i = conflicts.length - 1; i >= 0; i--) {\n      const conflict = conflicts[i];\n      if (conflict.command === item.command) {\n        continue;\n      }\n      const conflictIsChord = conflict.keypressParts.length > 1;\n      const itemIsChord = item.keypressParts.length > 1;\n      // TODO@chords\n      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n        // The conflict only shares the chord start with this command\n        continue;\n      }\n      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n        // `item` completely overwrites `conflict`\n        // Remove conflict from the lookupMap\n        this._removeFromLookupMap(conflict);\n      }\n    }\n    conflicts.push(item);\n    this._addToLookupMap(item);\n  }\n  _addToLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n    let arr = this._lookupMap.get(item.command);\n    if (typeof arr === 'undefined') {\n      arr = [item];\n      this._lookupMap.set(item.command, arr);\n    } else {\n      arr.push(item);\n    }\n  }\n  _removeFromLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n    const arr = this._lookupMap.get(item.command);\n    if (typeof arr === 'undefined') {\n      return;\n    }\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === item) {\n        arr.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Returns true if it is provable `a` implies `b`.\n   */\n  static whenIsEntirelyIncluded(a, b) {\n    if (!b || b.type === 1 /* ContextKeyExprType.True */) {\n      return true;\n    }\n    if (!a || a.type === 1 /* ContextKeyExprType.True */) {\n      return false;\n    }\n    return implies(a, b);\n  }\n  getKeybindings() {\n    return this._keybindings;\n  }\n  lookupPrimaryKeybinding(commandId, context) {\n    const items = this._lookupMap.get(commandId);\n    if (typeof items === 'undefined' || items.length === 0) {\n      return null;\n    }\n    if (items.length === 1) {\n      return items[0];\n    }\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      if (context.contextMatchesRules(item.when)) {\n        return item;\n      }\n    }\n    return items[items.length - 1];\n  }\n  resolve(context, currentChord, keypress) {\n    this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);\n    let lookupMap = null;\n    if (currentChord !== null) {\n      // Fetch all chord bindings for `currentChord`\n      const candidates = this._map.get(currentChord);\n      if (typeof candidates === 'undefined') {\n        // No chords starting with `currentChord`\n        this._log(`\\\\ No keybinding entries.`);\n        return null;\n      }\n      lookupMap = [];\n      for (let i = 0, len = candidates.length; i < len; i++) {\n        const candidate = candidates[i];\n        // TODO@chords\n        if (candidate.keypressParts[1] === keypress) {\n          lookupMap.push(candidate);\n        }\n      }\n    } else {\n      const candidates = this._map.get(keypress);\n      if (typeof candidates === 'undefined') {\n        // No bindings with `keypress`\n        this._log(`\\\\ No keybinding entries.`);\n        return null;\n      }\n      lookupMap = candidates;\n    }\n    const result = this._findCommand(context, lookupMap);\n    if (!result) {\n      this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n      return null;\n    }\n    // TODO@chords\n    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n      this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n      return {\n        enterChord: true,\n        leaveChord: false,\n        commandId: null,\n        commandArgs: null,\n        bubble: false\n      };\n    }\n    this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n    return {\n      enterChord: false,\n      leaveChord: result.keypressParts.length > 1,\n      commandId: result.command,\n      commandArgs: result.commandArgs,\n      bubble: result.bubble\n    };\n  }\n  _findCommand(context, matches) {\n    for (let i = matches.length - 1; i >= 0; i--) {\n      const k = matches[i];\n      if (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n        continue;\n      }\n      return k;\n    }\n    return null;\n  }\n  static _contextMatchesRules(context, rules) {\n    if (!rules) {\n      return true;\n    }\n    return rules.evaluate(context);\n  }\n}\nfunction printWhenExplanation(when) {\n  if (!when) {\n    return `no when condition`;\n  }\n  return `${when.serialize()}`;\n}\nfunction printSourceExplanation(kb) {\n  return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? `built-in` : `user`;\n}","map":{"version":3,"names":["implies","expressionsAreEqualWithConstantSubstitution","KeybindingResolver","constructor","defaultKeybindings","overrides","log","_log","_defaultKeybindings","_defaultBoundCommands","Map","defaultKeybinding","command","charAt","set","_map","_lookupMap","_keybindings","handleRemovals","concat","i","len","length","k","keypressParts","when","type","_addKeyPress","_isTargetedForRemoval","defaultKb","keypressFirstPart","keypressChordPart","rules","removals","rule","substring","has","get","push","size","result","commandRemovals","isDefault","isRemoved","commandRemoval","keypress","item","conflicts","_addToLookupMap","conflict","conflictIsChord","itemIsChord","whenIsEntirelyIncluded","_removeFromLookupMap","arr","splice","a","b","getKeybindings","lookupPrimaryKeybinding","commandId","context","items","contextMatchesRules","resolve","currentChord","lookupMap","candidates","candidate","_findCommand","printWhenExplanation","printSourceExplanation","enterChord","leaveChord","commandArgs","bubble","matches","_contextMatchesRules","evaluate","serialize","kb","extensionId","isBuiltinExtension"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nexport class KeybindingResolver {\n    constructor(defaultKeybindings, overrides, log) {\n        this._log = log;\n        this._defaultKeybindings = defaultKeybindings;\n        this._defaultBoundCommands = new Map();\n        for (const defaultKeybinding of defaultKeybindings) {\n            const command = defaultKeybinding.command;\n            if (command && command.charAt(0) !== '-') {\n                this._defaultBoundCommands.set(command, true);\n            }\n        }\n        this._map = new Map();\n        this._lookupMap = new Map();\n        this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));\n        for (let i = 0, len = this._keybindings.length; i < len; i++) {\n            const k = this._keybindings[i];\n            if (k.keypressParts.length === 0) {\n                // unbound\n                continue;\n            }\n            if (k.when && k.when.type === 0 /* ContextKeyExprType.False */) {\n                // when condition is false\n                continue;\n            }\n            // TODO@chords\n            this._addKeyPress(k.keypressParts[0], k);\n        }\n    }\n    static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, when) {\n        // TODO@chords\n        if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n            return false;\n        }\n        // TODO@chords\n        if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n            return false;\n        }\n        if (when) {\n            if (!defaultKb.when) {\n                return false;\n            }\n            if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Looks for rules containing \"-commandId\" and removes them.\n     */\n    static handleRemovals(rules) {\n        // Do a first pass and construct a hash-map for removals\n        const removals = new Map();\n        for (let i = 0, len = rules.length; i < len; i++) {\n            const rule = rules[i];\n            if (rule.command && rule.command.charAt(0) === '-') {\n                const command = rule.command.substring(1);\n                if (!removals.has(command)) {\n                    removals.set(command, [rule]);\n                }\n                else {\n                    removals.get(command).push(rule);\n                }\n            }\n        }\n        if (removals.size === 0) {\n            // There are no removals\n            return rules;\n        }\n        // Do a second pass and keep only non-removed keybindings\n        const result = [];\n        for (let i = 0, len = rules.length; i < len; i++) {\n            const rule = rules[i];\n            if (!rule.command || rule.command.length === 0) {\n                result.push(rule);\n                continue;\n            }\n            if (rule.command.charAt(0) === '-') {\n                continue;\n            }\n            const commandRemovals = removals.get(rule.command);\n            if (!commandRemovals || !rule.isDefault) {\n                result.push(rule);\n                continue;\n            }\n            let isRemoved = false;\n            for (const commandRemoval of commandRemovals) {\n                // TODO@chords\n                const keypressFirstPart = commandRemoval.keypressParts[0];\n                const keypressChordPart = commandRemoval.keypressParts[1];\n                const when = commandRemoval.when;\n                if (this._isTargetedForRemoval(rule, keypressFirstPart, keypressChordPart, when)) {\n                    isRemoved = true;\n                    break;\n                }\n            }\n            if (!isRemoved) {\n                result.push(rule);\n                continue;\n            }\n        }\n        return result;\n    }\n    _addKeyPress(keypress, item) {\n        const conflicts = this._map.get(keypress);\n        if (typeof conflicts === 'undefined') {\n            // There is no conflict so far\n            this._map.set(keypress, [item]);\n            this._addToLookupMap(item);\n            return;\n        }\n        for (let i = conflicts.length - 1; i >= 0; i--) {\n            const conflict = conflicts[i];\n            if (conflict.command === item.command) {\n                continue;\n            }\n            const conflictIsChord = (conflict.keypressParts.length > 1);\n            const itemIsChord = (item.keypressParts.length > 1);\n            // TODO@chords\n            if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n                // The conflict only shares the chord start with this command\n                continue;\n            }\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n                // `item` completely overwrites `conflict`\n                // Remove conflict from the lookupMap\n                this._removeFromLookupMap(conflict);\n            }\n        }\n        conflicts.push(item);\n        this._addToLookupMap(item);\n    }\n    _addToLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        let arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            arr = [item];\n            this._lookupMap.set(item.command, arr);\n        }\n        else {\n            arr.push(item);\n        }\n    }\n    _removeFromLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        const arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            return;\n        }\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] === item) {\n                arr.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Returns true if it is provable `a` implies `b`.\n     */\n    static whenIsEntirelyIncluded(a, b) {\n        if (!b || b.type === 1 /* ContextKeyExprType.True */) {\n            return true;\n        }\n        if (!a || a.type === 1 /* ContextKeyExprType.True */) {\n            return false;\n        }\n        return implies(a, b);\n    }\n    getKeybindings() {\n        return this._keybindings;\n    }\n    lookupPrimaryKeybinding(commandId, context) {\n        const items = this._lookupMap.get(commandId);\n        if (typeof items === 'undefined' || items.length === 0) {\n            return null;\n        }\n        if (items.length === 1) {\n            return items[0];\n        }\n        for (let i = items.length - 1; i >= 0; i--) {\n            const item = items[i];\n            if (context.contextMatchesRules(item.when)) {\n                return item;\n            }\n        }\n        return items[items.length - 1];\n    }\n    resolve(context, currentChord, keypress) {\n        this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);\n        let lookupMap = null;\n        if (currentChord !== null) {\n            // Fetch all chord bindings for `currentChord`\n            const candidates = this._map.get(currentChord);\n            if (typeof candidates === 'undefined') {\n                // No chords starting with `currentChord`\n                this._log(`\\\\ No keybinding entries.`);\n                return null;\n            }\n            lookupMap = [];\n            for (let i = 0, len = candidates.length; i < len; i++) {\n                const candidate = candidates[i];\n                // TODO@chords\n                if (candidate.keypressParts[1] === keypress) {\n                    lookupMap.push(candidate);\n                }\n            }\n        }\n        else {\n            const candidates = this._map.get(keypress);\n            if (typeof candidates === 'undefined') {\n                // No bindings with `keypress`\n                this._log(`\\\\ No keybinding entries.`);\n                return null;\n            }\n            lookupMap = candidates;\n        }\n        const result = this._findCommand(context, lookupMap);\n        if (!result) {\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n            return null;\n        }\n        // TODO@chords\n        if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n            return {\n                enterChord: true,\n                leaveChord: false,\n                commandId: null,\n                commandArgs: null,\n                bubble: false\n            };\n        }\n        this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n        return {\n            enterChord: false,\n            leaveChord: result.keypressParts.length > 1,\n            commandId: result.command,\n            commandArgs: result.commandArgs,\n            bubble: result.bubble\n        };\n    }\n    _findCommand(context, matches) {\n        for (let i = matches.length - 1; i >= 0; i--) {\n            const k = matches[i];\n            if (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n                continue;\n            }\n            return k;\n        }\n        return null;\n    }\n    static _contextMatchesRules(context, rules) {\n        if (!rules) {\n            return true;\n        }\n        return rules.evaluate(context);\n    }\n}\nfunction printWhenExplanation(when) {\n    if (!when) {\n        return `no when condition`;\n    }\n    return `${when.serialize()}`;\n}\nfunction printSourceExplanation(kb) {\n    return (kb.extensionId\n        ? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n        : (kb.isDefault ? `built-in` : `user`));\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,OAAO,EAAEC,2CAA2C,QAAQ,uCAAuC;AAC5G,OAAO,MAAMC,kBAAkB,CAAC;EAC5BC,WAAW,CAACC,kBAAkB,EAAEC,SAAS,EAAEC,GAAG,EAAE;IAC5C,IAAI,CAACC,IAAI,GAAGD,GAAG;IACf,IAAI,CAACE,mBAAmB,GAAGJ,kBAAkB;IAC7C,IAAI,CAACK,qBAAqB,GAAG,IAAIC,GAAG,EAAE;IACtC,KAAK,MAAMC,iBAAiB,IAAIP,kBAAkB,EAAE;MAChD,MAAMQ,OAAO,GAAGD,iBAAiB,CAACC,OAAO;MACzC,IAAIA,OAAO,IAAIA,OAAO,CAACC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACtC,IAAI,CAACJ,qBAAqB,CAACK,GAAG,CAACF,OAAO,EAAE,IAAI,CAAC;MACjD;IACJ;IACA,IAAI,CAACG,IAAI,GAAG,IAAIL,GAAG,EAAE;IACrB,IAAI,CAACM,UAAU,GAAG,IAAIN,GAAG,EAAE;IAC3B,IAAI,CAACO,YAAY,GAAGf,kBAAkB,CAACgB,cAAc,CAAC,EAAE,CAACC,MAAM,CAACf,kBAAkB,CAAC,CAACe,MAAM,CAACd,SAAS,CAAC,CAAC;IACtG,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACJ,YAAY,CAACK,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC1D,MAAMG,CAAC,GAAG,IAAI,CAACN,YAAY,CAACG,CAAC,CAAC;MAC9B,IAAIG,CAAC,CAACC,aAAa,CAACF,MAAM,KAAK,CAAC,EAAE;QAC9B;QACA;MACJ;MACA,IAAIC,CAAC,CAACE,IAAI,IAAIF,CAAC,CAACE,IAAI,CAACC,IAAI,KAAK,CAAC,CAAC,gCAAgC;QAC5D;QACA;MACJ;MACA;MACA,IAAI,CAACC,YAAY,CAACJ,CAAC,CAACC,aAAa,CAAC,CAAC,CAAC,EAAED,CAAC,CAAC;IAC5C;EACJ;EACA,OAAOK,qBAAqB,CAACC,SAAS,EAAEC,iBAAiB,EAAEC,iBAAiB,EAAEN,IAAI,EAAE;IAChF;IACA,IAAIK,iBAAiB,IAAID,SAAS,CAACL,aAAa,CAAC,CAAC,CAAC,KAAKM,iBAAiB,EAAE;MACvE,OAAO,KAAK;IAChB;IACA;IACA,IAAIC,iBAAiB,IAAIF,SAAS,CAACL,aAAa,CAAC,CAAC,CAAC,KAAKO,iBAAiB,EAAE;MACvE,OAAO,KAAK;IAChB;IACA,IAAIN,IAAI,EAAE;MACN,IAAI,CAACI,SAAS,CAACJ,IAAI,EAAE;QACjB,OAAO,KAAK;MAChB;MACA,IAAI,CAACxB,2CAA2C,CAACwB,IAAI,EAAEI,SAAS,CAACJ,IAAI,CAAC,EAAE;QACpE,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACI,OAAOP,cAAc,CAACc,KAAK,EAAE;IACzB;IACA,MAAMC,QAAQ,GAAG,IAAIvB,GAAG,EAAE;IAC1B,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGW,KAAK,CAACV,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC9C,MAAMc,IAAI,GAAGF,KAAK,CAACZ,CAAC,CAAC;MACrB,IAAIc,IAAI,CAACtB,OAAO,IAAIsB,IAAI,CAACtB,OAAO,CAACC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAChD,MAAMD,OAAO,GAAGsB,IAAI,CAACtB,OAAO,CAACuB,SAAS,CAAC,CAAC,CAAC;QACzC,IAAI,CAACF,QAAQ,CAACG,GAAG,CAACxB,OAAO,CAAC,EAAE;UACxBqB,QAAQ,CAACnB,GAAG,CAACF,OAAO,EAAE,CAACsB,IAAI,CAAC,CAAC;QACjC,CAAC,MACI;UACDD,QAAQ,CAACI,GAAG,CAACzB,OAAO,CAAC,CAAC0B,IAAI,CAACJ,IAAI,CAAC;QACpC;MACJ;IACJ;IACA,IAAID,QAAQ,CAACM,IAAI,KAAK,CAAC,EAAE;MACrB;MACA,OAAOP,KAAK;IAChB;IACA;IACA,MAAMQ,MAAM,GAAG,EAAE;IACjB,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGW,KAAK,CAACV,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC9C,MAAMc,IAAI,GAAGF,KAAK,CAACZ,CAAC,CAAC;MACrB,IAAI,CAACc,IAAI,CAACtB,OAAO,IAAIsB,IAAI,CAACtB,OAAO,CAACU,MAAM,KAAK,CAAC,EAAE;QAC5CkB,MAAM,CAACF,IAAI,CAACJ,IAAI,CAAC;QACjB;MACJ;MACA,IAAIA,IAAI,CAACtB,OAAO,CAACC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAChC;MACJ;MACA,MAAM4B,eAAe,GAAGR,QAAQ,CAACI,GAAG,CAACH,IAAI,CAACtB,OAAO,CAAC;MAClD,IAAI,CAAC6B,eAAe,IAAI,CAACP,IAAI,CAACQ,SAAS,EAAE;QACrCF,MAAM,CAACF,IAAI,CAACJ,IAAI,CAAC;QACjB;MACJ;MACA,IAAIS,SAAS,GAAG,KAAK;MACrB,KAAK,MAAMC,cAAc,IAAIH,eAAe,EAAE;QAC1C;QACA,MAAMX,iBAAiB,GAAGc,cAAc,CAACpB,aAAa,CAAC,CAAC,CAAC;QACzD,MAAMO,iBAAiB,GAAGa,cAAc,CAACpB,aAAa,CAAC,CAAC,CAAC;QACzD,MAAMC,IAAI,GAAGmB,cAAc,CAACnB,IAAI;QAChC,IAAI,IAAI,CAACG,qBAAqB,CAACM,IAAI,EAAEJ,iBAAiB,EAAEC,iBAAiB,EAAEN,IAAI,CAAC,EAAE;UAC9EkB,SAAS,GAAG,IAAI;UAChB;QACJ;MACJ;MACA,IAAI,CAACA,SAAS,EAAE;QACZH,MAAM,CAACF,IAAI,CAACJ,IAAI,CAAC;QACjB;MACJ;IACJ;IACA,OAAOM,MAAM;EACjB;EACAb,YAAY,CAACkB,QAAQ,EAAEC,IAAI,EAAE;IACzB,MAAMC,SAAS,GAAG,IAAI,CAAChC,IAAI,CAACsB,GAAG,CAACQ,QAAQ,CAAC;IACzC,IAAI,OAAOE,SAAS,KAAK,WAAW,EAAE;MAClC;MACA,IAAI,CAAChC,IAAI,CAACD,GAAG,CAAC+B,QAAQ,EAAE,CAACC,IAAI,CAAC,CAAC;MAC/B,IAAI,CAACE,eAAe,CAACF,IAAI,CAAC;MAC1B;IACJ;IACA,KAAK,IAAI1B,CAAC,GAAG2B,SAAS,CAACzB,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC5C,MAAM6B,QAAQ,GAAGF,SAAS,CAAC3B,CAAC,CAAC;MAC7B,IAAI6B,QAAQ,CAACrC,OAAO,KAAKkC,IAAI,CAAClC,OAAO,EAAE;QACnC;MACJ;MACA,MAAMsC,eAAe,GAAID,QAAQ,CAACzB,aAAa,CAACF,MAAM,GAAG,CAAE;MAC3D,MAAM6B,WAAW,GAAIL,IAAI,CAACtB,aAAa,CAACF,MAAM,GAAG,CAAE;MACnD;MACA,IAAI4B,eAAe,IAAIC,WAAW,IAAIF,QAAQ,CAACzB,aAAa,CAAC,CAAC,CAAC,KAAKsB,IAAI,CAACtB,aAAa,CAAC,CAAC,CAAC,EAAE;QACvF;QACA;MACJ;MACA,IAAItB,kBAAkB,CAACkD,sBAAsB,CAACH,QAAQ,CAACxB,IAAI,EAAEqB,IAAI,CAACrB,IAAI,CAAC,EAAE;QACrE;QACA;QACA,IAAI,CAAC4B,oBAAoB,CAACJ,QAAQ,CAAC;MACvC;IACJ;IACAF,SAAS,CAACT,IAAI,CAACQ,IAAI,CAAC;IACpB,IAAI,CAACE,eAAe,CAACF,IAAI,CAAC;EAC9B;EACAE,eAAe,CAACF,IAAI,EAAE;IAClB,IAAI,CAACA,IAAI,CAAClC,OAAO,EAAE;MACf;IACJ;IACA,IAAI0C,GAAG,GAAG,IAAI,CAACtC,UAAU,CAACqB,GAAG,CAACS,IAAI,CAAClC,OAAO,CAAC;IAC3C,IAAI,OAAO0C,GAAG,KAAK,WAAW,EAAE;MAC5BA,GAAG,GAAG,CAACR,IAAI,CAAC;MACZ,IAAI,CAAC9B,UAAU,CAACF,GAAG,CAACgC,IAAI,CAAClC,OAAO,EAAE0C,GAAG,CAAC;IAC1C,CAAC,MACI;MACDA,GAAG,CAAChB,IAAI,CAACQ,IAAI,CAAC;IAClB;EACJ;EACAO,oBAAoB,CAACP,IAAI,EAAE;IACvB,IAAI,CAACA,IAAI,CAAClC,OAAO,EAAE;MACf;IACJ;IACA,MAAM0C,GAAG,GAAG,IAAI,CAACtC,UAAU,CAACqB,GAAG,CAACS,IAAI,CAAClC,OAAO,CAAC;IAC7C,IAAI,OAAO0C,GAAG,KAAK,WAAW,EAAE;MAC5B;IACJ;IACA,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGiC,GAAG,CAAChC,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC5C,IAAIkC,GAAG,CAAClC,CAAC,CAAC,KAAK0B,IAAI,EAAE;QACjBQ,GAAG,CAACC,MAAM,CAACnC,CAAC,EAAE,CAAC,CAAC;QAChB;MACJ;IACJ;EACJ;EACA;AACJ;AACA;EACI,OAAOgC,sBAAsB,CAACI,CAAC,EAAEC,CAAC,EAAE;IAChC,IAAI,CAACA,CAAC,IAAIA,CAAC,CAAC/B,IAAI,KAAK,CAAC,CAAC,+BAA+B;MAClD,OAAO,IAAI;IACf;IACA,IAAI,CAAC8B,CAAC,IAAIA,CAAC,CAAC9B,IAAI,KAAK,CAAC,CAAC,+BAA+B;MAClD,OAAO,KAAK;IAChB;IACA,OAAO1B,OAAO,CAACwD,CAAC,EAAEC,CAAC,CAAC;EACxB;EACAC,cAAc,GAAG;IACb,OAAO,IAAI,CAACzC,YAAY;EAC5B;EACA0C,uBAAuB,CAACC,SAAS,EAAEC,OAAO,EAAE;IACxC,MAAMC,KAAK,GAAG,IAAI,CAAC9C,UAAU,CAACqB,GAAG,CAACuB,SAAS,CAAC;IAC5C,IAAI,OAAOE,KAAK,KAAK,WAAW,IAAIA,KAAK,CAACxC,MAAM,KAAK,CAAC,EAAE;MACpD,OAAO,IAAI;IACf;IACA,IAAIwC,KAAK,CAACxC,MAAM,KAAK,CAAC,EAAE;MACpB,OAAOwC,KAAK,CAAC,CAAC,CAAC;IACnB;IACA,KAAK,IAAI1C,CAAC,GAAG0C,KAAK,CAACxC,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxC,MAAM0B,IAAI,GAAGgB,KAAK,CAAC1C,CAAC,CAAC;MACrB,IAAIyC,OAAO,CAACE,mBAAmB,CAACjB,IAAI,CAACrB,IAAI,CAAC,EAAE;QACxC,OAAOqB,IAAI;MACf;IACJ;IACA,OAAOgB,KAAK,CAACA,KAAK,CAACxC,MAAM,GAAG,CAAC,CAAC;EAClC;EACA0C,OAAO,CAACH,OAAO,EAAEI,YAAY,EAAEpB,QAAQ,EAAE;IACrC,IAAI,CAACtC,IAAI,CAAE,eAAcsC,QAAS,GAAEoB,YAAY,GAAI,iBAAgBA,YAAa,EAAC,GAAI,EAAE,EAAC,CAAC;IAC1F,IAAIC,SAAS,GAAG,IAAI;IACpB,IAAID,YAAY,KAAK,IAAI,EAAE;MACvB;MACA,MAAME,UAAU,GAAG,IAAI,CAACpD,IAAI,CAACsB,GAAG,CAAC4B,YAAY,CAAC;MAC9C,IAAI,OAAOE,UAAU,KAAK,WAAW,EAAE;QACnC;QACA,IAAI,CAAC5D,IAAI,CAAE,2BAA0B,CAAC;QACtC,OAAO,IAAI;MACf;MACA2D,SAAS,GAAG,EAAE;MACd,KAAK,IAAI9C,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG8C,UAAU,CAAC7C,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACnD,MAAMgD,SAAS,GAAGD,UAAU,CAAC/C,CAAC,CAAC;QAC/B;QACA,IAAIgD,SAAS,CAAC5C,aAAa,CAAC,CAAC,CAAC,KAAKqB,QAAQ,EAAE;UACzCqB,SAAS,CAAC5B,IAAI,CAAC8B,SAAS,CAAC;QAC7B;MACJ;IACJ,CAAC,MACI;MACD,MAAMD,UAAU,GAAG,IAAI,CAACpD,IAAI,CAACsB,GAAG,CAACQ,QAAQ,CAAC;MAC1C,IAAI,OAAOsB,UAAU,KAAK,WAAW,EAAE;QACnC;QACA,IAAI,CAAC5D,IAAI,CAAE,2BAA0B,CAAC;QACtC,OAAO,IAAI;MACf;MACA2D,SAAS,GAAGC,UAAU;IAC1B;IACA,MAAM3B,MAAM,GAAG,IAAI,CAAC6B,YAAY,CAACR,OAAO,EAAEK,SAAS,CAAC;IACpD,IAAI,CAAC1B,MAAM,EAAE;MACT,IAAI,CAACjC,IAAI,CAAE,WAAU2D,SAAS,CAAC5C,MAAO,2DAA0D,CAAC;MACjG,OAAO,IAAI;IACf;IACA;IACA,IAAI2C,YAAY,KAAK,IAAI,IAAIzB,MAAM,CAAChB,aAAa,CAACF,MAAM,GAAG,CAAC,IAAIkB,MAAM,CAAChB,aAAa,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MAC9F,IAAI,CAACjB,IAAI,CAAE,WAAU2D,SAAS,CAAC5C,MAAO,6CAA4CgD,oBAAoB,CAAC9B,MAAM,CAACf,IAAI,CAAE,aAAY8C,sBAAsB,CAAC/B,MAAM,CAAE,GAAE,CAAC;MAClK,OAAO;QACHgC,UAAU,EAAE,IAAI;QAChBC,UAAU,EAAE,KAAK;QACjBb,SAAS,EAAE,IAAI;QACfc,WAAW,EAAE,IAAI;QACjBC,MAAM,EAAE;MACZ,CAAC;IACL;IACA,IAAI,CAACpE,IAAI,CAAE,WAAU2D,SAAS,CAAC5C,MAAO,gCAA+BkB,MAAM,CAAC5B,OAAQ,WAAU0D,oBAAoB,CAAC9B,MAAM,CAACf,IAAI,CAAE,aAAY8C,sBAAsB,CAAC/B,MAAM,CAAE,GAAE,CAAC;IAC9K,OAAO;MACHgC,UAAU,EAAE,KAAK;MACjBC,UAAU,EAAEjC,MAAM,CAAChB,aAAa,CAACF,MAAM,GAAG,CAAC;MAC3CsC,SAAS,EAAEpB,MAAM,CAAC5B,OAAO;MACzB8D,WAAW,EAAElC,MAAM,CAACkC,WAAW;MAC/BC,MAAM,EAAEnC,MAAM,CAACmC;IACnB,CAAC;EACL;EACAN,YAAY,CAACR,OAAO,EAAEe,OAAO,EAAE;IAC3B,KAAK,IAAIxD,CAAC,GAAGwD,OAAO,CAACtD,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1C,MAAMG,CAAC,GAAGqD,OAAO,CAACxD,CAAC,CAAC;MACpB,IAAI,CAAClB,kBAAkB,CAAC2E,oBAAoB,CAAChB,OAAO,EAAEtC,CAAC,CAACE,IAAI,CAAC,EAAE;QAC3D;MACJ;MACA,OAAOF,CAAC;IACZ;IACA,OAAO,IAAI;EACf;EACA,OAAOsD,oBAAoB,CAAChB,OAAO,EAAE7B,KAAK,EAAE;IACxC,IAAI,CAACA,KAAK,EAAE;MACR,OAAO,IAAI;IACf;IACA,OAAOA,KAAK,CAAC8C,QAAQ,CAACjB,OAAO,CAAC;EAClC;AACJ;AACA,SAASS,oBAAoB,CAAC7C,IAAI,EAAE;EAChC,IAAI,CAACA,IAAI,EAAE;IACP,OAAQ,mBAAkB;EAC9B;EACA,OAAQ,GAAEA,IAAI,CAACsD,SAAS,EAAG,EAAC;AAChC;AACA,SAASR,sBAAsB,CAACS,EAAE,EAAE;EAChC,OAAQA,EAAE,CAACC,WAAW,GACfD,EAAE,CAACE,kBAAkB,GAAI,sBAAqBF,EAAE,CAACC,WAAY,EAAC,GAAI,kBAAiBD,EAAE,CAACC,WAAY,EAAC,GACnGD,EAAE,CAACtC,SAAS,GAAI,UAAS,GAAI,MAAM;AAC9C"},"metadata":{},"sourceType":"module","externalDependencies":[]}