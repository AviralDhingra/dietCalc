{"ast":null,"code":"var _a, _b;\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from './strings.js';\nexport class StringIterator {\n  constructor() {\n    this._value = '';\n    this._pos = 0;\n  }\n  reset(key) {\n    this._value = key;\n    this._pos = 0;\n    return this;\n  }\n  next() {\n    this._pos += 1;\n    return this;\n  }\n  hasNext() {\n    return this._pos < this._value.length - 1;\n  }\n  cmp(a) {\n    const aCode = a.charCodeAt(0);\n    const thisCode = this._value.charCodeAt(this._pos);\n    return aCode - thisCode;\n  }\n  value() {\n    return this._value[this._pos];\n  }\n}\nexport class ConfigKeysIterator {\n  constructor() {\n    let _caseSensitive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._caseSensitive = _caseSensitive;\n  }\n  reset(key) {\n    this._value = key;\n    this._from = 0;\n    this._to = 0;\n    return this.next();\n  }\n  hasNext() {\n    return this._to < this._value.length;\n  }\n  next() {\n    // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n    this._from = this._to;\n    let justSeps = true;\n    for (; this._to < this._value.length; this._to++) {\n      const ch = this._value.charCodeAt(this._to);\n      if (ch === 46 /* CharCode.Period */) {\n        if (justSeps) {\n          this._from++;\n        } else {\n          break;\n        }\n      } else {\n        justSeps = false;\n      }\n    }\n    return this;\n  }\n  cmp(a) {\n    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n  }\n  value() {\n    return this._value.substring(this._from, this._to);\n  }\n}\nexport class PathIterator {\n  constructor() {\n    let _splitOnBackslash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let _caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._splitOnBackslash = _splitOnBackslash;\n    this._caseSensitive = _caseSensitive;\n  }\n  reset(key) {\n    this._from = 0;\n    this._to = 0;\n    this._value = key;\n    this._valueLen = key.length;\n    for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {\n      const ch = this._value.charCodeAt(pos);\n      if (!(ch === 47 /* CharCode.Slash */ || this._splitOnBackslash && ch === 92 /* CharCode.Backslash */)) {\n        break;\n      }\n    }\n    return this.next();\n  }\n  hasNext() {\n    return this._to < this._valueLen;\n  }\n  next() {\n    // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n    this._from = this._to;\n    let justSeps = true;\n    for (; this._to < this._valueLen; this._to++) {\n      const ch = this._value.charCodeAt(this._to);\n      if (ch === 47 /* CharCode.Slash */ || this._splitOnBackslash && ch === 92 /* CharCode.Backslash */) {\n        if (justSeps) {\n          this._from++;\n        } else {\n          break;\n        }\n      } else {\n        justSeps = false;\n      }\n    }\n    return this;\n  }\n  cmp(a) {\n    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n  }\n  value() {\n    return this._value.substring(this._from, this._to);\n  }\n}\nexport class UriIterator {\n  constructor(_ignorePathCasing, _ignoreQueryAndFragment) {\n    this._ignorePathCasing = _ignorePathCasing;\n    this._ignoreQueryAndFragment = _ignoreQueryAndFragment;\n    this._states = [];\n    this._stateIdx = 0;\n  }\n  reset(key) {\n    this._value = key;\n    this._states = [];\n    if (this._value.scheme) {\n      this._states.push(1 /* UriIteratorState.Scheme */);\n    }\n\n    if (this._value.authority) {\n      this._states.push(2 /* UriIteratorState.Authority */);\n    }\n\n    if (this._value.path) {\n      this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n      this._pathIterator.reset(key.path);\n      if (this._pathIterator.value()) {\n        this._states.push(3 /* UriIteratorState.Path */);\n      }\n    }\n\n    if (!this._ignoreQueryAndFragment(key)) {\n      if (this._value.query) {\n        this._states.push(4 /* UriIteratorState.Query */);\n      }\n\n      if (this._value.fragment) {\n        this._states.push(5 /* UriIteratorState.Fragment */);\n      }\n    }\n\n    this._stateIdx = 0;\n    return this;\n  }\n  next() {\n    if (this._states[this._stateIdx] === 3 /* UriIteratorState.Path */ && this._pathIterator.hasNext()) {\n      this._pathIterator.next();\n    } else {\n      this._stateIdx += 1;\n    }\n    return this;\n  }\n  hasNext() {\n    return this._states[this._stateIdx] === 3 /* UriIteratorState.Path */ && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;\n  }\n  cmp(a) {\n    if (this._states[this._stateIdx] === 1 /* UriIteratorState.Scheme */) {\n      return compareIgnoreCase(a, this._value.scheme);\n    } else if (this._states[this._stateIdx] === 2 /* UriIteratorState.Authority */) {\n      return compareIgnoreCase(a, this._value.authority);\n    } else if (this._states[this._stateIdx] === 3 /* UriIteratorState.Path */) {\n      return this._pathIterator.cmp(a);\n    } else if (this._states[this._stateIdx] === 4 /* UriIteratorState.Query */) {\n      return compare(a, this._value.query);\n    } else if (this._states[this._stateIdx] === 5 /* UriIteratorState.Fragment */) {\n      return compare(a, this._value.fragment);\n    }\n    throw new Error();\n  }\n  value() {\n    if (this._states[this._stateIdx] === 1 /* UriIteratorState.Scheme */) {\n      return this._value.scheme;\n    } else if (this._states[this._stateIdx] === 2 /* UriIteratorState.Authority */) {\n      return this._value.authority;\n    } else if (this._states[this._stateIdx] === 3 /* UriIteratorState.Path */) {\n      return this._pathIterator.value();\n    } else if (this._states[this._stateIdx] === 4 /* UriIteratorState.Query */) {\n      return this._value.query;\n    } else if (this._states[this._stateIdx] === 5 /* UriIteratorState.Fragment */) {\n      return this._value.fragment;\n    }\n    throw new Error();\n  }\n}\nclass TernarySearchTreeNode {\n  constructor() {\n    this.height = 1;\n  }\n  rotateLeft() {\n    const tmp = this.right;\n    this.right = tmp.left;\n    tmp.left = this;\n    this.updateHeight();\n    tmp.updateHeight();\n    return tmp;\n  }\n  rotateRight() {\n    const tmp = this.left;\n    this.left = tmp.right;\n    tmp.right = this;\n    this.updateHeight();\n    tmp.updateHeight();\n    return tmp;\n  }\n  updateHeight() {\n    this.height = 1 + Math.max(this.heightLeft, this.heightRight);\n  }\n  balanceFactor() {\n    return this.heightRight - this.heightLeft;\n  }\n  get heightLeft() {\n    var _c, _d;\n    return (_d = (_c = this.left) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0;\n  }\n  get heightRight() {\n    var _c, _d;\n    return (_d = (_c = this.right) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0;\n  }\n}\nexport class TernarySearchTree {\n  constructor(segments) {\n    this._iter = segments;\n  }\n  static forUris() {\n    let ignorePathCasing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => false;\n    let ignoreQueryAndFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => false;\n    return new TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));\n  }\n  static forStrings() {\n    return new TernarySearchTree(new StringIterator());\n  }\n  static forConfigKeys() {\n    return new TernarySearchTree(new ConfigKeysIterator());\n  }\n  clear() {\n    this._root = undefined;\n  }\n  set(key, element) {\n    const iter = this._iter.reset(key);\n    let node;\n    if (!this._root) {\n      this._root = new TernarySearchTreeNode();\n      this._root.segment = iter.value();\n    }\n    const stack = [];\n    // find insert_node\n    node = this._root;\n    while (true) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        if (!node.left) {\n          node.left = new TernarySearchTreeNode();\n          node.left.segment = iter.value();\n        }\n        stack.push([-1 /* Dir.Left */, node]);\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        if (!node.right) {\n          node.right = new TernarySearchTreeNode();\n          node.right.segment = iter.value();\n        }\n        stack.push([1 /* Dir.Right */, node]);\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        if (!node.mid) {\n          node.mid = new TernarySearchTreeNode();\n          node.mid.segment = iter.value();\n        }\n        stack.push([0 /* Dir.Mid */, node]);\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    // set value\n    const oldElement = node.value;\n    node.value = element;\n    node.key = key;\n    // balance\n    for (let i = stack.length - 1; i >= 0; i--) {\n      const node = stack[i][1];\n      node.updateHeight();\n      const bf = node.balanceFactor();\n      if (bf < -1 || bf > 1) {\n        // needs rotate\n        const d1 = stack[i][0];\n        const d2 = stack[i + 1][0];\n        if (d1 === 1 /* Dir.Right */ && d2 === 1 /* Dir.Right */) {\n          //right, right -> rotate left\n          stack[i][1] = node.rotateLeft();\n        } else if (d1 === -1 /* Dir.Left */ && d2 === -1 /* Dir.Left */) {\n          // left, left -> rotate right\n          stack[i][1] = node.rotateRight();\n        } else if (d1 === 1 /* Dir.Right */ && d2 === -1 /* Dir.Left */) {\n          // right, left -> double rotate right, left\n          node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n          stack[i][1] = node.rotateLeft();\n        } else if (d1 === -1 /* Dir.Left */ && d2 === 1 /* Dir.Right */) {\n          // left, right -> double rotate left, right\n          node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n          stack[i][1] = node.rotateRight();\n        } else {\n          throw new Error();\n        }\n        // patch path to parent\n        if (i > 0) {\n          switch (stack[i - 1][0]) {\n            case -1 /* Dir.Left */:\n              stack[i - 1][1].left = stack[i][1];\n              break;\n            case 1 /* Dir.Right */:\n              stack[i - 1][1].right = stack[i][1];\n              break;\n            case 0 /* Dir.Mid */:\n              stack[i - 1][1].mid = stack[i][1];\n              break;\n          }\n        } else {\n          this._root = stack[0][1];\n        }\n      }\n    }\n    return oldElement;\n  }\n  get(key) {\n    var _c;\n    return (_c = this._getNode(key)) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  _getNode(key) {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    return node;\n  }\n  has(key) {\n    const node = this._getNode(key);\n    return !((node === null || node === void 0 ? void 0 : node.value) === undefined && (node === null || node === void 0 ? void 0 : node.mid) === undefined);\n  }\n  delete(key) {\n    return this._delete(key, false);\n  }\n  deleteSuperstr(key) {\n    return this._delete(key, true);\n  }\n  _delete(key, superStr) {\n    var _c;\n    const iter = this._iter.reset(key);\n    const stack = [];\n    let node = this._root;\n    // find node\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        stack.push([-1 /* Dir.Left */, node]);\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        stack.push([1 /* Dir.Right */, node]);\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        stack.push([0 /* Dir.Mid */, node]);\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    if (!node) {\n      // node not found\n      return;\n    }\n    if (superStr) {\n      // removing children, reset height\n      node.left = undefined;\n      node.mid = undefined;\n      node.right = undefined;\n      node.height = 1;\n    } else {\n      // removing element\n      node.key = undefined;\n      node.value = undefined;\n    }\n    // BST node removal\n    if (!node.mid && !node.value) {\n      if (node.left && node.right) {\n        // full node\n        const min = this._min(node.right);\n        const {\n          key,\n          value,\n          segment\n        } = min;\n        this._delete(min.key, false);\n        node.key = key;\n        node.value = value;\n        node.segment = segment;\n      } else {\n        // empty or half empty\n        const newChild = (_c = node.left) !== null && _c !== void 0 ? _c : node.right;\n        if (stack.length > 0) {\n          const [dir, parent] = stack[stack.length - 1];\n          switch (dir) {\n            case -1 /* Dir.Left */:\n              parent.left = newChild;\n              break;\n            case 0 /* Dir.Mid */:\n              parent.mid = newChild;\n              break;\n            case 1 /* Dir.Right */:\n              parent.right = newChild;\n              break;\n          }\n        } else {\n          this._root = newChild;\n        }\n      }\n    }\n    // AVL balance\n    for (let i = stack.length - 1; i >= 0; i--) {\n      const node = stack[i][1];\n      node.updateHeight();\n      const bf = node.balanceFactor();\n      if (bf > 1) {\n        // right heavy\n        if (node.right.balanceFactor() >= 0) {\n          // right, right -> rotate left\n          stack[i][1] = node.rotateLeft();\n        } else {\n          // right, left -> double rotate\n          node.right = node.right.rotateRight();\n          stack[i][1] = node.rotateLeft();\n        }\n      } else if (bf < -1) {\n        // left heavy\n        if (node.left.balanceFactor() <= 0) {\n          // left, left -> rotate right\n          stack[i][1] = node.rotateRight();\n        } else {\n          // left, right -> double rotate\n          node.left = node.left.rotateLeft();\n          stack[i][1] = node.rotateRight();\n        }\n      }\n      // patch path to parent\n      if (i > 0) {\n        switch (stack[i - 1][0]) {\n          case -1 /* Dir.Left */:\n            stack[i - 1][1].left = stack[i][1];\n            break;\n          case 1 /* Dir.Right */:\n            stack[i - 1][1].right = stack[i][1];\n            break;\n          case 0 /* Dir.Mid */:\n            stack[i - 1][1].mid = stack[i][1];\n            break;\n        }\n      } else {\n        this._root = stack[0][1];\n      }\n    }\n  }\n  _min(node) {\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n  findSubstr(key) {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    let candidate = undefined;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        candidate = node.value || candidate;\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    return node && node.value || candidate;\n  }\n  findSuperstr(key) {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        // collect\n        if (!node.mid) {\n          return undefined;\n        } else {\n          return this._entries(node.mid);\n        }\n      }\n    }\n    return undefined;\n  }\n  forEach(callback) {\n    for (const [key, value] of this) {\n      callback(value, key);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield* this._entries(this._root);\n  }\n  _entries(node) {\n    const result = [];\n    this._dfsEntries(node, result);\n    return result[Symbol.iterator]();\n  }\n  _dfsEntries(node, bucket) {\n    // DFS\n    if (!node) {\n      return;\n    }\n    if (node.left) {\n      this._dfsEntries(node.left, bucket);\n    }\n    if (node.value) {\n      bucket.push([node.key, node.value]);\n    }\n    if (node.mid) {\n      this._dfsEntries(node.mid, bucket);\n    }\n    if (node.right) {\n      this._dfsEntries(node.right, bucket);\n    }\n  }\n}\nclass ResourceMapEntry {\n  constructor(uri, value) {\n    this.uri = uri;\n    this.value = value;\n  }\n}\nexport class ResourceMap {\n  constructor(mapOrKeyFn, toKey) {\n    this[_a] = 'ResourceMap';\n    if (mapOrKeyFn instanceof ResourceMap) {\n      this.map = new Map(mapOrKeyFn.map);\n      this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n    } else {\n      this.map = new Map();\n      this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\n    }\n  }\n  set(resource, value) {\n    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n    return this;\n  }\n  get(resource) {\n    var _c;\n    return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  has(resource) {\n    return this.map.has(this.toKey(resource));\n  }\n  get size() {\n    return this.map.size;\n  }\n  clear() {\n    this.map.clear();\n  }\n  delete(resource) {\n    return this.map.delete(this.toKey(resource));\n  }\n  forEach(clb, thisArg) {\n    if (typeof thisArg !== 'undefined') {\n      clb = clb.bind(thisArg);\n    }\n    for (const [_, entry] of this.map) {\n      clb(entry.value, entry.uri, this);\n    }\n  }\n  *values() {\n    for (const entry of this.map.values()) {\n      yield entry.value;\n    }\n  }\n  *keys() {\n    for (const entry of this.map.values()) {\n      yield entry.uri;\n    }\n  }\n  *entries() {\n    for (const entry of this.map.values()) {\n      yield [entry.uri, entry.value];\n    }\n  }\n  *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n    for (const [, entry] of this.map) {\n      yield [entry.uri, entry.value];\n    }\n  }\n}\nResourceMap.defaultToKey = resource => resource.toString();\nexport class LinkedMap {\n  constructor() {\n    this[_b] = 'LinkedMap';\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state = 0;\n  }\n  clear() {\n    this._map.clear();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state++;\n  }\n  isEmpty() {\n    return !this._head && !this._tail;\n  }\n  get size() {\n    return this._size;\n  }\n  get first() {\n    var _c;\n    return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  get last() {\n    var _c;\n    return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  get(key) {\n    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    if (touch !== 0 /* Touch.None */) {\n      this.touch(item, touch);\n    }\n    return item.value;\n  }\n  set(key, value) {\n    let touch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let item = this._map.get(key);\n    if (item) {\n      item.value = value;\n      if (touch !== 0 /* Touch.None */) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = {\n        key,\n        value,\n        next: undefined,\n        previous: undefined\n      };\n      switch (touch) {\n        case 0 /* Touch.None */:\n          this.addItemLast(item);\n          break;\n        case 1 /* Touch.AsOld */:\n          this.addItemFirst(item);\n          break;\n        case 2 /* Touch.AsNew */:\n          this.addItemLast(item);\n          break;\n        default:\n          this.addItemLast(item);\n          break;\n      }\n      this._map.set(key, item);\n      this._size++;\n    }\n    return this;\n  }\n  delete(key) {\n    return !!this.remove(key);\n  }\n  remove(key) {\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    this._map.delete(key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  shift() {\n    if (!this._head && !this._tail) {\n      return undefined;\n    }\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    const item = this._head;\n    this._map.delete(item.key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n      if (this._state !== state) {\n        throw new Error(`LinkedMap got modified during iteration.`);\n      }\n      current = current.next;\n    }\n  }\n  keys() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: current.key,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  values() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: current.value,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  entries() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: [current.key, current.value],\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.entries();\n  }\n  trimOld(newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._head;\n    let currentSize = this.size;\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n      current = current.next;\n      currentSize--;\n    }\n    this._head = current;\n    this._size = currentSize;\n    if (current) {\n      current.previous = undefined;\n    }\n    this._state++;\n  }\n  addItemFirst(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n    this._head = item;\n    this._state++;\n  }\n  addItemLast(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n    this._tail = item;\n    this._state++;\n  }\n  removeItem(item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      // This can only happen if size === 1 which is handled\n      // by the case above.\n      if (!item.next) {\n        throw new Error('Invalid list');\n      }\n      item.next.previous = undefined;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      // This can only happen if size === 1 which is handled\n      // by the case above.\n      if (!item.previous) {\n        throw new Error('Invalid list');\n      }\n      item.previous.next = undefined;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n      next.previous = previous;\n      previous.next = next;\n    }\n    item.next = undefined;\n    item.previous = undefined;\n    this._state++;\n  }\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    if (touch !== 1 /* Touch.AsOld */ && touch !== 2 /* Touch.AsNew */) {\n      return;\n    }\n    if (touch === 1 /* Touch.AsOld */) {\n      if (item === this._head) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      // Unlink the item\n      if (item === this._tail) {\n        // previous must be defined since item was not head but is tail\n        // So there are more than on item in the map\n        previous.next = undefined;\n        this._tail = previous;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n      // Insert the node at head\n      item.previous = undefined;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === 2 /* Touch.AsNew */) {\n      if (item === this._tail) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      // Unlink the item.\n      if (item === this._head) {\n        // next must be defined since item was not tail but is head\n        // So there are more than on item in the map\n        next.previous = undefined;\n        this._head = next;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.next = undefined;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) => {\n      data.push([key, value]);\n    });\n    return data;\n  }\n  fromJSON(data) {\n    this.clear();\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n}\nexport class LRUCache extends LinkedMap {\n  constructor(limit) {\n    let ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    super();\n    this._limit = limit;\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n  }\n  get limit() {\n    return this._limit;\n  }\n  set limit(limit) {\n    this._limit = limit;\n    this.checkTrim();\n  }\n  get(key) {\n    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    return super.get(key, touch);\n  }\n  peek(key) {\n    return super.get(key, 0 /* Touch.None */);\n  }\n\n  set(key, value) {\n    super.set(key, value, 2 /* Touch.AsNew */);\n    this.checkTrim();\n    return this;\n  }\n  checkTrim() {\n    if (this.size > this._limit) {\n      this.trimOld(Math.round(this._limit * this._ratio));\n    }\n  }\n}","map":{"version":3,"names":["_a","_b","compare","compareIgnoreCase","compareSubstring","compareSubstringIgnoreCase","StringIterator","constructor","_value","_pos","reset","key","next","hasNext","length","cmp","a","aCode","charCodeAt","thisCode","value","ConfigKeysIterator","_caseSensitive","_from","_to","justSeps","ch","substring","PathIterator","_splitOnBackslash","_valueLen","pos","UriIterator","_ignorePathCasing","_ignoreQueryAndFragment","_states","_stateIdx","scheme","push","authority","path","_pathIterator","query","fragment","Error","TernarySearchTreeNode","height","rotateLeft","tmp","right","left","updateHeight","rotateRight","Math","max","heightLeft","heightRight","balanceFactor","_c","_d","TernarySearchTree","segments","_iter","forUris","ignorePathCasing","ignoreQueryAndFragment","forStrings","forConfigKeys","clear","_root","undefined","set","element","iter","node","segment","stack","val","mid","oldElement","i","bf","d1","d2","get","_getNode","has","delete","_delete","deleteSuperstr","superStr","min","_min","newChild","dir","parent","findSubstr","candidate","findSuperstr","_entries","forEach","callback","Symbol","iterator","result","_dfsEntries","bucket","ResourceMapEntry","uri","ResourceMap","mapOrKeyFn","toKey","map","Map","defaultToKey","resource","size","clb","thisArg","bind","_","entry","values","keys","entries","toStringTag","toString","LinkedMap","_map","_head","_tail","_size","_state","isEmpty","first","last","touch","item","previous","addItemLast","addItemFirst","remove","removeItem","shift","callbackfn","state","current","done","trimOld","newSize","currentSize","toJSON","data","fromJSON","LRUCache","limit","ratio","_limit","_ratio","checkTrim","peek","round"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/base/common/map.js"],"sourcesContent":["var _a, _b;\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from './strings.js';\nexport class StringIterator {\n    constructor() {\n        this._value = '';\n        this._pos = 0;\n    }\n    reset(key) {\n        this._value = key;\n        this._pos = 0;\n        return this;\n    }\n    next() {\n        this._pos += 1;\n        return this;\n    }\n    hasNext() {\n        return this._pos < this._value.length - 1;\n    }\n    cmp(a) {\n        const aCode = a.charCodeAt(0);\n        const thisCode = this._value.charCodeAt(this._pos);\n        return aCode - thisCode;\n    }\n    value() {\n        return this._value[this._pos];\n    }\n}\nexport class ConfigKeysIterator {\n    constructor(_caseSensitive = true) {\n        this._caseSensitive = _caseSensitive;\n    }\n    reset(key) {\n        this._value = key;\n        this._from = 0;\n        this._to = 0;\n        return this.next();\n    }\n    hasNext() {\n        return this._to < this._value.length;\n    }\n    next() {\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._value.length; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === 46 /* CharCode.Period */) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n    cmp(a) {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n    value() {\n        return this._value.substring(this._from, this._to);\n    }\n}\nexport class PathIterator {\n    constructor(_splitOnBackslash = true, _caseSensitive = true) {\n        this._splitOnBackslash = _splitOnBackslash;\n        this._caseSensitive = _caseSensitive;\n    }\n    reset(key) {\n        this._from = 0;\n        this._to = 0;\n        this._value = key;\n        this._valueLen = key.length;\n        for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {\n            const ch = this._value.charCodeAt(pos);\n            if (!(ch === 47 /* CharCode.Slash */ || this._splitOnBackslash && ch === 92 /* CharCode.Backslash */)) {\n                break;\n            }\n        }\n        return this.next();\n    }\n    hasNext() {\n        return this._to < this._valueLen;\n    }\n    next() {\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._valueLen; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === 47 /* CharCode.Slash */ || this._splitOnBackslash && ch === 92 /* CharCode.Backslash */) {\n                if (justSeps) {\n                    this._from++;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n    cmp(a) {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n    value() {\n        return this._value.substring(this._from, this._to);\n    }\n}\nexport class UriIterator {\n    constructor(_ignorePathCasing, _ignoreQueryAndFragment) {\n        this._ignorePathCasing = _ignorePathCasing;\n        this._ignoreQueryAndFragment = _ignoreQueryAndFragment;\n        this._states = [];\n        this._stateIdx = 0;\n    }\n    reset(key) {\n        this._value = key;\n        this._states = [];\n        if (this._value.scheme) {\n            this._states.push(1 /* UriIteratorState.Scheme */);\n        }\n        if (this._value.authority) {\n            this._states.push(2 /* UriIteratorState.Authority */);\n        }\n        if (this._value.path) {\n            this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n            this._pathIterator.reset(key.path);\n            if (this._pathIterator.value()) {\n                this._states.push(3 /* UriIteratorState.Path */);\n            }\n        }\n        if (!this._ignoreQueryAndFragment(key)) {\n            if (this._value.query) {\n                this._states.push(4 /* UriIteratorState.Query */);\n            }\n            if (this._value.fragment) {\n                this._states.push(5 /* UriIteratorState.Fragment */);\n            }\n        }\n        this._stateIdx = 0;\n        return this;\n    }\n    next() {\n        if (this._states[this._stateIdx] === 3 /* UriIteratorState.Path */ && this._pathIterator.hasNext()) {\n            this._pathIterator.next();\n        }\n        else {\n            this._stateIdx += 1;\n        }\n        return this;\n    }\n    hasNext() {\n        return (this._states[this._stateIdx] === 3 /* UriIteratorState.Path */ && this._pathIterator.hasNext())\n            || this._stateIdx < this._states.length - 1;\n    }\n    cmp(a) {\n        if (this._states[this._stateIdx] === 1 /* UriIteratorState.Scheme */) {\n            return compareIgnoreCase(a, this._value.scheme);\n        }\n        else if (this._states[this._stateIdx] === 2 /* UriIteratorState.Authority */) {\n            return compareIgnoreCase(a, this._value.authority);\n        }\n        else if (this._states[this._stateIdx] === 3 /* UriIteratorState.Path */) {\n            return this._pathIterator.cmp(a);\n        }\n        else if (this._states[this._stateIdx] === 4 /* UriIteratorState.Query */) {\n            return compare(a, this._value.query);\n        }\n        else if (this._states[this._stateIdx] === 5 /* UriIteratorState.Fragment */) {\n            return compare(a, this._value.fragment);\n        }\n        throw new Error();\n    }\n    value() {\n        if (this._states[this._stateIdx] === 1 /* UriIteratorState.Scheme */) {\n            return this._value.scheme;\n        }\n        else if (this._states[this._stateIdx] === 2 /* UriIteratorState.Authority */) {\n            return this._value.authority;\n        }\n        else if (this._states[this._stateIdx] === 3 /* UriIteratorState.Path */) {\n            return this._pathIterator.value();\n        }\n        else if (this._states[this._stateIdx] === 4 /* UriIteratorState.Query */) {\n            return this._value.query;\n        }\n        else if (this._states[this._stateIdx] === 5 /* UriIteratorState.Fragment */) {\n            return this._value.fragment;\n        }\n        throw new Error();\n    }\n}\nclass TernarySearchTreeNode {\n    constructor() {\n        this.height = 1;\n    }\n    rotateLeft() {\n        const tmp = this.right;\n        this.right = tmp.left;\n        tmp.left = this;\n        this.updateHeight();\n        tmp.updateHeight();\n        return tmp;\n    }\n    rotateRight() {\n        const tmp = this.left;\n        this.left = tmp.right;\n        tmp.right = this;\n        this.updateHeight();\n        tmp.updateHeight();\n        return tmp;\n    }\n    updateHeight() {\n        this.height = 1 + Math.max(this.heightLeft, this.heightRight);\n    }\n    balanceFactor() {\n        return this.heightRight - this.heightLeft;\n    }\n    get heightLeft() {\n        var _c, _d;\n        return (_d = (_c = this.left) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0;\n    }\n    get heightRight() {\n        var _c, _d;\n        return (_d = (_c = this.right) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0;\n    }\n}\nexport class TernarySearchTree {\n    constructor(segments) {\n        this._iter = segments;\n    }\n    static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {\n        return new TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));\n    }\n    static forStrings() {\n        return new TernarySearchTree(new StringIterator());\n    }\n    static forConfigKeys() {\n        return new TernarySearchTree(new ConfigKeysIterator());\n    }\n    clear() {\n        this._root = undefined;\n    }\n    set(key, element) {\n        const iter = this._iter.reset(key);\n        let node;\n        if (!this._root) {\n            this._root = new TernarySearchTreeNode();\n            this._root.segment = iter.value();\n        }\n        const stack = [];\n        // find insert_node\n        node = this._root;\n        while (true) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                if (!node.left) {\n                    node.left = new TernarySearchTreeNode();\n                    node.left.segment = iter.value();\n                }\n                stack.push([-1 /* Dir.Left */, node]);\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                if (!node.right) {\n                    node.right = new TernarySearchTreeNode();\n                    node.right.segment = iter.value();\n                }\n                stack.push([1 /* Dir.Right */, node]);\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                if (!node.mid) {\n                    node.mid = new TernarySearchTreeNode();\n                    node.mid.segment = iter.value();\n                }\n                stack.push([0 /* Dir.Mid */, node]);\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        // set value\n        const oldElement = node.value;\n        node.value = element;\n        node.key = key;\n        // balance\n        for (let i = stack.length - 1; i >= 0; i--) {\n            const node = stack[i][1];\n            node.updateHeight();\n            const bf = node.balanceFactor();\n            if (bf < -1 || bf > 1) {\n                // needs rotate\n                const d1 = stack[i][0];\n                const d2 = stack[i + 1][0];\n                if (d1 === 1 /* Dir.Right */ && d2 === 1 /* Dir.Right */) {\n                    //right, right -> rotate left\n                    stack[i][1] = node.rotateLeft();\n                }\n                else if (d1 === -1 /* Dir.Left */ && d2 === -1 /* Dir.Left */) {\n                    // left, left -> rotate right\n                    stack[i][1] = node.rotateRight();\n                }\n                else if (d1 === 1 /* Dir.Right */ && d2 === -1 /* Dir.Left */) {\n                    // right, left -> double rotate right, left\n                    node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n                    stack[i][1] = node.rotateLeft();\n                }\n                else if (d1 === -1 /* Dir.Left */ && d2 === 1 /* Dir.Right */) {\n                    // left, right -> double rotate left, right\n                    node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n                    stack[i][1] = node.rotateRight();\n                }\n                else {\n                    throw new Error();\n                }\n                // patch path to parent\n                if (i > 0) {\n                    switch (stack[i - 1][0]) {\n                        case -1 /* Dir.Left */:\n                            stack[i - 1][1].left = stack[i][1];\n                            break;\n                        case 1 /* Dir.Right */:\n                            stack[i - 1][1].right = stack[i][1];\n                            break;\n                        case 0 /* Dir.Mid */:\n                            stack[i - 1][1].mid = stack[i][1];\n                            break;\n                    }\n                }\n                else {\n                    this._root = stack[0][1];\n                }\n            }\n        }\n        return oldElement;\n    }\n    get(key) {\n        var _c;\n        return (_c = this._getNode(key)) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    _getNode(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node;\n    }\n    has(key) {\n        const node = this._getNode(key);\n        return !((node === null || node === void 0 ? void 0 : node.value) === undefined && (node === null || node === void 0 ? void 0 : node.mid) === undefined);\n    }\n    delete(key) {\n        return this._delete(key, false);\n    }\n    deleteSuperstr(key) {\n        return this._delete(key, true);\n    }\n    _delete(key, superStr) {\n        var _c;\n        const iter = this._iter.reset(key);\n        const stack = [];\n        let node = this._root;\n        // find node\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                stack.push([-1 /* Dir.Left */, node]);\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                stack.push([1 /* Dir.Right */, node]);\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                stack.push([0 /* Dir.Mid */, node]);\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        if (!node) {\n            // node not found\n            return;\n        }\n        if (superStr) {\n            // removing children, reset height\n            node.left = undefined;\n            node.mid = undefined;\n            node.right = undefined;\n            node.height = 1;\n        }\n        else {\n            // removing element\n            node.key = undefined;\n            node.value = undefined;\n        }\n        // BST node removal\n        if (!node.mid && !node.value) {\n            if (node.left && node.right) {\n                // full node\n                const min = this._min(node.right);\n                const { key, value, segment } = min;\n                this._delete(min.key, false);\n                node.key = key;\n                node.value = value;\n                node.segment = segment;\n            }\n            else {\n                // empty or half empty\n                const newChild = (_c = node.left) !== null && _c !== void 0 ? _c : node.right;\n                if (stack.length > 0) {\n                    const [dir, parent] = stack[stack.length - 1];\n                    switch (dir) {\n                        case -1 /* Dir.Left */:\n                            parent.left = newChild;\n                            break;\n                        case 0 /* Dir.Mid */:\n                            parent.mid = newChild;\n                            break;\n                        case 1 /* Dir.Right */:\n                            parent.right = newChild;\n                            break;\n                    }\n                }\n                else {\n                    this._root = newChild;\n                }\n            }\n        }\n        // AVL balance\n        for (let i = stack.length - 1; i >= 0; i--) {\n            const node = stack[i][1];\n            node.updateHeight();\n            const bf = node.balanceFactor();\n            if (bf > 1) {\n                // right heavy\n                if (node.right.balanceFactor() >= 0) {\n                    // right, right -> rotate left\n                    stack[i][1] = node.rotateLeft();\n                }\n                else {\n                    // right, left -> double rotate\n                    node.right = node.right.rotateRight();\n                    stack[i][1] = node.rotateLeft();\n                }\n            }\n            else if (bf < -1) {\n                // left heavy\n                if (node.left.balanceFactor() <= 0) {\n                    // left, left -> rotate right\n                    stack[i][1] = node.rotateRight();\n                }\n                else {\n                    // left, right -> double rotate\n                    node.left = node.left.rotateLeft();\n                    stack[i][1] = node.rotateRight();\n                }\n            }\n            // patch path to parent\n            if (i > 0) {\n                switch (stack[i - 1][0]) {\n                    case -1 /* Dir.Left */:\n                        stack[i - 1][1].left = stack[i][1];\n                        break;\n                    case 1 /* Dir.Right */:\n                        stack[i - 1][1].right = stack[i][1];\n                        break;\n                    case 0 /* Dir.Mid */:\n                        stack[i - 1][1].mid = stack[i][1];\n                        break;\n                }\n            }\n            else {\n                this._root = stack[0][1];\n            }\n        }\n    }\n    _min(node) {\n        while (node.left) {\n            node = node.left;\n        }\n        return node;\n    }\n    findSubstr(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        let candidate = undefined;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                candidate = node.value || candidate;\n                node = node.mid;\n            }\n            else {\n                break;\n            }\n        }\n        return node && node.value || candidate;\n    }\n    findSuperstr(key) {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            }\n            else if (val < 0) {\n                // right\n                node = node.right;\n            }\n            else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            }\n            else {\n                // collect\n                if (!node.mid) {\n                    return undefined;\n                }\n                else {\n                    return this._entries(node.mid);\n                }\n            }\n        }\n        return undefined;\n    }\n    forEach(callback) {\n        for (const [key, value] of this) {\n            callback(value, key);\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this._entries(this._root);\n    }\n    _entries(node) {\n        const result = [];\n        this._dfsEntries(node, result);\n        return result[Symbol.iterator]();\n    }\n    _dfsEntries(node, bucket) {\n        // DFS\n        if (!node) {\n            return;\n        }\n        if (node.left) {\n            this._dfsEntries(node.left, bucket);\n        }\n        if (node.value) {\n            bucket.push([node.key, node.value]);\n        }\n        if (node.mid) {\n            this._dfsEntries(node.mid, bucket);\n        }\n        if (node.right) {\n            this._dfsEntries(node.right, bucket);\n        }\n    }\n}\nclass ResourceMapEntry {\n    constructor(uri, value) {\n        this.uri = uri;\n        this.value = value;\n    }\n}\nexport class ResourceMap {\n    constructor(mapOrKeyFn, toKey) {\n        this[_a] = 'ResourceMap';\n        if (mapOrKeyFn instanceof ResourceMap) {\n            this.map = new Map(mapOrKeyFn.map);\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n        }\n        else {\n            this.map = new Map();\n            this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\n        }\n    }\n    set(resource, value) {\n        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n        return this;\n    }\n    get(resource) {\n        var _c;\n        return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(resource) {\n        return this.map.has(this.toKey(resource));\n    }\n    get size() {\n        return this.map.size;\n    }\n    clear() {\n        this.map.clear();\n    }\n    delete(resource) {\n        return this.map.delete(this.toKey(resource));\n    }\n    forEach(clb, thisArg) {\n        if (typeof thisArg !== 'undefined') {\n            clb = clb.bind(thisArg);\n        }\n        for (const [_, entry] of this.map) {\n            clb(entry.value, entry.uri, this);\n        }\n    }\n    *values() {\n        for (const entry of this.map.values()) {\n            yield entry.value;\n        }\n    }\n    *keys() {\n        for (const entry of this.map.values()) {\n            yield entry.uri;\n        }\n    }\n    *entries() {\n        for (const entry of this.map.values()) {\n            yield [entry.uri, entry.value];\n        }\n    }\n    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        for (const [, entry] of this.map) {\n            yield [entry.uri, entry.value];\n        }\n    }\n}\nResourceMap.defaultToKey = (resource) => resource.toString();\nexport class LinkedMap {\n    constructor() {\n        this[_b] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        var _c;\n        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    get last() {\n        var _c;\n        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = 0 /* Touch.None */) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== 0 /* Touch.None */) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = 0 /* Touch.None */) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== 0 /* Touch.None */) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case 0 /* Touch.None */:\n                    this.addItemLast(item);\n                    break;\n                case 1 /* Touch.AsOld */:\n                    this.addItemFirst(item);\n                    break;\n                case 2 /* Touch.AsNew */:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== 1 /* Touch.AsOld */ && touch !== 2 /* Touch.AsNew */)) {\n            return;\n        }\n        if (touch === 1 /* Touch.AsOld */) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === 2 /* Touch.AsNew */) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexport class LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get(key, touch = 2 /* Touch.AsNew */) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, 0 /* Touch.None */);\n    }\n    set(key, value) {\n        super.set(key, value, 2 /* Touch.AsNew */);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}