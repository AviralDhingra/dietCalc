{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n  constructor(languageIdCodec) {\n    this._lineTokens = [];\n    this._len = 0;\n    this._languageIdCodec = languageIdCodec;\n  }\n  flush() {\n    this._lineTokens = [];\n    this._len = 0;\n  }\n  getTokens(topLevelLanguageId, lineIndex, lineText) {\n    let rawLineTokens = null;\n    if (lineIndex < this._len) {\n      rawLineTokens = this._lineTokens[lineIndex];\n    }\n    if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n      return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n    }\n    const lineTokens = new Uint32Array(2);\n    lineTokens[0] = lineText.length;\n    lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n    return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n  }\n  static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n    const tokens = _tokens ? toUint32Array(_tokens) : null;\n    if (lineTextLength === 0) {\n      let hasDifferentLanguageId = false;\n      if (tokens && tokens.length > 1) {\n        hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;\n      }\n      if (!hasDifferentLanguageId) {\n        return EMPTY_LINE_TOKENS;\n      }\n    }\n    if (!tokens || tokens.length === 0) {\n      const tokens = new Uint32Array(2);\n      tokens[0] = lineTextLength;\n      tokens[1] = getDefaultMetadata(topLevelLanguageId);\n      return tokens.buffer;\n    }\n    // Ensure the last token covers the end of the text\n    tokens[tokens.length - 2] = lineTextLength;\n    if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n      // Store directly the ArrayBuffer pointer to save an object\n      return tokens.buffer;\n    }\n    return tokens;\n  }\n  _ensureLine(lineIndex) {\n    while (lineIndex >= this._len) {\n      this._lineTokens[this._len] = null;\n      this._len++;\n    }\n  }\n  _deleteLines(start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n    this._lineTokens.splice(start, deleteCount);\n    this._len -= deleteCount;\n  }\n  _insertLines(insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n    const lineTokens = [];\n    for (let i = 0; i < insertCount; i++) {\n      lineTokens[i] = null;\n    }\n    this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n    this._len += insertCount;\n  }\n  setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n    const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n    this._ensureLine(lineIndex);\n    const oldTokens = this._lineTokens[lineIndex];\n    this._lineTokens[lineIndex] = tokens;\n    if (checkEquality) {\n      return !ContiguousTokensStore._equals(oldTokens, tokens);\n    }\n    return false;\n  }\n  static _equals(_a, _b) {\n    if (!_a || !_b) {\n      return !_a && !_b;\n    }\n    const a = toUint32Array(_a);\n    const b = toUint32Array(_b);\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  //#region Editing\n  acceptEdit(range, eolCount, firstLineLength) {\n    this._acceptDeleteRange(range);\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n  }\n  _acceptDeleteRange(range) {\n    const firstLineIndex = range.startLineNumber - 1;\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        // Nothing to delete\n        return;\n      }\n      this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n      return;\n    }\n    this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n    const lastLineIndex = range.endLineNumber - 1;\n    let lastLineTokens = null;\n    if (lastLineIndex < this._len) {\n      lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n    }\n    // Take remaining text on last line and append it to remaining text on first line\n    this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n    // Delete middle lines\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  }\n  _acceptInsertText(position, eolCount, firstLineLength) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n    const lineIndex = position.lineNumber - 1;\n    if (lineIndex >= this._len) {\n      return;\n    }\n    if (eolCount === 0) {\n      // Inserting text on one line\n      this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n      return;\n    }\n    this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n    this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n    this._insertLines(position.lineNumber, eolCount);\n  }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n  return (topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */ | 0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */ | 0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */ | 1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */ | 2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */\n  // If there is no grammar, we just take a guess and try to match brackets.\n  | 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) >>> 0;\n}","map":{"version":3,"names":["arrays","Position","ContiguousTokensEditing","EMPTY_LINE_TOKENS","toUint32Array","LineTokens","TokenMetadata","ContiguousTokensStore","constructor","languageIdCodec","_lineTokens","_len","_languageIdCodec","flush","getTokens","topLevelLanguageId","lineIndex","lineText","rawLineTokens","lineTokens","Uint32Array","length","getDefaultMetadata","encodeLanguageId","_massageTokens","lineTextLength","_tokens","tokens","hasDifferentLanguageId","getLanguageId","buffer","byteOffset","byteLength","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","i","arrayInsert","setTokens","checkEquality","oldTokens","_equals","_a","_b","a","b","len","acceptEdit","range","eolCount","firstLineLength","_acceptDeleteRange","_acceptInsertText","startLineNumber","startColumn","firstLineIndex","endLineNumber","endColumn","delete","deleteEnding","lastLineIndex","lastLineTokens","deleteBeginning","append","position","lineNumber","insert","column"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}