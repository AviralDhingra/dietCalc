{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n  constructor(map) {\n    this.map = map;\n    this.hasRegExp = false;\n    this._regExpGlobal = null;\n  }\n  static createFromLanguage(configuration, denseKeyProvider) {\n    function getId(bracketInfo) {\n      return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n    }\n    const map = new Map();\n    for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n      const length = toLength(0, openingBracket.bracketText.length);\n      const openingTextId = getId(openingBracket);\n      const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n      map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n    }\n    for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n      const length = toLength(0, closingBracket.bracketText.length);\n      let bracketIds = SmallImmutableSet.getEmpty();\n      const closingBrackets = closingBracket.getClosedBrackets();\n      for (const bracket of closingBrackets) {\n        bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n      }\n      map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n    }\n    return new BracketTokens(map);\n  }\n  getRegExpStr() {\n    if (this.isEmpty) {\n      return null;\n    } else {\n      const keys = [...this.map.keys()];\n      keys.sort();\n      keys.reverse();\n      return keys.map(k => prepareBracketForRegExp(k)).join('|');\n    }\n  }\n  /**\n   * Returns null if there is no such regexp (because there are no brackets).\n  */\n  get regExpGlobal() {\n    if (!this.hasRegExp) {\n      const regExpStr = this.getRegExpStr();\n      this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n      this.hasRegExp = true;\n    }\n    return this._regExpGlobal;\n  }\n  getToken(value) {\n    return this.map.get(value.toLowerCase());\n  }\n  findClosingTokenText(openingBracketIds) {\n    for (const [closingText, info] of this.map) {\n      if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n        return closingText;\n      }\n    }\n    return undefined;\n  }\n  get isEmpty() {\n    return this.map.size === 0;\n  }\n}\nfunction prepareBracketForRegExp(str) {\n  let escaped = escapeRegExpCharacters(str);\n  // These bracket pair delimiters start or end with letters\n  // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n  if (/^[\\w ]+/.test(str)) {\n    escaped = `\\\\b${escaped}`;\n  }\n  if (/[\\w ]+$/.test(str)) {\n    escaped = `${escaped}\\\\b`;\n  }\n  return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n  constructor(denseKeyProvider, getLanguageConfiguration) {\n    this.denseKeyProvider = denseKeyProvider;\n    this.getLanguageConfiguration = getLanguageConfiguration;\n    this.languageIdToBracketTokens = new Map();\n  }\n  didLanguageChange(languageId) {\n    // Report a change whenever the language configuration updates.\n    return this.languageIdToBracketTokens.has(languageId);\n  }\n  getSingleLanguageBracketTokens(languageId) {\n    let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n    if (!singleLanguageBracketTokens) {\n      singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n      this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n    }\n    return singleLanguageBracketTokens;\n  }\n}","map":{"version":3,"names":["escapeRegExpCharacters","BracketAstNode","toLength","identityKeyProvider","SmallImmutableSet","Token","BracketTokens","constructor","map","hasRegExp","_regExpGlobal","createFromLanguage","configuration","denseKeyProvider","getId","bracketInfo","getKey","languageId","bracketText","Map","openingBracket","bracketsNew","openingBrackets","length","openingTextId","bracketIds","getEmpty","add","set","create","closingBracket","closingBrackets","getClosedBrackets","bracket","getRegExpStr","isEmpty","keys","sort","reverse","k","prepareBracketForRegExp","join","regExpGlobal","regExpStr","RegExp","getToken","value","get","toLowerCase","findClosingTokenText","openingBracketIds","closingText","info","kind","intersects","undefined","size","str","escaped","test","LanguageAgnosticBracketTokens","getLanguageConfiguration","languageIdToBracketTokens","didLanguageChange","has","getSingleLanguageBracketTokens","singleLanguageBracketTokens"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getClosedBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,sBAAsB,QAAQ,uCAAuC;AAC9E,SAASC,cAAc,QAAQ,UAAU;AACzC,SAASC,QAAQ,QAAQ,aAAa;AACtC,SAASC,mBAAmB,EAAEC,iBAAiB,QAAQ,wBAAwB;AAC/E,SAASC,KAAK,QAAQ,gBAAgB;AACtC,OAAO,MAAMC,aAAa,CAAC;EACvBC,WAAW,CAACC,GAAG,EAAE;IACb,IAAI,CAACA,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,aAAa,GAAG,IAAI;EAC7B;EACA,OAAOC,kBAAkB,CAACC,aAAa,EAAEC,gBAAgB,EAAE;IACvD,SAASC,KAAK,CAACC,WAAW,EAAE;MACxB,OAAOF,gBAAgB,CAACG,MAAM,CAAE,GAAED,WAAW,CAACE,UAAW,MAAKF,WAAW,CAACG,WAAY,EAAC,CAAC;IAC5F;IACA,MAAMV,GAAG,GAAG,IAAIW,GAAG,EAAE;IACrB,KAAK,MAAMC,cAAc,IAAIR,aAAa,CAACS,WAAW,CAACC,eAAe,EAAE;MACpE,MAAMC,MAAM,GAAGrB,QAAQ,CAAC,CAAC,EAAEkB,cAAc,CAACF,WAAW,CAACK,MAAM,CAAC;MAC7D,MAAMC,aAAa,GAAGV,KAAK,CAACM,cAAc,CAAC;MAC3C,MAAMK,UAAU,GAAGrB,iBAAiB,CAACsB,QAAQ,EAAE,CAACC,GAAG,CAACH,aAAa,EAAErB,mBAAmB,CAAC;MACvFK,GAAG,CAACoB,GAAG,CAACR,cAAc,CAACF,WAAW,EAAE,IAAIb,KAAK,CAACkB,MAAM,EAAE,CAAC,CAAC,gCAAgCC,aAAa,EAAEC,UAAU,EAAExB,cAAc,CAAC4B,MAAM,CAACN,MAAM,EAAEH,cAAc,EAAEK,UAAU,CAAC,CAAC,CAAC;IAClL;IACA,KAAK,MAAMK,cAAc,IAAIlB,aAAa,CAACS,WAAW,CAACU,eAAe,EAAE;MACpE,MAAMR,MAAM,GAAGrB,QAAQ,CAAC,CAAC,EAAE4B,cAAc,CAACZ,WAAW,CAACK,MAAM,CAAC;MAC7D,IAAIE,UAAU,GAAGrB,iBAAiB,CAACsB,QAAQ,EAAE;MAC7C,MAAMK,eAAe,GAAGD,cAAc,CAACE,iBAAiB,EAAE;MAC1D,KAAK,MAAMC,OAAO,IAAIF,eAAe,EAAE;QACnCN,UAAU,GAAGA,UAAU,CAACE,GAAG,CAACb,KAAK,CAACmB,OAAO,CAAC,EAAE9B,mBAAmB,CAAC;MACpE;MACAK,GAAG,CAACoB,GAAG,CAACE,cAAc,CAACZ,WAAW,EAAE,IAAIb,KAAK,CAACkB,MAAM,EAAE,CAAC,CAAC,gCAAgCT,KAAK,CAACiB,eAAe,CAAC,CAAC,CAAC,CAAC,EAAEN,UAAU,EAAExB,cAAc,CAAC4B,MAAM,CAACN,MAAM,EAAEO,cAAc,EAAEL,UAAU,CAAC,CAAC,CAAC;IAC9L;IACA,OAAO,IAAInB,aAAa,CAACE,GAAG,CAAC;EACjC;EACA0B,YAAY,GAAG;IACX,IAAI,IAAI,CAACC,OAAO,EAAE;MACd,OAAO,IAAI;IACf,CAAC,MACI;MACD,MAAMC,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC5B,GAAG,CAAC4B,IAAI,EAAE,CAAC;MACjCA,IAAI,CAACC,IAAI,EAAE;MACXD,IAAI,CAACE,OAAO,EAAE;MACd,OAAOF,IAAI,CAAC5B,GAAG,CAAC+B,CAAC,IAAIC,uBAAuB,CAACD,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,GAAG,CAAC;IAC9D;EACJ;EACA;AACJ;AACA;EACI,IAAIC,YAAY,GAAG;IACf,IAAI,CAAC,IAAI,CAACjC,SAAS,EAAE;MACjB,MAAMkC,SAAS,GAAG,IAAI,CAACT,YAAY,EAAE;MACrC,IAAI,CAACxB,aAAa,GAAGiC,SAAS,GAAG,IAAIC,MAAM,CAACD,SAAS,EAAE,IAAI,CAAC,GAAG,IAAI;MACnE,IAAI,CAAClC,SAAS,GAAG,IAAI;IACzB;IACA,OAAO,IAAI,CAACC,aAAa;EAC7B;EACAmC,QAAQ,CAACC,KAAK,EAAE;IACZ,OAAO,IAAI,CAACtC,GAAG,CAACuC,GAAG,CAACD,KAAK,CAACE,WAAW,EAAE,CAAC;EAC5C;EACAC,oBAAoB,CAACC,iBAAiB,EAAE;IACpC,KAAK,MAAM,CAACC,WAAW,EAAEC,IAAI,CAAC,IAAI,IAAI,CAAC5C,GAAG,EAAE;MACxC,IAAI4C,IAAI,CAACC,IAAI,KAAK,CAAC,CAAC,kCAAkCD,IAAI,CAAC3B,UAAU,CAAC6B,UAAU,CAACJ,iBAAiB,CAAC,EAAE;QACjG,OAAOC,WAAW;MACtB;IACJ;IACA,OAAOI,SAAS;EACpB;EACA,IAAIpB,OAAO,GAAG;IACV,OAAO,IAAI,CAAC3B,GAAG,CAACgD,IAAI,KAAK,CAAC;EAC9B;AACJ;AACA,SAAShB,uBAAuB,CAACiB,GAAG,EAAE;EAClC,IAAIC,OAAO,GAAG1D,sBAAsB,CAACyD,GAAG,CAAC;EACzC;EACA;EACA,IAAI,SAAS,CAACE,IAAI,CAACF,GAAG,CAAC,EAAE;IACrBC,OAAO,GAAI,MAAKA,OAAQ,EAAC;EAC7B;EACA,IAAI,SAAS,CAACC,IAAI,CAACF,GAAG,CAAC,EAAE;IACrBC,OAAO,GAAI,GAAEA,OAAQ,KAAI;EAC7B;EACA,OAAOA,OAAO;AAClB;AACA,OAAO,MAAME,6BAA6B,CAAC;EACvCrD,WAAW,CAACM,gBAAgB,EAAEgD,wBAAwB,EAAE;IACpD,IAAI,CAAChD,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACgD,wBAAwB,GAAGA,wBAAwB;IACxD,IAAI,CAACC,yBAAyB,GAAG,IAAI3C,GAAG,EAAE;EAC9C;EACA4C,iBAAiB,CAAC9C,UAAU,EAAE;IAC1B;IACA,OAAO,IAAI,CAAC6C,yBAAyB,CAACE,GAAG,CAAC/C,UAAU,CAAC;EACzD;EACAgD,8BAA8B,CAAChD,UAAU,EAAE;IACvC,IAAIiD,2BAA2B,GAAG,IAAI,CAACJ,yBAAyB,CAACf,GAAG,CAAC9B,UAAU,CAAC;IAChF,IAAI,CAACiD,2BAA2B,EAAE;MAC9BA,2BAA2B,GAAG5D,aAAa,CAACK,kBAAkB,CAAC,IAAI,CAACkD,wBAAwB,CAAC5C,UAAU,CAAC,EAAE,IAAI,CAACJ,gBAAgB,CAAC;MAChI,IAAI,CAACiD,yBAAyB,CAAClC,GAAG,CAACX,UAAU,EAAEiD,2BAA2B,CAAC;IAC/E;IACA,OAAOA,2BAA2B;EACtC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}