{"ast":null,"code":"const hasBuffer = typeof Buffer !== 'undefined';\nlet textDecoder;\nexport class VSBuffer {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.byteLength = this.buffer.byteLength;\n  }\n  /**\n   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n   * which is not transferrable.\n   */\n  static wrap(actual) {\n    if (hasBuffer && !Buffer.isBuffer(actual)) {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n      // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n    }\n    return new VSBuffer(actual);\n  }\n  toString() {\n    if (hasBuffer) {\n      return this.buffer.toString();\n    } else {\n      if (!textDecoder) {\n        textDecoder = new TextDecoder();\n      }\n      return textDecoder.decode(this.buffer);\n    }\n  }\n}\nexport function readUInt16LE(source, offset) {\n  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;\n}\nexport function writeUInt16LE(destination, value, offset) {\n  destination[offset + 0] = value & 0b11111111;\n  value = value >>> 8;\n  destination[offset + 1] = value & 0b11111111;\n}\nexport function readUInt32BE(source, offset) {\n  return source[offset] * Math.pow(2, 24) + source[offset + 1] * Math.pow(2, 16) + source[offset + 2] * Math.pow(2, 8) + source[offset + 3];\n}\nexport function writeUInt32BE(destination, value, offset) {\n  destination[offset + 3] = value;\n  value = value >>> 8;\n  destination[offset + 2] = value;\n  value = value >>> 8;\n  destination[offset + 1] = value;\n  value = value >>> 8;\n  destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n  return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n  destination[offset] = value;\n}","map":{"version":3,"names":["hasBuffer","Buffer","textDecoder","VSBuffer","constructor","buffer","byteLength","wrap","actual","isBuffer","from","byteOffset","toString","TextDecoder","decode","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","Math","pow","writeUInt32BE","readUInt8","writeUInt8"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/base/common/buffer.js"],"sourcesContent":["const hasBuffer = (typeof Buffer !== 'undefined');\nlet textDecoder;\nexport class VSBuffer {\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * Math.pow(2, 24)\n        + source[offset + 1] * Math.pow(2, 16)\n        + source[offset + 2] * Math.pow(2, 8)\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n"],"mappings":"AAAA,MAAMA,SAAS,GAAI,OAAOC,MAAM,KAAK,WAAY;AACjD,IAAIC,WAAW;AACf,OAAO,MAAMC,QAAQ,CAAC;EAClBC,WAAW,CAACC,MAAM,EAAE;IAChB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,UAAU,GAAG,IAAI,CAACD,MAAM,CAACC,UAAU;EAC5C;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOC,IAAI,CAACC,MAAM,EAAE;IAChB,IAAIR,SAAS,IAAI,CAAEC,MAAM,CAACQ,QAAQ,CAACD,MAAM,CAAE,EAAE;MACzC;MACA;MACAA,MAAM,GAAGP,MAAM,CAACS,IAAI,CAACF,MAAM,CAACH,MAAM,EAAEG,MAAM,CAACG,UAAU,EAAEH,MAAM,CAACF,UAAU,CAAC;IAC7E;IACA,OAAO,IAAIH,QAAQ,CAACK,MAAM,CAAC;EAC/B;EACAI,QAAQ,GAAG;IACP,IAAIZ,SAAS,EAAE;MACX,OAAO,IAAI,CAACK,MAAM,CAACO,QAAQ,EAAE;IACjC,CAAC,MACI;MACD,IAAI,CAACV,WAAW,EAAE;QACdA,WAAW,GAAG,IAAIW,WAAW,EAAE;MACnC;MACA,OAAOX,WAAW,CAACY,MAAM,CAAC,IAAI,CAACT,MAAM,CAAC;IAC1C;EACJ;AACJ;AACA,OAAO,SAASU,YAAY,CAACC,MAAM,EAAEC,MAAM,EAAE;EACzC,OAAUD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAM,CAAC,GAClCD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAM,CAAE;AACzC;AACA,OAAO,SAASC,aAAa,CAACC,WAAW,EAAEC,KAAK,EAAEH,MAAM,EAAE;EACtDE,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAIG,KAAK,GAAG,UAAW;EAC9CA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBD,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAIG,KAAK,GAAG,UAAW;AAClD;AACA,OAAO,SAASC,YAAY,CAACL,MAAM,EAAEC,MAAM,EAAE;EACzC,OAAQD,MAAM,CAACC,MAAM,CAAC,GAAGK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAClCP,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GACpCP,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GACnCP,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC;AAC5B;AACA,OAAO,SAASO,aAAa,CAACL,WAAW,EAAEC,KAAK,EAAEH,MAAM,EAAE;EACtDE,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAGG,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBD,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAGG,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBD,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAGG,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBD,WAAW,CAACF,MAAM,CAAC,GAAGG,KAAK;AAC/B;AACA,OAAO,SAASK,SAAS,CAACT,MAAM,EAAEC,MAAM,EAAE;EACtC,OAAOD,MAAM,CAACC,MAAM,CAAC;AACzB;AACA,OAAO,SAASS,UAAU,CAACP,WAAW,EAAEC,KAAK,EAAEH,MAAM,EAAE;EACnDE,WAAW,CAACF,MAAM,CAAC,GAAGG,KAAK;AAC/B"},"metadata":{},"sourceType":"module","externalDependencies":[]}