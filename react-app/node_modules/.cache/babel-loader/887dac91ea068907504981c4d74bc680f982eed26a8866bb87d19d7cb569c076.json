{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { IMenuService, isIMenuItem, MenuItemAction, MenuRegistry, SubmenuItemAction } from './actions.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { toAction } from '../../../base/common/actions.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { removeFastWithoutKeepingOrder } from '../../../base/common/arrays.js';\nimport { localize } from '../../../nls.js';\nlet MenuService = class MenuService {\n  constructor(_commandService, storageService) {\n    this._commandService = _commandService;\n    this._hiddenStates = new PersistedMenuHideState(storageService);\n  }\n  createMenu(id, contextKeyService, options) {\n    return new Menu(id, this._hiddenStates, Object.assign({\n      emitEventsForSubmenuChanges: false,\n      eventDebounceDelay: 50\n    }, options), this._commandService, contextKeyService, this);\n  }\n};\nMenuService = __decorate([__param(0, ICommandService), __param(1, IStorageService)], MenuService);\nexport { MenuService };\nlet PersistedMenuHideState = class PersistedMenuHideState {\n  constructor(_storageService) {\n    this._storageService = _storageService;\n    this._disposables = new DisposableStore();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n    this._ignoreChangeEvent = false;\n    try {\n      const raw = _storageService.get(PersistedMenuHideState._key, 0 /* StorageScope.PROFILE */, '{}');\n      this._data = JSON.parse(raw);\n    } catch (err) {\n      this._data = Object.create(null);\n    }\n    this._disposables.add(_storageService.onDidChangeValue(e => {\n      if (e.key !== PersistedMenuHideState._key) {\n        return;\n      }\n      if (!this._ignoreChangeEvent) {\n        try {\n          const raw = _storageService.get(PersistedMenuHideState._key, 0 /* StorageScope.PROFILE */, '{}');\n          this._data = JSON.parse(raw);\n        } catch (err) {\n          console.log('FAILED to read storage after UPDATE', err);\n        }\n      }\n      this._onDidChange.fire();\n    }));\n  }\n  dispose() {\n    this._onDidChange.dispose();\n    this._disposables.dispose();\n  }\n  isHidden(menu, commandId) {\n    var _a, _b;\n    return (_b = (_a = this._data[menu.id]) === null || _a === void 0 ? void 0 : _a.includes(commandId)) !== null && _b !== void 0 ? _b : false;\n  }\n  updateHidden(menu, commandId, hidden) {\n    const entries = this._data[menu.id];\n    if (!hidden) {\n      // remove and cleanup\n      if (entries) {\n        const idx = entries.indexOf(commandId);\n        if (idx >= 0) {\n          removeFastWithoutKeepingOrder(entries, idx);\n        }\n        if (entries.length === 0) {\n          delete this._data[menu.id];\n        }\n      }\n    } else {\n      // add unless already added\n      if (!entries) {\n        this._data[menu.id] = [commandId];\n      } else {\n        const idx = entries.indexOf(commandId);\n        if (idx < 0) {\n          entries.push(commandId);\n        }\n      }\n    }\n    this._persist();\n  }\n  _persist() {\n    try {\n      this._ignoreChangeEvent = true;\n      const raw = JSON.stringify(this._data);\n      this._storageService.store(PersistedMenuHideState._key, raw, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n    } finally {\n      this._ignoreChangeEvent = false;\n    }\n  }\n};\nPersistedMenuHideState._key = 'menu.hiddenCommands';\nPersistedMenuHideState = __decorate([__param(0, IStorageService)], PersistedMenuHideState);\nlet Menu = class Menu {\n  constructor(_id, _hiddenStates, _options, _commandService, _contextKeyService, _menuService) {\n    this._id = _id;\n    this._hiddenStates = _hiddenStates;\n    this._options = _options;\n    this._commandService = _commandService;\n    this._contextKeyService = _contextKeyService;\n    this._menuService = _menuService;\n    this._disposables = new DisposableStore();\n    this._menuGroups = [];\n    this._contextKeys = new Set();\n    this._build();\n    // Rebuild this menu whenever the menu registry reports an event for this MenuId.\n    // This usually happen while code and extensions are loaded and affects the over\n    // structure of the menu\n    const rebuildMenuSoon = new RunOnceScheduler(() => {\n      this._build();\n      this._onDidChange.fire(this);\n    }, _options.eventDebounceDelay);\n    this._disposables.add(rebuildMenuSoon);\n    this._disposables.add(MenuRegistry.onDidChangeMenu(e => {\n      if (e.has(_id)) {\n        rebuildMenuSoon.schedule();\n      }\n    }));\n    // When context keys or storage state changes we need to check if the menu also has changed. However,\n    // we only do that when someone listens on this menu because (1) these events are\n    // firing often and (2) menu are often leaked\n    const lazyListener = this._disposables.add(new DisposableStore());\n    const startLazyListener = () => {\n      const fireChangeSoon = new RunOnceScheduler(() => this._onDidChange.fire(this), _options.eventDebounceDelay);\n      lazyListener.add(fireChangeSoon);\n      lazyListener.add(_contextKeyService.onDidChangeContext(e => {\n        if (e.affectsSome(this._contextKeys)) {\n          fireChangeSoon.schedule();\n        }\n      }));\n      lazyListener.add(_hiddenStates.onDidChange(() => {\n        fireChangeSoon.schedule();\n      }));\n    };\n    this._onDidChange = new Emitter({\n      // start/stop context key listener\n      onFirstListenerAdd: startLazyListener,\n      onLastListenerRemove: lazyListener.clear.bind(lazyListener)\n    });\n    this.onDidChange = this._onDidChange.event;\n  }\n  dispose() {\n    this._disposables.dispose();\n    this._onDidChange.dispose();\n  }\n  _build() {\n    // reset\n    this._menuGroups.length = 0;\n    this._contextKeys.clear();\n    const menuItems = MenuRegistry.getMenuItems(this._id);\n    let group;\n    menuItems.sort(Menu._compareMenuItems);\n    for (const item of menuItems) {\n      // group by groupId\n      const groupName = item.group || '';\n      if (!group || group[0] !== groupName) {\n        group = [groupName, []];\n        this._menuGroups.push(group);\n      }\n      group[1].push(item);\n      // keep keys for eventing\n      this._collectContextKeys(item);\n    }\n  }\n  _collectContextKeys(item) {\n    Menu._fillInKbExprKeys(item.when, this._contextKeys);\n    if (isIMenuItem(item)) {\n      // keep precondition keys for event if applicable\n      if (item.command.precondition) {\n        Menu._fillInKbExprKeys(item.command.precondition, this._contextKeys);\n      }\n      // keep toggled keys for event if applicable\n      if (item.command.toggled) {\n        const toggledExpression = item.command.toggled.condition || item.command.toggled;\n        Menu._fillInKbExprKeys(toggledExpression, this._contextKeys);\n      }\n    } else if (this._options.emitEventsForSubmenuChanges) {\n      // recursively collect context keys from submenus so that this\n      // menu fires events when context key changes affect submenus\n      MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeys, this);\n    }\n  }\n  getActions(options) {\n    const result = [];\n    const allToggleActions = [];\n    for (const group of this._menuGroups) {\n      const [id, items] = group;\n      const toggleActions = [];\n      const activeActions = [];\n      for (const item of items) {\n        if (this._contextKeyService.contextMatchesRules(item.when)) {\n          let action;\n          const isMenuItem = isIMenuItem(item);\n          if (isMenuItem) {\n            const menuHide = createMenuHide(this._id, item.command, this._hiddenStates);\n            action = new MenuItemAction(item.command, item.alt, options, menuHide, this._contextKeyService, this._commandService);\n          } else {\n            action = new SubmenuItemAction(item, this._menuService, this._contextKeyService, options);\n            if (action.actions.length === 0) {\n              action.dispose();\n              action = undefined;\n            }\n          }\n          if (action) {\n            activeActions.push(action);\n          }\n        }\n      }\n      if (activeActions.length > 0) {\n        result.push([id, activeActions]);\n      }\n      if (toggleActions.length > 0) {\n        allToggleActions.push(toggleActions);\n      }\n    }\n    return result;\n  }\n  static _fillInKbExprKeys(exp, set) {\n    if (exp) {\n      for (const key of exp.keys()) {\n        set.add(key);\n      }\n    }\n  }\n  static _compareMenuItems(a, b) {\n    const aGroup = a.group;\n    const bGroup = b.group;\n    if (aGroup !== bGroup) {\n      // Falsy groups come last\n      if (!aGroup) {\n        return 1;\n      } else if (!bGroup) {\n        return -1;\n      }\n      // 'navigation' group comes first\n      if (aGroup === 'navigation') {\n        return -1;\n      } else if (bGroup === 'navigation') {\n        return 1;\n      }\n      // lexical sort for groups\n      const value = aGroup.localeCompare(bGroup);\n      if (value !== 0) {\n        return value;\n      }\n    }\n    // sort on priority - default is 0\n    const aPrio = a.order || 0;\n    const bPrio = b.order || 0;\n    if (aPrio < bPrio) {\n      return -1;\n    } else if (aPrio > bPrio) {\n      return 1;\n    }\n    // sort on titles\n    return Menu._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);\n  }\n  static _compareTitles(a, b) {\n    const aStr = typeof a === 'string' ? a : a.original;\n    const bStr = typeof b === 'string' ? b : b.original;\n    return aStr.localeCompare(bStr);\n  }\n};\nMenu = __decorate([__param(3, ICommandService), __param(4, IContextKeyService), __param(5, IMenuService)], Menu);\nfunction createMenuHide(menu, command, states) {\n  const id = `${menu.id}/${command.id}`;\n  const title = typeof command.title === 'string' ? command.title : command.title.value;\n  const hide = toAction({\n    id,\n    label: localize('hide.label', 'Hide \\'{0}\\'', title),\n    run() {\n      states.updateHidden(menu, command.id, true);\n    }\n  });\n  const toggle = toAction({\n    id,\n    label: title,\n    get checked() {\n      return !states.isHidden(menu, command.id);\n    },\n    run() {\n      const newValue = !states.isHidden(menu, command.id);\n      states.updateHidden(menu, command.id, newValue);\n    }\n  });\n  return {\n    hide,\n    toggle,\n    get isHidden() {\n      return !toggle.checked;\n    }\n  };\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","RunOnceScheduler","Emitter","DisposableStore","IMenuService","isIMenuItem","MenuItemAction","MenuRegistry","SubmenuItemAction","ICommandService","IContextKeyService","toAction","IStorageService","removeFastWithoutKeepingOrder","localize","MenuService","constructor","_commandService","storageService","_hiddenStates","PersistedMenuHideState","createMenu","id","contextKeyService","options","Menu","assign","emitEventsForSubmenuChanges","eventDebounceDelay","_storageService","_disposables","_onDidChange","onDidChange","event","_ignoreChangeEvent","raw","get","_key","_data","JSON","parse","err","create","add","onDidChangeValue","e","console","log","fire","dispose","isHidden","menu","commandId","_a","_b","includes","updateHidden","hidden","entries","idx","indexOf","push","_persist","stringify","store","_id","_options","_contextKeyService","_menuService","_menuGroups","_contextKeys","Set","_build","rebuildMenuSoon","onDidChangeMenu","has","schedule","lazyListener","startLazyListener","fireChangeSoon","onDidChangeContext","affectsSome","onFirstListenerAdd","onLastListenerRemove","clear","bind","menuItems","getMenuItems","group","sort","_compareMenuItems","item","groupName","_collectContextKeys","_fillInKbExprKeys","when","command","precondition","toggled","toggledExpression","condition","submenu","forEach","getActions","result","allToggleActions","items","toggleActions","activeActions","contextMatchesRules","action","isMenuItem","menuHide","createMenuHide","alt","actions","undefined","exp","set","keys","a","b","aGroup","bGroup","value","localeCompare","aPrio","order","bPrio","_compareTitles","title","aStr","original","bStr","states","hide","label","run","toggle","checked","newValue"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/platform/actions/common/menuService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { IMenuService, isIMenuItem, MenuItemAction, MenuRegistry, SubmenuItemAction } from './actions.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { toAction } from '../../../base/common/actions.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { removeFastWithoutKeepingOrder } from '../../../base/common/arrays.js';\nimport { localize } from '../../../nls.js';\nlet MenuService = class MenuService {\n    constructor(_commandService, storageService) {\n        this._commandService = _commandService;\n        this._hiddenStates = new PersistedMenuHideState(storageService);\n    }\n    createMenu(id, contextKeyService, options) {\n        return new Menu(id, this._hiddenStates, Object.assign({ emitEventsForSubmenuChanges: false, eventDebounceDelay: 50 }, options), this._commandService, contextKeyService, this);\n    }\n};\nMenuService = __decorate([\n    __param(0, ICommandService),\n    __param(1, IStorageService)\n], MenuService);\nexport { MenuService };\nlet PersistedMenuHideState = class PersistedMenuHideState {\n    constructor(_storageService) {\n        this._storageService = _storageService;\n        this._disposables = new DisposableStore();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._ignoreChangeEvent = false;\n        try {\n            const raw = _storageService.get(PersistedMenuHideState._key, 0 /* StorageScope.PROFILE */, '{}');\n            this._data = JSON.parse(raw);\n        }\n        catch (err) {\n            this._data = Object.create(null);\n        }\n        this._disposables.add(_storageService.onDidChangeValue(e => {\n            if (e.key !== PersistedMenuHideState._key) {\n                return;\n            }\n            if (!this._ignoreChangeEvent) {\n                try {\n                    const raw = _storageService.get(PersistedMenuHideState._key, 0 /* StorageScope.PROFILE */, '{}');\n                    this._data = JSON.parse(raw);\n                }\n                catch (err) {\n                    console.log('FAILED to read storage after UPDATE', err);\n                }\n            }\n            this._onDidChange.fire();\n        }));\n    }\n    dispose() {\n        this._onDidChange.dispose();\n        this._disposables.dispose();\n    }\n    isHidden(menu, commandId) {\n        var _a, _b;\n        return (_b = (_a = this._data[menu.id]) === null || _a === void 0 ? void 0 : _a.includes(commandId)) !== null && _b !== void 0 ? _b : false;\n    }\n    updateHidden(menu, commandId, hidden) {\n        const entries = this._data[menu.id];\n        if (!hidden) {\n            // remove and cleanup\n            if (entries) {\n                const idx = entries.indexOf(commandId);\n                if (idx >= 0) {\n                    removeFastWithoutKeepingOrder(entries, idx);\n                }\n                if (entries.length === 0) {\n                    delete this._data[menu.id];\n                }\n            }\n        }\n        else {\n            // add unless already added\n            if (!entries) {\n                this._data[menu.id] = [commandId];\n            }\n            else {\n                const idx = entries.indexOf(commandId);\n                if (idx < 0) {\n                    entries.push(commandId);\n                }\n            }\n        }\n        this._persist();\n    }\n    _persist() {\n        try {\n            this._ignoreChangeEvent = true;\n            const raw = JSON.stringify(this._data);\n            this._storageService.store(PersistedMenuHideState._key, raw, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n        }\n        finally {\n            this._ignoreChangeEvent = false;\n        }\n    }\n};\nPersistedMenuHideState._key = 'menu.hiddenCommands';\nPersistedMenuHideState = __decorate([\n    __param(0, IStorageService)\n], PersistedMenuHideState);\nlet Menu = class Menu {\n    constructor(_id, _hiddenStates, _options, _commandService, _contextKeyService, _menuService) {\n        this._id = _id;\n        this._hiddenStates = _hiddenStates;\n        this._options = _options;\n        this._commandService = _commandService;\n        this._contextKeyService = _contextKeyService;\n        this._menuService = _menuService;\n        this._disposables = new DisposableStore();\n        this._menuGroups = [];\n        this._contextKeys = new Set();\n        this._build();\n        // Rebuild this menu whenever the menu registry reports an event for this MenuId.\n        // This usually happen while code and extensions are loaded and affects the over\n        // structure of the menu\n        const rebuildMenuSoon = new RunOnceScheduler(() => {\n            this._build();\n            this._onDidChange.fire(this);\n        }, _options.eventDebounceDelay);\n        this._disposables.add(rebuildMenuSoon);\n        this._disposables.add(MenuRegistry.onDidChangeMenu(e => {\n            if (e.has(_id)) {\n                rebuildMenuSoon.schedule();\n            }\n        }));\n        // When context keys or storage state changes we need to check if the menu also has changed. However,\n        // we only do that when someone listens on this menu because (1) these events are\n        // firing often and (2) menu are often leaked\n        const lazyListener = this._disposables.add(new DisposableStore());\n        const startLazyListener = () => {\n            const fireChangeSoon = new RunOnceScheduler(() => this._onDidChange.fire(this), _options.eventDebounceDelay);\n            lazyListener.add(fireChangeSoon);\n            lazyListener.add(_contextKeyService.onDidChangeContext(e => {\n                if (e.affectsSome(this._contextKeys)) {\n                    fireChangeSoon.schedule();\n                }\n            }));\n            lazyListener.add(_hiddenStates.onDidChange(() => {\n                fireChangeSoon.schedule();\n            }));\n        };\n        this._onDidChange = new Emitter({\n            // start/stop context key listener\n            onFirstListenerAdd: startLazyListener,\n            onLastListenerRemove: lazyListener.clear.bind(lazyListener)\n        });\n        this.onDidChange = this._onDidChange.event;\n    }\n    dispose() {\n        this._disposables.dispose();\n        this._onDidChange.dispose();\n    }\n    _build() {\n        // reset\n        this._menuGroups.length = 0;\n        this._contextKeys.clear();\n        const menuItems = MenuRegistry.getMenuItems(this._id);\n        let group;\n        menuItems.sort(Menu._compareMenuItems);\n        for (const item of menuItems) {\n            // group by groupId\n            const groupName = item.group || '';\n            if (!group || group[0] !== groupName) {\n                group = [groupName, []];\n                this._menuGroups.push(group);\n            }\n            group[1].push(item);\n            // keep keys for eventing\n            this._collectContextKeys(item);\n        }\n    }\n    _collectContextKeys(item) {\n        Menu._fillInKbExprKeys(item.when, this._contextKeys);\n        if (isIMenuItem(item)) {\n            // keep precondition keys for event if applicable\n            if (item.command.precondition) {\n                Menu._fillInKbExprKeys(item.command.precondition, this._contextKeys);\n            }\n            // keep toggled keys for event if applicable\n            if (item.command.toggled) {\n                const toggledExpression = item.command.toggled.condition || item.command.toggled;\n                Menu._fillInKbExprKeys(toggledExpression, this._contextKeys);\n            }\n        }\n        else if (this._options.emitEventsForSubmenuChanges) {\n            // recursively collect context keys from submenus so that this\n            // menu fires events when context key changes affect submenus\n            MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeys, this);\n        }\n    }\n    getActions(options) {\n        const result = [];\n        const allToggleActions = [];\n        for (const group of this._menuGroups) {\n            const [id, items] = group;\n            const toggleActions = [];\n            const activeActions = [];\n            for (const item of items) {\n                if (this._contextKeyService.contextMatchesRules(item.when)) {\n                    let action;\n                    const isMenuItem = isIMenuItem(item);\n                    if (isMenuItem) {\n                        const menuHide = createMenuHide(this._id, item.command, this._hiddenStates);\n                        action = new MenuItemAction(item.command, item.alt, options, menuHide, this._contextKeyService, this._commandService);\n                    }\n                    else {\n                        action = new SubmenuItemAction(item, this._menuService, this._contextKeyService, options);\n                        if (action.actions.length === 0) {\n                            action.dispose();\n                            action = undefined;\n                        }\n                    }\n                    if (action) {\n                        activeActions.push(action);\n                    }\n                }\n            }\n            if (activeActions.length > 0) {\n                result.push([id, activeActions]);\n            }\n            if (toggleActions.length > 0) {\n                allToggleActions.push(toggleActions);\n            }\n        }\n        return result;\n    }\n    static _fillInKbExprKeys(exp, set) {\n        if (exp) {\n            for (const key of exp.keys()) {\n                set.add(key);\n            }\n        }\n    }\n    static _compareMenuItems(a, b) {\n        const aGroup = a.group;\n        const bGroup = b.group;\n        if (aGroup !== bGroup) {\n            // Falsy groups come last\n            if (!aGroup) {\n                return 1;\n            }\n            else if (!bGroup) {\n                return -1;\n            }\n            // 'navigation' group comes first\n            if (aGroup === 'navigation') {\n                return -1;\n            }\n            else if (bGroup === 'navigation') {\n                return 1;\n            }\n            // lexical sort for groups\n            const value = aGroup.localeCompare(bGroup);\n            if (value !== 0) {\n                return value;\n            }\n        }\n        // sort on priority - default is 0\n        const aPrio = a.order || 0;\n        const bPrio = b.order || 0;\n        if (aPrio < bPrio) {\n            return -1;\n        }\n        else if (aPrio > bPrio) {\n            return 1;\n        }\n        // sort on titles\n        return Menu._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);\n    }\n    static _compareTitles(a, b) {\n        const aStr = typeof a === 'string' ? a : a.original;\n        const bStr = typeof b === 'string' ? b : b.original;\n        return aStr.localeCompare(bStr);\n    }\n};\nMenu = __decorate([\n    __param(3, ICommandService),\n    __param(4, IContextKeyService),\n    __param(5, IMenuService)\n], Menu);\nfunction createMenuHide(menu, command, states) {\n    const id = `${menu.id}/${command.id}`;\n    const title = typeof command.title === 'string' ? command.title : command.title.value;\n    const hide = toAction({\n        id,\n        label: localize('hide.label', 'Hide \\'{0}\\'', title),\n        run() { states.updateHidden(menu, command.id, true); }\n    });\n    const toggle = toAction({\n        id,\n        label: title,\n        get checked() { return !states.isHidden(menu, command.id); },\n        run() {\n            const newValue = !states.isHidden(menu, command.id);\n            states.updateHidden(menu, command.id, newValue);\n        }\n    });\n    return {\n        hide,\n        toggle,\n        get isHidden() { return !toggle.checked; },\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,UAAU,GAAI,IAAI,IAAI,IAAI,CAACA,UAAU,IAAK,UAAUC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE;EACnF,IAAIC,CAAC,GAAGC,SAAS,CAACC,MAAM;IAAEC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGH,MAAM,GAAGE,IAAI,KAAK,IAAI,GAAGA,IAAI,GAAGK,MAAM,CAACC,wBAAwB,CAACR,MAAM,EAAEC,GAAG,CAAC,GAAGC,IAAI;IAAEO,CAAC;EAC5H,IAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAACC,QAAQ,KAAK,UAAU,EAAEL,CAAC,GAAGI,OAAO,CAACC,QAAQ,CAACZ,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,CAAC,CAAC,KAC1H,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAM,GAAG,CAAC,EAAEO,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAC,CAAC,EAAEN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACH,CAAC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACT,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,GAAGG,CAAC,CAACT,MAAM,EAAEC,GAAG,CAAC,KAAKK,CAAC;EACjJ,OAAOH,CAAC,GAAG,CAAC,IAAIG,CAAC,IAAIC,MAAM,CAACM,cAAc,CAACb,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,EAAEA,CAAC;AACjE,CAAC;AACD,IAAIQ,OAAO,GAAI,IAAI,IAAI,IAAI,CAACA,OAAO,IAAK,UAAUC,UAAU,EAAEC,SAAS,EAAE;EACrE,OAAO,UAAUhB,MAAM,EAAEC,GAAG,EAAE;IAAEe,SAAS,CAAChB,MAAM,EAAEC,GAAG,EAAEc,UAAU,CAAC;EAAE,CAAC;AACzE,CAAC;AACD,SAASE,gBAAgB,QAAQ,+BAA+B;AAChE,SAASC,OAAO,QAAQ,+BAA+B;AACvD,SAASC,eAAe,QAAQ,mCAAmC;AACnE,SAASC,YAAY,EAAEC,WAAW,EAAEC,cAAc,EAAEC,YAAY,EAAEC,iBAAiB,QAAQ,cAAc;AACzG,SAASC,eAAe,QAAQ,mCAAmC;AACnE,SAASC,kBAAkB,QAAQ,uCAAuC;AAC1E,SAASC,QAAQ,QAAQ,iCAAiC;AAC1D,SAASC,eAAe,QAAQ,iCAAiC;AACjE,SAASC,6BAA6B,QAAQ,gCAAgC;AAC9E,SAASC,QAAQ,QAAQ,iBAAiB;AAC1C,IAAIC,WAAW,GAAG,MAAMA,WAAW,CAAC;EAChCC,WAAW,CAACC,eAAe,EAAEC,cAAc,EAAE;IACzC,IAAI,CAACD,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACE,aAAa,GAAG,IAAIC,sBAAsB,CAACF,cAAc,CAAC;EACnE;EACAG,UAAU,CAACC,EAAE,EAAEC,iBAAiB,EAAEC,OAAO,EAAE;IACvC,OAAO,IAAIC,IAAI,CAACH,EAAE,EAAE,IAAI,CAACH,aAAa,EAAE5B,MAAM,CAACmC,MAAM,CAAC;MAAEC,2BAA2B,EAAE,KAAK;MAAEC,kBAAkB,EAAE;IAAG,CAAC,EAAEJ,OAAO,CAAC,EAAE,IAAI,CAACP,eAAe,EAAEM,iBAAiB,EAAE,IAAI,CAAC;EAClL;AACJ,CAAC;AACDR,WAAW,GAAGjC,UAAU,CAAC,CACrBgB,OAAO,CAAC,CAAC,EAAEW,eAAe,CAAC,EAC3BX,OAAO,CAAC,CAAC,EAAEc,eAAe,CAAC,CAC9B,EAAEG,WAAW,CAAC;AACf,SAASA,WAAW;AACpB,IAAIK,sBAAsB,GAAG,MAAMA,sBAAsB,CAAC;EACtDJ,WAAW,CAACa,eAAe,EAAE;IACzB,IAAI,CAACA,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,YAAY,GAAG,IAAI3B,eAAe,EAAE;IACzC,IAAI,CAAC4B,YAAY,GAAG,IAAI7B,OAAO,EAAE;IACjC,IAAI,CAAC8B,WAAW,GAAG,IAAI,CAACD,YAAY,CAACE,KAAK;IAC1C,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B,IAAI;MACA,MAAMC,GAAG,GAAGN,eAAe,CAACO,GAAG,CAAChB,sBAAsB,CAACiB,IAAI,EAAE,CAAC,CAAC,4BAA4B,IAAI,CAAC;MAChG,IAAI,CAACC,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACL,GAAG,CAAC;IAChC,CAAC,CACD,OAAOM,GAAG,EAAE;MACR,IAAI,CAACH,KAAK,GAAG/C,MAAM,CAACmD,MAAM,CAAC,IAAI,CAAC;IACpC;IACA,IAAI,CAACZ,YAAY,CAACa,GAAG,CAACd,eAAe,CAACe,gBAAgB,CAACC,CAAC,IAAI;MACxD,IAAIA,CAAC,CAAC5D,GAAG,KAAKmC,sBAAsB,CAACiB,IAAI,EAAE;QACvC;MACJ;MACA,IAAI,CAAC,IAAI,CAACH,kBAAkB,EAAE;QAC1B,IAAI;UACA,MAAMC,GAAG,GAAGN,eAAe,CAACO,GAAG,CAAChB,sBAAsB,CAACiB,IAAI,EAAE,CAAC,CAAC,4BAA4B,IAAI,CAAC;UAChG,IAAI,CAACC,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACL,GAAG,CAAC;QAChC,CAAC,CACD,OAAOM,GAAG,EAAE;UACRK,OAAO,CAACC,GAAG,CAAC,qCAAqC,EAAEN,GAAG,CAAC;QAC3D;MACJ;MACA,IAAI,CAACV,YAAY,CAACiB,IAAI,EAAE;IAC5B,CAAC,CAAC,CAAC;EACP;EACAC,OAAO,GAAG;IACN,IAAI,CAAClB,YAAY,CAACkB,OAAO,EAAE;IAC3B,IAAI,CAACnB,YAAY,CAACmB,OAAO,EAAE;EAC/B;EACAC,QAAQ,CAACC,IAAI,EAAEC,SAAS,EAAE;IACtB,IAAIC,EAAE,EAAEC,EAAE;IACV,OAAO,CAACA,EAAE,GAAG,CAACD,EAAE,GAAG,IAAI,CAACf,KAAK,CAACa,IAAI,CAAC7B,EAAE,CAAC,MAAM,IAAI,IAAI+B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,QAAQ,CAACH,SAAS,CAAC,MAAM,IAAI,IAAIE,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,KAAK;EAC/I;EACAE,YAAY,CAACL,IAAI,EAAEC,SAAS,EAAEK,MAAM,EAAE;IAClC,MAAMC,OAAO,GAAG,IAAI,CAACpB,KAAK,CAACa,IAAI,CAAC7B,EAAE,CAAC;IACnC,IAAI,CAACmC,MAAM,EAAE;MACT;MACA,IAAIC,OAAO,EAAE;QACT,MAAMC,GAAG,GAAGD,OAAO,CAACE,OAAO,CAACR,SAAS,CAAC;QACtC,IAAIO,GAAG,IAAI,CAAC,EAAE;UACV9C,6BAA6B,CAAC6C,OAAO,EAAEC,GAAG,CAAC;QAC/C;QACA,IAAID,OAAO,CAACrE,MAAM,KAAK,CAAC,EAAE;UACtB,OAAO,IAAI,CAACiD,KAAK,CAACa,IAAI,CAAC7B,EAAE,CAAC;QAC9B;MACJ;IACJ,CAAC,MACI;MACD;MACA,IAAI,CAACoC,OAAO,EAAE;QACV,IAAI,CAACpB,KAAK,CAACa,IAAI,CAAC7B,EAAE,CAAC,GAAG,CAAC8B,SAAS,CAAC;MACrC,CAAC,MACI;QACD,MAAMO,GAAG,GAAGD,OAAO,CAACE,OAAO,CAACR,SAAS,CAAC;QACtC,IAAIO,GAAG,GAAG,CAAC,EAAE;UACTD,OAAO,CAACG,IAAI,CAACT,SAAS,CAAC;QAC3B;MACJ;IACJ;IACA,IAAI,CAACU,QAAQ,EAAE;EACnB;EACAA,QAAQ,GAAG;IACP,IAAI;MACA,IAAI,CAAC5B,kBAAkB,GAAG,IAAI;MAC9B,MAAMC,GAAG,GAAGI,IAAI,CAACwB,SAAS,CAAC,IAAI,CAACzB,KAAK,CAAC;MACtC,IAAI,CAACT,eAAe,CAACmC,KAAK,CAAC5C,sBAAsB,CAACiB,IAAI,EAAEF,GAAG,EAAE,CAAC,CAAC,4BAA4B,CAAC,CAAC,yBAAyB;IAC1H,CAAC,SACO;MACJ,IAAI,CAACD,kBAAkB,GAAG,KAAK;IACnC;EACJ;AACJ,CAAC;AACDd,sBAAsB,CAACiB,IAAI,GAAG,qBAAqB;AACnDjB,sBAAsB,GAAGtC,UAAU,CAAC,CAChCgB,OAAO,CAAC,CAAC,EAAEc,eAAe,CAAC,CAC9B,EAAEQ,sBAAsB,CAAC;AAC1B,IAAIK,IAAI,GAAG,MAAMA,IAAI,CAAC;EAClBT,WAAW,CAACiD,GAAG,EAAE9C,aAAa,EAAE+C,QAAQ,EAAEjD,eAAe,EAAEkD,kBAAkB,EAAEC,YAAY,EAAE;IACzF,IAAI,CAACH,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC9C,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAC+C,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACjD,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACkD,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACtC,YAAY,GAAG,IAAI3B,eAAe,EAAE;IACzC,IAAI,CAACkE,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,YAAY,GAAG,IAAIC,GAAG,EAAE;IAC7B,IAAI,CAACC,MAAM,EAAE;IACb;IACA;IACA;IACA,MAAMC,eAAe,GAAG,IAAIxE,gBAAgB,CAAC,MAAM;MAC/C,IAAI,CAACuE,MAAM,EAAE;MACb,IAAI,CAACzC,YAAY,CAACiB,IAAI,CAAC,IAAI,CAAC;IAChC,CAAC,EAAEkB,QAAQ,CAACtC,kBAAkB,CAAC;IAC/B,IAAI,CAACE,YAAY,CAACa,GAAG,CAAC8B,eAAe,CAAC;IACtC,IAAI,CAAC3C,YAAY,CAACa,GAAG,CAACpC,YAAY,CAACmE,eAAe,CAAC7B,CAAC,IAAI;MACpD,IAAIA,CAAC,CAAC8B,GAAG,CAACV,GAAG,CAAC,EAAE;QACZQ,eAAe,CAACG,QAAQ,EAAE;MAC9B;IACJ,CAAC,CAAC,CAAC;IACH;IACA;IACA;IACA,MAAMC,YAAY,GAAG,IAAI,CAAC/C,YAAY,CAACa,GAAG,CAAC,IAAIxC,eAAe,EAAE,CAAC;IACjE,MAAM2E,iBAAiB,GAAG,MAAM;MAC5B,MAAMC,cAAc,GAAG,IAAI9E,gBAAgB,CAAC,MAAM,IAAI,CAAC8B,YAAY,CAACiB,IAAI,CAAC,IAAI,CAAC,EAAEkB,QAAQ,CAACtC,kBAAkB,CAAC;MAC5GiD,YAAY,CAAClC,GAAG,CAACoC,cAAc,CAAC;MAChCF,YAAY,CAAClC,GAAG,CAACwB,kBAAkB,CAACa,kBAAkB,CAACnC,CAAC,IAAI;QACxD,IAAIA,CAAC,CAACoC,WAAW,CAAC,IAAI,CAACX,YAAY,CAAC,EAAE;UAClCS,cAAc,CAACH,QAAQ,EAAE;QAC7B;MACJ,CAAC,CAAC,CAAC;MACHC,YAAY,CAAClC,GAAG,CAACxB,aAAa,CAACa,WAAW,CAAC,MAAM;QAC7C+C,cAAc,CAACH,QAAQ,EAAE;MAC7B,CAAC,CAAC,CAAC;IACP,CAAC;IACD,IAAI,CAAC7C,YAAY,GAAG,IAAI7B,OAAO,CAAC;MAC5B;MACAgF,kBAAkB,EAAEJ,iBAAiB;MACrCK,oBAAoB,EAAEN,YAAY,CAACO,KAAK,CAACC,IAAI,CAACR,YAAY;IAC9D,CAAC,CAAC;IACF,IAAI,CAAC7C,WAAW,GAAG,IAAI,CAACD,YAAY,CAACE,KAAK;EAC9C;EACAgB,OAAO,GAAG;IACN,IAAI,CAACnB,YAAY,CAACmB,OAAO,EAAE;IAC3B,IAAI,CAAClB,YAAY,CAACkB,OAAO,EAAE;EAC/B;EACAuB,MAAM,GAAG;IACL;IACA,IAAI,CAACH,WAAW,CAAChF,MAAM,GAAG,CAAC;IAC3B,IAAI,CAACiF,YAAY,CAACc,KAAK,EAAE;IACzB,MAAME,SAAS,GAAG/E,YAAY,CAACgF,YAAY,CAAC,IAAI,CAACtB,GAAG,CAAC;IACrD,IAAIuB,KAAK;IACTF,SAAS,CAACG,IAAI,CAAChE,IAAI,CAACiE,iBAAiB,CAAC;IACtC,KAAK,MAAMC,IAAI,IAAIL,SAAS,EAAE;MAC1B;MACA,MAAMM,SAAS,GAAGD,IAAI,CAACH,KAAK,IAAI,EAAE;MAClC,IAAI,CAACA,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAKI,SAAS,EAAE;QAClCJ,KAAK,GAAG,CAACI,SAAS,EAAE,EAAE,CAAC;QACvB,IAAI,CAACvB,WAAW,CAACR,IAAI,CAAC2B,KAAK,CAAC;MAChC;MACAA,KAAK,CAAC,CAAC,CAAC,CAAC3B,IAAI,CAAC8B,IAAI,CAAC;MACnB;MACA,IAAI,CAACE,mBAAmB,CAACF,IAAI,CAAC;IAClC;EACJ;EACAE,mBAAmB,CAACF,IAAI,EAAE;IACtBlE,IAAI,CAACqE,iBAAiB,CAACH,IAAI,CAACI,IAAI,EAAE,IAAI,CAACzB,YAAY,CAAC;IACpD,IAAIjE,WAAW,CAACsF,IAAI,CAAC,EAAE;MACnB;MACA,IAAIA,IAAI,CAACK,OAAO,CAACC,YAAY,EAAE;QAC3BxE,IAAI,CAACqE,iBAAiB,CAACH,IAAI,CAACK,OAAO,CAACC,YAAY,EAAE,IAAI,CAAC3B,YAAY,CAAC;MACxE;MACA;MACA,IAAIqB,IAAI,CAACK,OAAO,CAACE,OAAO,EAAE;QACtB,MAAMC,iBAAiB,GAAGR,IAAI,CAACK,OAAO,CAACE,OAAO,CAACE,SAAS,IAAIT,IAAI,CAACK,OAAO,CAACE,OAAO;QAChFzE,IAAI,CAACqE,iBAAiB,CAACK,iBAAiB,EAAE,IAAI,CAAC7B,YAAY,CAAC;MAChE;IACJ,CAAC,MACI,IAAI,IAAI,CAACJ,QAAQ,CAACvC,2BAA2B,EAAE;MAChD;MACA;MACApB,YAAY,CAACgF,YAAY,CAACI,IAAI,CAACU,OAAO,CAAC,CAACC,OAAO,CAAC,IAAI,CAACT,mBAAmB,EAAE,IAAI,CAAC;IACnF;EACJ;EACAU,UAAU,CAAC/E,OAAO,EAAE;IAChB,MAAMgF,MAAM,GAAG,EAAE;IACjB,MAAMC,gBAAgB,GAAG,EAAE;IAC3B,KAAK,MAAMjB,KAAK,IAAI,IAAI,CAACnB,WAAW,EAAE;MAClC,MAAM,CAAC/C,EAAE,EAAEoF,KAAK,CAAC,GAAGlB,KAAK;MACzB,MAAMmB,aAAa,GAAG,EAAE;MACxB,MAAMC,aAAa,GAAG,EAAE;MACxB,KAAK,MAAMjB,IAAI,IAAIe,KAAK,EAAE;QACtB,IAAI,IAAI,CAACvC,kBAAkB,CAAC0C,mBAAmB,CAAClB,IAAI,CAACI,IAAI,CAAC,EAAE;UACxD,IAAIe,MAAM;UACV,MAAMC,UAAU,GAAG1G,WAAW,CAACsF,IAAI,CAAC;UACpC,IAAIoB,UAAU,EAAE;YACZ,MAAMC,QAAQ,GAAGC,cAAc,CAAC,IAAI,CAAChD,GAAG,EAAE0B,IAAI,CAACK,OAAO,EAAE,IAAI,CAAC7E,aAAa,CAAC;YAC3E2F,MAAM,GAAG,IAAIxG,cAAc,CAACqF,IAAI,CAACK,OAAO,EAAEL,IAAI,CAACuB,GAAG,EAAE1F,OAAO,EAAEwF,QAAQ,EAAE,IAAI,CAAC7C,kBAAkB,EAAE,IAAI,CAAClD,eAAe,CAAC;UACzH,CAAC,MACI;YACD6F,MAAM,GAAG,IAAItG,iBAAiB,CAACmF,IAAI,EAAE,IAAI,CAACvB,YAAY,EAAE,IAAI,CAACD,kBAAkB,EAAE3C,OAAO,CAAC;YACzF,IAAIsF,MAAM,CAACK,OAAO,CAAC9H,MAAM,KAAK,CAAC,EAAE;cAC7ByH,MAAM,CAAC7D,OAAO,EAAE;cAChB6D,MAAM,GAAGM,SAAS;YACtB;UACJ;UACA,IAAIN,MAAM,EAAE;YACRF,aAAa,CAAC/C,IAAI,CAACiD,MAAM,CAAC;UAC9B;QACJ;MACJ;MACA,IAAIF,aAAa,CAACvH,MAAM,GAAG,CAAC,EAAE;QAC1BmH,MAAM,CAAC3C,IAAI,CAAC,CAACvC,EAAE,EAAEsF,aAAa,CAAC,CAAC;MACpC;MACA,IAAID,aAAa,CAACtH,MAAM,GAAG,CAAC,EAAE;QAC1BoH,gBAAgB,CAAC5C,IAAI,CAAC8C,aAAa,CAAC;MACxC;IACJ;IACA,OAAOH,MAAM;EACjB;EACA,OAAOV,iBAAiB,CAACuB,GAAG,EAAEC,GAAG,EAAE;IAC/B,IAAID,GAAG,EAAE;MACL,KAAK,MAAMpI,GAAG,IAAIoI,GAAG,CAACE,IAAI,EAAE,EAAE;QAC1BD,GAAG,CAAC3E,GAAG,CAAC1D,GAAG,CAAC;MAChB;IACJ;EACJ;EACA,OAAOyG,iBAAiB,CAAC8B,CAAC,EAAEC,CAAC,EAAE;IAC3B,MAAMC,MAAM,GAAGF,CAAC,CAAChC,KAAK;IACtB,MAAMmC,MAAM,GAAGF,CAAC,CAACjC,KAAK;IACtB,IAAIkC,MAAM,KAAKC,MAAM,EAAE;MACnB;MACA,IAAI,CAACD,MAAM,EAAE;QACT,OAAO,CAAC;MACZ,CAAC,MACI,IAAI,CAACC,MAAM,EAAE;QACd,OAAO,CAAC,CAAC;MACb;MACA;MACA,IAAID,MAAM,KAAK,YAAY,EAAE;QACzB,OAAO,CAAC,CAAC;MACb,CAAC,MACI,IAAIC,MAAM,KAAK,YAAY,EAAE;QAC9B,OAAO,CAAC;MACZ;MACA;MACA,MAAMC,KAAK,GAAGF,MAAM,CAACG,aAAa,CAACF,MAAM,CAAC;MAC1C,IAAIC,KAAK,KAAK,CAAC,EAAE;QACb,OAAOA,KAAK;MAChB;IACJ;IACA;IACA,MAAME,KAAK,GAAGN,CAAC,CAACO,KAAK,IAAI,CAAC;IAC1B,MAAMC,KAAK,GAAGP,CAAC,CAACM,KAAK,IAAI,CAAC;IAC1B,IAAID,KAAK,GAAGE,KAAK,EAAE;MACf,OAAO,CAAC,CAAC;IACb,CAAC,MACI,IAAIF,KAAK,GAAGE,KAAK,EAAE;MACpB,OAAO,CAAC;IACZ;IACA;IACA,OAAOvG,IAAI,CAACwG,cAAc,CAAC5H,WAAW,CAACmH,CAAC,CAAC,GAAGA,CAAC,CAACxB,OAAO,CAACkC,KAAK,GAAGV,CAAC,CAACU,KAAK,EAAE7H,WAAW,CAACoH,CAAC,CAAC,GAAGA,CAAC,CAACzB,OAAO,CAACkC,KAAK,GAAGT,CAAC,CAACS,KAAK,CAAC;EACtH;EACA,OAAOD,cAAc,CAACT,CAAC,EAAEC,CAAC,EAAE;IACxB,MAAMU,IAAI,GAAG,OAAOX,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAGA,CAAC,CAACY,QAAQ;IACnD,MAAMC,IAAI,GAAG,OAAOZ,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAGA,CAAC,CAACW,QAAQ;IACnD,OAAOD,IAAI,CAACN,aAAa,CAACQ,IAAI,CAAC;EACnC;AACJ,CAAC;AACD5G,IAAI,GAAG3C,UAAU,CAAC,CACdgB,OAAO,CAAC,CAAC,EAAEW,eAAe,CAAC,EAC3BX,OAAO,CAAC,CAAC,EAAEY,kBAAkB,CAAC,EAC9BZ,OAAO,CAAC,CAAC,EAAEM,YAAY,CAAC,CAC3B,EAAEqB,IAAI,CAAC;AACR,SAASwF,cAAc,CAAC9D,IAAI,EAAE6C,OAAO,EAAEsC,MAAM,EAAE;EAC3C,MAAMhH,EAAE,GAAI,GAAE6B,IAAI,CAAC7B,EAAG,IAAG0E,OAAO,CAAC1E,EAAG,EAAC;EACrC,MAAM4G,KAAK,GAAG,OAAOlC,OAAO,CAACkC,KAAK,KAAK,QAAQ,GAAGlC,OAAO,CAACkC,KAAK,GAAGlC,OAAO,CAACkC,KAAK,CAACN,KAAK;EACrF,MAAMW,IAAI,GAAG5H,QAAQ,CAAC;IAClBW,EAAE;IACFkH,KAAK,EAAE1H,QAAQ,CAAC,YAAY,EAAE,cAAc,EAAEoH,KAAK,CAAC;IACpDO,GAAG,GAAG;MAAEH,MAAM,CAAC9E,YAAY,CAACL,IAAI,EAAE6C,OAAO,CAAC1E,EAAE,EAAE,IAAI,CAAC;IAAE;EACzD,CAAC,CAAC;EACF,MAAMoH,MAAM,GAAG/H,QAAQ,CAAC;IACpBW,EAAE;IACFkH,KAAK,EAAEN,KAAK;IACZ,IAAIS,OAAO,GAAG;MAAE,OAAO,CAACL,MAAM,CAACpF,QAAQ,CAACC,IAAI,EAAE6C,OAAO,CAAC1E,EAAE,CAAC;IAAE,CAAC;IAC5DmH,GAAG,GAAG;MACF,MAAMG,QAAQ,GAAG,CAACN,MAAM,CAACpF,QAAQ,CAACC,IAAI,EAAE6C,OAAO,CAAC1E,EAAE,CAAC;MACnDgH,MAAM,CAAC9E,YAAY,CAACL,IAAI,EAAE6C,OAAO,CAAC1E,EAAE,EAAEsH,QAAQ,CAAC;IACnD;EACJ,CAAC,CAAC;EACF,OAAO;IACHL,IAAI;IACJG,MAAM;IACN,IAAIxF,QAAQ,GAAG;MAAE,OAAO,CAACwF,MAAM,CAACC,OAAO;IAAE;EAC7C,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}