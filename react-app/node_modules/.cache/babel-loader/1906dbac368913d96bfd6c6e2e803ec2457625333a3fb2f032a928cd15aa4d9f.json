{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n  function is(thing) {\n    return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n  }\n  Iterable.is = is;\n  const _empty = Object.freeze([]);\n  function empty() {\n    return _empty;\n  }\n  Iterable.empty = empty;\n  function* single(element) {\n    yield element;\n  }\n  Iterable.single = single;\n  function from(iterable) {\n    return iterable || _empty;\n  }\n  Iterable.from = from;\n  function isEmpty(iterable) {\n    return !iterable || iterable[Symbol.iterator]().next().done === true;\n  }\n  Iterable.isEmpty = isEmpty;\n  function first(iterable) {\n    return iterable[Symbol.iterator]().next().value;\n  }\n  Iterable.first = first;\n  function some(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  Iterable.some = some;\n  function find(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        return element;\n      }\n    }\n    return undefined;\n  }\n  Iterable.find = find;\n  function* filter(iterable, predicate) {\n    for (const element of iterable) {\n      if (predicate(element)) {\n        yield element;\n      }\n    }\n  }\n  Iterable.filter = filter;\n  function* map(iterable, fn) {\n    let index = 0;\n    for (const element of iterable) {\n      yield fn(element, index++);\n    }\n  }\n  Iterable.map = map;\n  function* concat() {\n    for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {\n      iterables[_key] = arguments[_key];\n    }\n    for (const iterable of iterables) {\n      for (const element of iterable) {\n        yield element;\n      }\n    }\n  }\n  Iterable.concat = concat;\n  function* concatNested(iterables) {\n    for (const iterable of iterables) {\n      for (const element of iterable) {\n        yield element;\n      }\n    }\n  }\n  Iterable.concatNested = concatNested;\n  function reduce(iterable, reducer, initialValue) {\n    let value = initialValue;\n    for (const element of iterable) {\n      value = reducer(value, element);\n    }\n    return value;\n  }\n  Iterable.reduce = reduce;\n  function forEach(iterable, fn) {\n    let index = 0;\n    for (const element of iterable) {\n      fn(element, index++);\n    }\n  }\n  Iterable.forEach = forEach;\n  /**\n   * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n   */\n  function slice(arr, from) {\n    let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    return function* () {\n      if (from < 0) {\n        from += arr.length;\n      }\n      if (to < 0) {\n        to += arr.length;\n      } else if (to > arr.length) {\n        to = arr.length;\n      }\n      for (; from < to; from++) {\n        yield arr[from];\n      }\n    }();\n  }\n  Iterable.slice = slice;\n  /**\n   * Consumes `atMost` elements from iterable and returns the consumed elements,\n   * and an iterable for the rest of the elements.\n   */\n  function consume(iterable) {\n    let atMost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n    const consumed = [];\n    if (atMost === 0) {\n      return [consumed, iterable];\n    }\n    const iterator = iterable[Symbol.iterator]();\n    for (let i = 0; i < atMost; i++) {\n      const next = iterator.next();\n      if (next.done) {\n        return [consumed, Iterable.empty()];\n      }\n      consumed.push(next.value);\n    }\n    return [consumed, {\n      [Symbol.iterator]() {\n        return iterator;\n      }\n    }];\n  }\n  Iterable.consume = consume;\n  /**\n   * Consumes `atMost` elements from iterable and returns the consumed elements,\n   * and an iterable for the rest of the elements.\n   */\n  function collect(iterable) {\n    return consume(iterable)[0];\n  }\n  Iterable.collect = collect;\n  /**\n   * Returns whether the iterables are the same length and all items are\n   * equal using the comparator function.\n   */\n  function equals(a, b) {\n    let comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (at, bt) => at === bt;\n    const ai = a[Symbol.iterator]();\n    const bi = b[Symbol.iterator]();\n    while (true) {\n      const an = ai.next();\n      const bn = bi.next();\n      if (an.done !== bn.done) {\n        return false;\n      } else if (an.done) {\n        return true;\n      } else if (!comparator(an.value, bn.value)) {\n        return false;\n      }\n    }\n  }\n  Iterable.equals = equals;\n})(Iterable || (Iterable = {}));","map":{"version":3,"names":["Iterable","is","thing","Symbol","iterator","_empty","Object","freeze","empty","single","element","from","iterable","isEmpty","next","done","first","value","some","predicate","find","undefined","filter","map","fn","index","concat","iterables","concatNested","reduce","reducer","initialValue","forEach","slice","arr","to","length","consume","atMost","Number","POSITIVE_INFINITY","consumed","i","push","collect","equals","a","b","comparator","at","bt","ai","bi","an","bn"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/base/common/iterator.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function isEmpty(iterable) {\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\n    }\n    Iterable.isEmpty = isEmpty;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function find(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    Iterable.find = find;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield fn(element, index++);\n        }\n    }\n    Iterable.map = map;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            for (const element of iterable) {\n                yield element;\n            }\n        }\n    }\n    Iterable.concat = concat;\n    function* concatNested(iterables) {\n        for (const iterable of iterables) {\n            for (const element of iterable) {\n                yield element;\n            }\n        }\n    }\n    Iterable.concatNested = concatNested;\n    function reduce(iterable, reducer, initialValue) {\n        let value = initialValue;\n        for (const element of iterable) {\n            value = reducer(value, element);\n        }\n        return value;\n    }\n    Iterable.reduce = reduce;\n    function forEach(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            fn(element, index++);\n        }\n    }\n    Iterable.forEach = forEach;\n    /**\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n     */\n    function* slice(arr, from, to = arr.length) {\n        if (from < 0) {\n            from += arr.length;\n        }\n        if (to < 0) {\n            to += arr.length;\n        }\n        else if (to > arr.length) {\n            to = arr.length;\n        }\n        for (; from < to; from++) {\n            yield arr[from];\n        }\n    }\n    Iterable.slice = slice;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function collect(iterable) {\n        return consume(iterable)[0];\n    }\n    Iterable.collect = collect;\n    /**\n     * Returns whether the iterables are the same length and all items are\n     * equal using the comparator function.\n     */\n    function equals(a, b, comparator = (at, bt) => at === bt) {\n        const ai = a[Symbol.iterator]();\n        const bi = b[Symbol.iterator]();\n        while (true) {\n            const an = ai.next();\n            const bn = bi.next();\n            if (an.done !== bn.done) {\n                return false;\n            }\n            else if (an.done) {\n                return true;\n            }\n            else if (!comparator(an.value, bn.value)) {\n                return false;\n            }\n        }\n    }\n    Iterable.equals = equals;\n})(Iterable || (Iterable = {}));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}