{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n  constructor(context) {\n    this._selTrackedRange = null;\n    this._trackSelection = true;\n    this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));\n  }\n  dispose(context) {\n    this._removeTrackedRange(context);\n  }\n  startTrackingSelection(context) {\n    this._trackSelection = true;\n    this._updateTrackedRange(context);\n  }\n  stopTrackingSelection(context) {\n    this._trackSelection = false;\n    this._removeTrackedRange(context);\n  }\n  _updateTrackedRange(context) {\n    if (!this._trackSelection) {\n      // don't track the selection\n      return;\n    }\n    this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n  }\n\n  _removeTrackedRange(context) {\n    this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n  }\n\n  asCursorState() {\n    return new CursorState(this.modelState, this.viewState);\n  }\n  readSelectionFromMarkers(context) {\n    const range = context.model._getTrackedRange(this._selTrackedRange);\n    return Selection.fromRange(range, this.modelState.selection.getDirection());\n  }\n  ensureValidState(context) {\n    this._setState(context, this.modelState, this.viewState);\n  }\n  setState(context, modelState, viewState) {\n    this._setState(context, modelState, viewState);\n  }\n  static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n    if (position.equals(cacheInput)) {\n      return cacheOutput;\n    }\n    return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n  }\n\n  static _validateViewState(viewModel, viewState) {\n    const position = viewState.position;\n    const sStartPosition = viewState.selectionStart.getStartPosition();\n    const sEndPosition = viewState.selectionStart.getEndPosition();\n    const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n    const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n    if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n      // fast path: the state is valid\n      return viewState;\n    }\n    return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n  }\n  _setState(context, modelState, viewState) {\n    if (viewState) {\n      viewState = Cursor._validateViewState(context.viewModel, viewState);\n    }\n    if (!modelState) {\n      if (!viewState) {\n        return;\n      }\n      // We only have the view state => compute the model state\n      const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n      const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n      modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n    } else {\n      // Validate new model state\n      const selectionStart = context.model.validateRange(modelState.selectionStart);\n      const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n      const position = context.model.validatePosition(modelState.position);\n      const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n      modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n    }\n    if (!viewState) {\n      // We only have the model state => compute the view state\n      const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n      const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n      const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n      const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n      viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n    } else {\n      // Validate new view state\n      const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n      const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n      viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n    }\n    this.modelState = modelState;\n    this.viewState = viewState;\n    this._updateTrackedRange(context);\n  }\n}","map":{"version":3,"names":["CursorState","SingleCursorState","Position","Range","Selection","Cursor","constructor","context","_selTrackedRange","_trackSelection","_setState","dispose","_removeTrackedRange","startTrackingSelection","_updateTrackedRange","stopTrackingSelection","model","_setTrackedRange","modelState","selection","asCursorState","viewState","readSelectionFromMarkers","range","_getTrackedRange","fromRange","getDirection","ensureValidState","setState","_validatePositionWithCache","viewModel","position","cacheInput","cacheOutput","equals","normalizePosition","_validateViewState","sStartPosition","selectionStart","getStartPosition","sEndPosition","getEndPosition","validPosition","validSStartPosition","validSEndPosition","fromPositions","selectionStartLeftoverVisibleColumns","column","leftoverVisibleColumns","validateRange","coordinatesConverter","convertViewRangeToModelRange","validatePosition","convertViewPositionToModelPosition","equalsRange","viewSelectionStart1","convertModelPositionToViewPosition","startLineNumber","startColumn","viewSelectionStart2","endLineNumber","endColumn","viewSelectionStart","lineNumber","viewPosition","validateViewRange","validateViewPosition"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}