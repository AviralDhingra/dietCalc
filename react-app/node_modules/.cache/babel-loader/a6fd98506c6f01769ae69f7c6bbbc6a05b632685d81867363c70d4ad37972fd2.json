{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n  constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    this._editorId = editorId;\n    this.model = model;\n    this._validModelVersionId = -1;\n    this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n    this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n    this.fontInfo = fontInfo;\n    this.tabSize = tabSize;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    this._constructLines( /*resetHiddenAreas*/true, null);\n  }\n  dispose() {\n    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n  }\n  createCoordinatesConverter() {\n    return new CoordinatesConverter(this);\n  }\n  _constructLines(resetHiddenAreas, previousLineBreaks) {\n    this.modelLineProjections = [];\n    if (resetHiddenAreas) {\n      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    const linesContent = this.model.getLinesContent();\n    const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n    const lineCount = linesContent.length;\n    const lineBreaksComputer = this.createLineBreaksComputer();\n    const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n    for (let i = 0; i < lineCount; i++) {\n      const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n      lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n    }\n    const linesBreaks = lineBreaksComputer.finalize();\n    const values = [];\n    const hiddenAreas = this.hiddenAreasDecorationIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n    let hiddenAreaStart = 1,\n      hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n    for (let i = 0; i < lineCount; i++) {\n      const lineNumber = i + 1;\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n      }\n      const isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n      const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n      values[i] = line.getViewLineCount();\n      this.modelLineProjections[i] = line;\n    }\n    this._validModelVersionId = this.model.getVersionId();\n    this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n  }\n  getHiddenAreas() {\n    return this.hiddenAreasDecorationIds.map(decId => this.model.getDecorationRange(decId));\n  }\n  setHiddenAreas(_ranges) {\n    const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n    const newRanges = normalizeLineRanges(validatedRanges);\n    // TODO@Martin: Please stop calling this method on each model change!\n    // This checks if there really was a change\n    const oldRanges = this.hiddenAreasDecorationIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n    if (newRanges.length === oldRanges.length) {\n      let hasDifference = false;\n      for (let i = 0; i < newRanges.length; i++) {\n        if (!newRanges[i].equalsRange(oldRanges[i])) {\n          hasDifference = true;\n          break;\n        }\n      }\n      if (!hasDifference) {\n        return false;\n      }\n    }\n    const newDecorations = newRanges.map(r => ({\n      range: r,\n      options: ModelDecorationOptions.EMPTY\n    }));\n    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n    const hiddenAreas = newRanges;\n    let hiddenAreaStart = 1,\n      hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n    let hasVisibleLine = false;\n    for (let i = 0; i < this.modelLineProjections.length; i++) {\n      const lineNumber = i + 1;\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n      }\n      let lineChanged = false;\n      if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n        // Line should be hidden\n        if (this.modelLineProjections[i].isVisible()) {\n          this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n          lineChanged = true;\n        }\n      } else {\n        hasVisibleLine = true;\n        // Line should be visible\n        if (!this.modelLineProjections[i].isVisible()) {\n          this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n          lineChanged = true;\n        }\n      }\n      if (lineChanged) {\n        const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n        this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n      }\n    }\n    if (!hasVisibleLine) {\n      // Cannot have everything be hidden => reveal everything!\n      this.setHiddenAreas([]);\n    }\n    return true;\n  }\n  modelPositionIsVisible(modelLineNumber, _modelColumn) {\n    if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n      // invalid arguments\n      return false;\n    }\n    return this.modelLineProjections[modelLineNumber - 1].isVisible();\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n      // invalid arguments\n      return 1;\n    }\n    return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n  }\n  setTabSize(newTabSize) {\n    if (this.tabSize === newTabSize) {\n      return false;\n    }\n    this.tabSize = newTabSize;\n    this._constructLines( /*resetHiddenAreas*/false, null);\n    return true;\n  }\n  setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    const equalFontInfo = this.fontInfo.equals(fontInfo);\n    const equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy;\n    const equalWrappingColumn = this.wrappingColumn === wrappingColumn;\n    const equalWrappingIndent = this.wrappingIndent === wrappingIndent;\n    if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n      return false;\n    }\n    const onlyWrappingColumnChanged = equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent;\n    this.fontInfo = fontInfo;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    let previousLineBreaks = null;\n    if (onlyWrappingColumnChanged) {\n      previousLineBreaks = [];\n      for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n        previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n      }\n    }\n    this._constructLines( /*resetHiddenAreas*/false, previousLineBreaks);\n    return true;\n  }\n  createLineBreaksComputer() {\n    const lineBreaksComputerFactory = this.wrappingStrategy === 'advanced' ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory;\n    return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n  }\n  onModelFlushed() {\n    this._constructLines( /*resetHiddenAreas*/true, null);\n  }\n  onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n    if (!versionId || versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n    const outputFromLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;\n    const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n    this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n  }\n  onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n    if (!versionId || versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n    // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n    const isInHiddenArea = fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible();\n    const outputFromLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;\n    let totalOutputLineCount = 0;\n    const insertLines = [];\n    const insertPrefixSumValues = [];\n    for (let i = 0, len = lineBreaks.length; i < len; i++) {\n      const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n      insertLines.push(line);\n      const outputLineCount = line.getViewLineCount();\n      totalOutputLineCount += outputLineCount;\n      insertPrefixSumValues[i] = outputLineCount;\n    }\n    // TODO@Alex: use arrays.arrayInsert\n    this.modelLineProjections = this.modelLineProjections.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.modelLineProjections.slice(fromLineNumber - 1));\n    this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n    return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n  }\n  onModelLineChanged(versionId, lineNumber, lineBreakData) {\n    if (versionId !== null && versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return [false, null, null, null];\n    }\n    const lineIndex = lineNumber - 1;\n    const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n    const isVisible = this.modelLineProjections[lineIndex].isVisible();\n    const line = createModelLineProjection(lineBreakData, isVisible);\n    this.modelLineProjections[lineIndex] = line;\n    const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n    let lineMappingChanged = false;\n    let changeFrom = 0;\n    let changeTo = -1;\n    let insertFrom = 0;\n    let insertTo = -1;\n    let deleteFrom = 0;\n    let deleteTo = -1;\n    if (oldOutputLineCount > newOutputLineCount) {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n      deleteFrom = changeTo + 1;\n      deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else if (oldOutputLineCount < newOutputLineCount) {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + oldOutputLineCount - 1;\n      insertFrom = changeTo + 1;\n      insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n    }\n    this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n    const viewLinesChangedEvent = changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null;\n    const viewLinesInsertedEvent = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;\n    const viewLinesDeletedEvent = deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;\n    return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n  }\n  acceptVersionId(versionId) {\n    this._validModelVersionId = versionId;\n    if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n      // At least one line must be visible => reset hidden areas\n      this.setHiddenAreas([]);\n    }\n  }\n  getViewLineCount() {\n    return this.projectedModelLineLineCounts.getTotalSum();\n  }\n  _toValidViewLineNumber(viewLineNumber) {\n    if (viewLineNumber < 1) {\n      return 1;\n    }\n    const viewLineCount = this.getViewLineCount();\n    if (viewLineNumber > viewLineCount) {\n      return viewLineCount;\n    }\n    return viewLineNumber | 0;\n  }\n  getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    minLineNumber = this._toValidViewLineNumber(minLineNumber);\n    maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n    const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n    const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n    const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n    const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n    const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n    const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n    return {\n      startLineNumber: viewStartPosition.lineNumber,\n      endLineNumber: viewEndPosition.lineNumber,\n      indent: result.indent\n    };\n  }\n  // #region ViewLineInfo\n  getViewLineInfo(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n    return new ViewLineInfo(lineIndex + 1, remainder);\n  }\n  getMinColumnOfViewLine(viewLineInfo) {\n    return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n  }\n  getMaxColumnOfViewLine(viewLineInfo) {\n    return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n  }\n  getModelStartPositionOfViewLine(viewLineInfo) {\n    const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n    const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n    return new Position(viewLineInfo.modelLineNumber, column);\n  }\n  getModelEndPositionOfViewLine(viewLineInfo) {\n    const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n    const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n    return new Position(viewLineInfo.modelLineNumber, column);\n  }\n  getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n    const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n    const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n    const result = new Array();\n    let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n    let viewLines = new Array();\n    for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n      const line = this.modelLineProjections[curModelLine - 1];\n      if (line.isVisible()) {\n        const startOffset = curModelLine === startViewLine.modelLineNumber ? startViewLine.modelLineWrappedLineIdx : 0;\n        const endOffset = curModelLine === endViewLine.modelLineNumber ? endViewLine.modelLineWrappedLineIdx + 1 : line.getViewLineCount();\n        for (let i = startOffset; i < endOffset; i++) {\n          viewLines.push(new ViewLineInfo(curModelLine, i));\n        }\n      }\n      if (!line.isVisible() && lastVisibleModelPos) {\n        const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n        const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n        result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        viewLines = [];\n        lastVisibleModelPos = null;\n      } else if (line.isVisible() && !lastVisibleModelPos) {\n        lastVisibleModelPos = new Position(curModelLine, 1);\n      }\n    }\n    if (lastVisibleModelPos) {\n      const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n      result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n    }\n    return result;\n  }\n  // #endregion\n  getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n    const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n    const resultPerViewLine = [];\n    for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n      const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n      const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n      for (const viewLineInfo of group.viewLines) {\n        const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n        // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n        // model-columns must be converted to view-model columns.\n        const result = bracketGuides.map(g => {\n          if (g.forWrappedLinesAfterColumn !== -1) {\n            const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n            if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n              return undefined;\n            }\n          }\n          if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n            const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n            if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n              return undefined;\n            }\n          }\n          if (!g.horizontalLine) {\n            return g;\n          }\n          let column = -1;\n          if (g.column !== -1) {\n            const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n            if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n              column = p.column;\n            } else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n              column = this.getMinColumnOfViewLine(viewLineInfo);\n            } else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n              return undefined;\n            }\n          }\n          const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n          const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n          if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n            return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n          } else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n            return undefined;\n          } else {\n            if (g.visibleColumn !== -1) {\n              // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n              return undefined;\n            }\n            return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n          }\n        });\n        resultPerViewLine.push(result.filter(r => !!r));\n      }\n    }\n    return resultPerViewLine;\n  }\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    // TODO: Use the same code as in `getViewLinesBracketGuides`.\n    // Future TODO: Merge with `getViewLinesBracketGuides`.\n    // However, this requires more refactoring of indent guides.\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n    const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n    let result = [];\n    const resultRepeatCount = [];\n    const resultRepeatOption = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n      if (line.isVisible()) {\n        const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n        const count = viewLineEndIndex - viewLineStartIndex + 1;\n        let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n        if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n          // wrapped lines should block indent guides\n          option = viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */;\n        }\n\n        resultRepeatCount.push(count);\n        resultRepeatOption.push(option);\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, 0);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n          reqStart = null;\n        }\n      }\n    }\n    if (reqStart !== null) {\n      result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n      reqStart = null;\n    }\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    const viewIndents = new Array(viewLineCount);\n    let currIndex = 0;\n    for (let i = 0, len = result.length; i < len; i++) {\n      let value = result[i];\n      const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n      const option = resultRepeatOption[i];\n      let blockAtIndex;\n      if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n        blockAtIndex = 0;\n      } else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n        blockAtIndex = 1;\n      } else {\n        blockAtIndex = count;\n      }\n      for (let j = 0; j < count; j++) {\n        if (j === blockAtIndex) {\n          value = 0;\n        }\n        viewIndents[currIndex++] = value;\n      }\n    }\n    return viewIndents;\n  }\n  getViewLineContent(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLineLength(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLineMinColumn(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLineMaxColumn(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLineData(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n    let viewLineNumber = viewStartLineNumber;\n    const startModelLineIndex = start.index;\n    const startRemainder = start.remainder;\n    const result = [];\n    for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n      if (!line.isVisible()) {\n        continue;\n      }\n      const fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;\n      let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n      let lastLine = false;\n      if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n        lastLine = true;\n        remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n      }\n      line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n      viewLineNumber += remainingViewLineCount;\n      if (lastLine) {\n        break;\n      }\n    }\n    return result;\n  }\n  validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n    const line = this.modelLineProjections[lineIndex];\n    const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n    if (viewColumn < minColumn) {\n      viewColumn = minColumn;\n    }\n    if (viewColumn > maxColumn) {\n      viewColumn = maxColumn;\n    }\n    const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n    const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n    if (computedModelPosition.equals(expectedModelPosition)) {\n      return new Position(viewLineNumber, viewColumn);\n    }\n    return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n  }\n  validateViewRange(viewRange, expectedModelRange) {\n    const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n    const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n    return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n  }\n  convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n    // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n    return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n  }\n  convertViewRangeToModelRange(viewRange) {\n    const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n    const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\n    let affinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n    const inputLineNumber = validPosition.lineNumber;\n    const inputColumn = validPosition.column;\n    let lineIndex = inputLineNumber - 1,\n      lineIndexChanged = false;\n    while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      lineIndex--;\n      lineIndexChanged = true;\n    }\n    if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      // Could not reach a real line\n      // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n      return new Position(1, 1);\n    }\n    const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n    let r;\n    if (lineIndexChanged) {\n      r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n    } else {\n      r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n    }\n    // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n    return r;\n  }\n  /**\n   * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n  */\n  convertModelRangeToViewRange(modelRange) {\n    let affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (modelRange.isEmpty()) {\n      const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n      return Range.fromPositions(start);\n    } else {\n      const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n      const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    let lineIndex = modelLineNumber - 1;\n    if (this.modelLineProjections[lineIndex].isVisible()) {\n      // this model line is visible\n      const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n      return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n    }\n    // this model line is not visible\n    while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      lineIndex--;\n    }\n    if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      // Could not reach a real line\n      return 1;\n    }\n    const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n    return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n  }\n  getDecorationsInRange(range, ownerId, filterOutValidation) {\n    const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n    const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n    if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n      // most likely there are no hidden lines => fast path\n      // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n      return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n    }\n    let result = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n      if (line.isVisible()) {\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n          result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n          reqStart = null;\n        }\n      }\n    }\n    if (reqStart !== null) {\n      result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n      reqStart = null;\n    }\n    result.sort((a, b) => {\n      const res = Range.compareRangesUsingStarts(a.range, b.range);\n      if (res === 0) {\n        if (a.id < b.id) {\n          return -1;\n        }\n        if (a.id > b.id) {\n          return 1;\n        }\n        return 0;\n      }\n      return res;\n    });\n    // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n    const finalResult = [];\n    let finalResultLen = 0;\n    let prevDecId = null;\n    for (const dec of result) {\n      const decId = dec.id;\n      if (prevDecId === decId) {\n        // skip\n        continue;\n      }\n      prevDecId = decId;\n      finalResult[finalResultLen++] = dec;\n    }\n    return finalResult;\n  }\n  getInjectedTextAt(position) {\n    const info = this.getViewLineInfo(position.lineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n  }\n  normalizePosition(position, affinity) {\n    const info = this.getViewLineInfo(position.lineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n  }\n  getLineIndentColumn(lineNumber) {\n    const info = this.getViewLineInfo(lineNumber);\n    if (info.modelLineWrappedLineIdx === 0) {\n      return this.model.getLineIndentColumn(info.modelLineNumber);\n    }\n    // wrapped lines have no indentation.\n    // We deliberately don't handle the case that indentation is wrapped\n    // to avoid two view lines reporting indentation for the very same model line.\n    return 0;\n  }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n  if (ranges.length === 0) {\n    return [];\n  }\n  const sortedRanges = ranges.slice();\n  sortedRanges.sort(Range.compareRangesUsingStarts);\n  const result = [];\n  let currentRangeStart = sortedRanges[0].startLineNumber;\n  let currentRangeEnd = sortedRanges[0].endLineNumber;\n  for (let i = 1, len = sortedRanges.length; i < len; i++) {\n    const range = sortedRanges[i];\n    if (range.startLineNumber > currentRangeEnd + 1) {\n      result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n      currentRangeStart = range.startLineNumber;\n      currentRangeEnd = range.endLineNumber;\n    } else if (range.endLineNumber > currentRangeEnd) {\n      currentRangeEnd = range.endLineNumber;\n    }\n  }\n  result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n  return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n  constructor(modelLineNumber, modelLineWrappedLineIdx) {\n    this.modelLineNumber = modelLineNumber;\n    this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n  }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n  constructor(modelRange, viewLines) {\n    this.modelRange = modelRange;\n    this.viewLines = viewLines;\n  }\n}\nclass CoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  }\n  // View -> Model conversion and related methods\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n  }\n  convertViewRangeToModelRange(viewRange) {\n    return this._lines.convertViewRangeToModelRange(viewRange);\n  }\n  validateViewPosition(viewPosition, expectedModelPosition) {\n    return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n  }\n  validateViewRange(viewRange, expectedModelRange) {\n    return this._lines.validateViewRange(viewRange, expectedModelRange);\n  }\n  // Model -> View conversion and related methods\n  convertModelPositionToViewPosition(modelPosition, affinity) {\n    return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n  }\n  convertModelRangeToViewRange(modelRange, affinity) {\n    return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n  }\n  modelPositionIsVisible(modelPosition) {\n    return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    return this._lines.getModelLineViewLineCount(modelLineNumber);\n  }\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n  }\n}\nexport class ViewModelLinesFromModelAsIs {\n  constructor(model) {\n    this.model = model;\n  }\n  dispose() {}\n  createCoordinatesConverter() {\n    return new IdentityCoordinatesConverter(this);\n  }\n  getHiddenAreas() {\n    return [];\n  }\n  setHiddenAreas(_ranges) {\n    return false;\n  }\n  setTabSize(_newTabSize) {\n    return false;\n  }\n  setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n    return false;\n  }\n  createLineBreaksComputer() {\n    const result = [];\n    return {\n      addRequest: (lineText, injectedText, previousLineBreakData) => {\n        result.push(null);\n      },\n      finalize: () => {\n        return result;\n      }\n    };\n  }\n  onModelFlushed() {}\n  onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n    return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n  }\n  onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n    return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n  }\n  onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n    return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n  }\n  acceptVersionId(_versionId) {}\n  getViewLineCount() {\n    return this.model.getLineCount();\n  }\n  getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n    return {\n      startLineNumber: viewLineNumber,\n      endLineNumber: viewLineNumber,\n      indent: 0\n    };\n  }\n  getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n    return new Array(endLineNumber - startLineNumber + 1).fill([]);\n  }\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    const result = new Array(viewLineCount);\n    for (let i = 0; i < viewLineCount; i++) {\n      result[i] = 0;\n    }\n    return result;\n  }\n  getViewLineContent(viewLineNumber) {\n    return this.model.getLineContent(viewLineNumber);\n  }\n  getViewLineLength(viewLineNumber) {\n    return this.model.getLineLength(viewLineNumber);\n  }\n  getViewLineMinColumn(viewLineNumber) {\n    return this.model.getLineMinColumn(viewLineNumber);\n  }\n  getViewLineMaxColumn(viewLineNumber) {\n    return this.model.getLineMaxColumn(viewLineNumber);\n  }\n  getViewLineData(viewLineNumber) {\n    const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n    const lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n  }\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    const lineCount = this.model.getLineCount();\n    viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n    viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n    const result = [];\n    for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n      const idx = lineNumber - viewStartLineNumber;\n      result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n    }\n    return result;\n  }\n  getDecorationsInRange(range, ownerId, filterOutValidation) {\n    return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n  }\n  normalizePosition(position, affinity) {\n    return this.model.normalizePosition(position, affinity);\n  }\n  getLineIndentColumn(lineNumber) {\n    return this.model.getLineIndentColumn(lineNumber);\n  }\n  getInjectedTextAt(position) {\n    // Identity lines collection does not support injected text.\n    return null;\n  }\n}\nclass IdentityCoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  }\n  _validPosition(pos) {\n    return this._lines.model.validatePosition(pos);\n  }\n  _validRange(range) {\n    return this._lines.model.validateRange(range);\n  }\n  // View -> Model conversion and related methods\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._validPosition(viewPosition);\n  }\n  convertViewRangeToModelRange(viewRange) {\n    return this._validRange(viewRange);\n  }\n  validateViewPosition(_viewPosition, expectedModelPosition) {\n    return this._validPosition(expectedModelPosition);\n  }\n  validateViewRange(_viewRange, expectedModelRange) {\n    return this._validRange(expectedModelRange);\n  }\n  // Model -> View conversion and related methods\n  convertModelPositionToViewPosition(modelPosition) {\n    return this._validPosition(modelPosition);\n  }\n  convertModelRangeToViewRange(modelRange) {\n    return this._validRange(modelRange);\n  }\n  modelPositionIsVisible(modelPosition) {\n    const lineCount = this._lines.model.getLineCount();\n    if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n      // invalid arguments\n      return false;\n    }\n    return true;\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    return 1;\n  }\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    return modelLineNumber;\n  }\n}","map":{"version":3,"names":["arrays","Position","Range","IndentGuide","IndentGuideHorizontalLine","ModelDecorationOptions","LineInjectedText","viewEvents","createModelLineProjection","ConstantTimePrefixSumComputer","ViewLineData","ViewModelLinesFromProjectedModel","constructor","editorId","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","fontInfo","tabSize","wrappingStrategy","wrappingColumn","wrappingIndent","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","dispose","hiddenAreasDecorationIds","deltaDecorations","createCoordinatesConverter","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineCount","length","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","ArrayQueue","fromDecorations","i","lineInjectedText","takeWhile","t","lineNumber","addRequest","linesBreaks","finalize","values","hiddenAreas","map","areaId","getDecorationRange","sort","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","startLineNumber","endLineNumber","isInHiddenArea","line","getViewLineCount","getVersionId","projectedModelLineLineCounts","getHiddenAreas","decId","setHiddenAreas","_ranges","validatedRanges","r","validateRange","newRanges","normalizeLineRanges","oldRanges","hasDifference","equalsRange","newDecorations","range","options","EMPTY","hasVisibleLine","lineChanged","isVisible","setVisible","newOutputLineCount","setValue","modelPositionIsVisible","modelLineNumber","_modelColumn","getModelLineViewLineCount","setTabSize","newTabSize","setWrappingSettings","equalFontInfo","equals","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","len","getProjectionData","lineBreaksComputerFactory","onModelFlushed","onModelLinesDeleted","versionId","fromLineNumber","toLineNumber","outputFromLineNumber","getPrefixSum","outputToLineNumber","splice","removeValues","ViewLinesDeletedEvent","onModelLinesInserted","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","push","outputLineCount","slice","concat","insertValues","ViewLinesInsertedEvent","onModelLineChanged","lineBreakData","lineIndex","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","ViewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","acceptVersionId","getTotalSum","_toValidViewLineNumber","viewLineNumber","viewLineCount","getActiveIndentGuide","minLineNumber","maxLineNumber","modelPosition","convertViewPositionToModelPosition","getViewLineMinColumn","modelMinPosition","modelMaxPosition","result","guides","viewStartPosition","convertModelPositionToViewPosition","viewEndPosition","getLineMaxColumn","indent","getViewLineInfo","getIndexOf","index","remainder","ViewLineInfo","getMinColumnOfViewLine","viewLineInfo","modelLineWrappedLineIdx","getMaxColumnOfViewLine","getViewLineMaxColumn","getModelStartPositionOfViewLine","minViewColumn","column","getModelColumnOfViewPosition","getModelEndPositionOfViewLine","maxViewColumn","getViewLineInfosGroupedByModelRanges","viewStartLineNumber","viewEndLineNumber","startViewLine","endViewLine","Array","lastVisibleModelPos","viewLines","curModelLine","startOffset","endOffset","lastVisibleModelPos2","modelRange","fromPositions","ViewLineInfoGroupedByModelRange","getViewLinesBracketGuides","activeViewPosition","modelActivePosition","resultPerViewLine","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","bracketGuides","g","forWrappedLinesAfterColumn","p","getViewPositionOfModelPosition","undefined","forWrappedLinesBeforeOrAtColumn","horizontalLine","viewPosition","endColumn","visibleColumn","className","top","filter","getViewLinesIndentGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","count","option","getLinesIndentGuides","viewIndents","currIndex","value","Math","min","blockAtIndex","j","getViewLineContent","info","getViewLineLength","getViewLineData","getViewLinesData","needed","start","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","validateViewPosition","viewColumn","expectedModelPosition","minColumn","maxColumn","computedModelColumn","computedModelPosition","validatePosition","validateViewRange","viewRange","expectedModelRange","validViewStart","startColumn","getStartPosition","validViewEnd","getEndPosition","inputColumn","convertViewRangeToModelRange","end","_modelLineNumber","affinity","validPosition","inputLineNumber","lineIndexChanged","deltaLineNumber","convertModelRangeToViewRange","isEmpty","modelColumn","getDecorationsInRange","ownerId","filterOutValidation","maxLineColumn","a","b","res","id","finalResult","finalResultLen","prevDecId","dec","getInjectedTextAt","position","normalizePosition","getLineIndentColumn","ranges","sortedRanges","currentRangeStart","currentRangeEnd","lines","_lines","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","lineText","injectedText","previousLineBreakData","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","getLineContent","getLineLength","getLineMinColumn","lineTokens","tokenization","getLineTokens","lineContent","inflate","max","idx","_validPosition","pos","_validRange","_viewPosition","_viewRange"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getMaxColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                // model-columns must be converted to view-model columns.\n                const result = bracketGuides.map(g => {\n                    if (g.forWrappedLinesAfterColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                        if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                        if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (!g.horizontalLine) {\n                        return g;\n                    }\n                    let column = -1;\n                    if (g.column !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                        if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                            column = p.column;\n                        }\n                        else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            column = this.getMinColumnOfViewLine(viewLineInfo);\n                        }\n                        else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                    const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                    if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                    }\n                    else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                        return undefined;\n                    }\n                    else {\n                        if (g.visibleColumn !== -1) {\n                            // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                            return undefined;\n                        }\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                    }\n                });\n                resultPerViewLine.push(result.filter((r) => !!r));\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n            lineIndexChanged = true;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            return new Position(1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        const finalResult = [];\n        let finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}