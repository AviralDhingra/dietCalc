{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { compareBy, findLast, findLastMaxBy } from '../../../../base/common/arrays.js';\nexport class BracketPairsTextModelPart extends Disposable {\n  constructor(textModel, languageConfigurationService) {\n    super();\n    this.textModel = textModel;\n    this.languageConfigurationService = languageConfigurationService;\n    this.bracketPairsTree = this._register(new MutableDisposable());\n    this.onDidChangeEmitter = new Emitter();\n    this.onDidChange = this.onDidChangeEmitter.event;\n    this.bracketsRequested = false;\n    this._register(this.languageConfigurationService.onDidChange(e => {\n      var _a;\n      if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n      }\n    }));\n  }\n  get canBuildAST() {\n    const maxSupportedDocumentLength = /* max lines */50000 * /* average column count */100;\n    return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n  }\n  //#region TextModel events\n  handleDidChangeOptions(e) {\n    this.bracketPairsTree.clear();\n    this.updateBracketPairsTree();\n  }\n  handleDidChangeLanguage(e) {\n    this.bracketPairsTree.clear();\n    this.updateBracketPairsTree();\n  }\n  handleDidChangeContent(change) {\n    var _a;\n    (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n  }\n  handleDidChangeBackgroundTokenizationState() {\n    var _a;\n    (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n  }\n  handleDidChangeTokens(e) {\n    var _a;\n    (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n  }\n  //#endregion\n  updateBracketPairsTree() {\n    if (this.bracketsRequested && this.canBuildAST) {\n      if (!this.bracketPairsTree.value) {\n        const store = new DisposableStore();\n        this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, languageId => {\n          return this.languageConfigurationService.getLanguageConfiguration(languageId);\n        })), store);\n        store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n        this.onDidChangeEmitter.fire();\n      }\n    } else {\n      if (this.bracketPairsTree.value) {\n        this.bracketPairsTree.clear();\n        // Important: Don't call fire if there was no change!\n        this.onDidChangeEmitter.fire();\n      }\n    }\n  }\n  /**\n   * Returns all bracket pairs that intersect the given range.\n   * The result is sorted by the start position.\n  */\n  getBracketPairsInRange(range) {\n    var _a;\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || [];\n  }\n  getBracketPairsInRangeWithMinIndentation(range) {\n    var _a;\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || [];\n  }\n  getBracketsInRange(range) {\n    var _a;\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range)) || [];\n  }\n  findMatchingBracketUp(_bracket, _position, maxDuration) {\n    const position = this.textModel.validatePosition(_position);\n    const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n    if (this.canBuildAST) {\n      const closingBracketInfo = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew.getClosingBracketInfo(_bracket);\n      if (!closingBracketInfo) {\n        return null;\n      }\n      const bracketPair = findLast(this.getBracketPairsInRange(Range.fromPositions(_position, _position)) || [], b => closingBracketInfo.closes(b.openingBracketInfo));\n      if (bracketPair) {\n        return bracketPair.openingBracketRange;\n      }\n      return null;\n    } else {\n      // Fallback to old bracket matching code:\n      const bracket = _bracket.toLowerCase();\n      const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n      if (!bracketsSupport) {\n        return null;\n      }\n      const data = bracketsSupport.textIsBracket[bracket];\n      if (!data) {\n        return null;\n      }\n      return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n    }\n  }\n  matchBracket(position, maxDuration) {\n    if (this.canBuildAST) {\n      const bracketPair = findLastMaxBy(this.getBracketPairsInRange(Range.fromPositions(position, position)).filter(item => item.closingBracketRange !== undefined && (item.openingBracketRange.containsPosition(position) || item.closingBracketRange.containsPosition(position))), compareBy(item => item.openingBracketRange.containsPosition(position) ? item.openingBracketRange : item.closingBracketRange, Range.compareRangesUsingStarts));\n      if (bracketPair) {\n        return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n      }\n      return null;\n    } else {\n      // Fallback to old bracket matching code:\n      const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n      return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n    }\n  }\n  _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n    const tokenCount = lineTokens.getCount();\n    const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n    // limit search to not go before `maxBracketLength`\n    let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n    for (let i = tokenIndex - 1; i >= 0; i--) {\n      const tokenEndOffset = lineTokens.getEndOffset(i);\n      if (tokenEndOffset <= searchStartOffset) {\n        break;\n      }\n      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n        searchStartOffset = tokenEndOffset;\n        break;\n      }\n    }\n    // limit search to not go after `maxBracketLength`\n    let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n    for (let i = tokenIndex + 1; i < tokenCount; i++) {\n      const tokenStartOffset = lineTokens.getStartOffset(i);\n      if (tokenStartOffset >= searchEndOffset) {\n        break;\n      }\n      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n        searchEndOffset = tokenStartOffset;\n        break;\n      }\n    }\n    return {\n      searchStartOffset,\n      searchEndOffset\n    };\n  }\n  _matchBracket(position, continueSearchPredicate) {\n    const lineNumber = position.lineNumber;\n    const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n    const lineText = this.textModel.getLineContent(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    if (tokenIndex < 0) {\n      return null;\n    }\n    const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n    // check that the token is not to be ignored\n    if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n      let {\n        searchStartOffset,\n        searchEndOffset\n      } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n      // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n      // `bestResult` will contain the most right-side result\n      let bestResult = null;\n      while (true) {\n        const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!foundBracket) {\n          // there are no more brackets in this text\n          break;\n        }\n        // check that we didn't hit a bracket too far away from position\n        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n          const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n            bestResult = r;\n          }\n        }\n        searchStartOffset = foundBracket.endColumn - 1;\n      }\n      if (bestResult) {\n        return bestResult;\n      }\n    }\n    // If position is in between two tokens, try also looking in the previous token\n    if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n      const prevTokenIndex = tokenIndex - 1;\n      const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n      // check that previous token is not to be ignored\n      if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n        const {\n          searchStartOffset,\n          searchEndOffset\n        } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n        const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        // check that we didn't hit a bracket too far away from position\n        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n          const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n            return r;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n    if (!data) {\n      return null;\n    }\n    const matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);\n    if (!matched) {\n      return null;\n    }\n    if (matched instanceof BracketSearchCanceled) {\n      return matched;\n    }\n    return [foundBracket, matched];\n  }\n  _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageId;\n    const reversedBracketRegex = bracket.reversedRegex;\n    let count = -1;\n    let totalCallCount = 0;\n    const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n        if (count === 0) {\n          return r;\n        }\n        searchEndOffset = r.startColumn - 1;\n      }\n      return null;\n    };\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return r;\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    return null;\n  }\n  _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageId;\n    const bracketRegex = bracket.forwardRegex;\n    let count = 1;\n    let totalCallCount = 0;\n    const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n        if (count === 0) {\n          return r;\n        }\n        searchStartOffset = r.endColumn - 1;\n      }\n      return null;\n    };\n    const lineCount = this.textModel.getLineCount();\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return r;\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    return null;\n  }\n  findPrevBracket(_position) {\n    var _a;\n    const position = this.textModel.validatePosition(_position);\n    if (this.canBuildAST) {\n      this.bracketsRequested = true;\n      this.updateBracketPairsTree();\n      return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n    }\n    let languageId = null;\n    let modeBrackets = null;\n    let bracketConfig = null;\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(bracketConfig, r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(bracketConfig, r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return this._toFoundBracket(bracketConfig, r);\n        }\n      }\n    }\n    return null;\n  }\n  findNextBracket(_position) {\n    var _a;\n    const position = this.textModel.validatePosition(_position);\n    if (this.canBuildAST) {\n      this.bracketsRequested = true;\n      this.updateBracketPairsTree();\n      return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n    }\n    const lineCount = this.textModel.getLineCount();\n    let languageId = null;\n    let modeBrackets = null;\n    let bracketConfig = null;\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(bracketConfig, r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(bracketConfig, r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return this._toFoundBracket(bracketConfig, r);\n        }\n      }\n    }\n    return null;\n  }\n  findEnclosingBrackets(_position, maxDuration) {\n    const position = this.textModel.validatePosition(_position);\n    if (this.canBuildAST) {\n      const range = Range.fromPositions(position);\n      const bracketPair = findLast(this.getBracketPairsInRange(Range.fromPositions(position, position)), item => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n      if (bracketPair) {\n        return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n      }\n      return null;\n    }\n    const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n    const lineCount = this.textModel.getLineCount();\n    const savedCounts = new Map();\n    let counts = [];\n    const resetCounts = (languageId, modeBrackets) => {\n      if (!savedCounts.has(languageId)) {\n        const tmp = [];\n        for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n          tmp[i] = 0;\n        }\n        savedCounts.set(languageId, tmp);\n      }\n      counts = savedCounts.get(languageId);\n    };\n    let totalCallCount = 0;\n    const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const bracket = modeBrackets.textIsBracket[hitText];\n        if (bracket) {\n          if (bracket.isOpen(hitText)) {\n            counts[bracket.index]++;\n          } else if (bracket.isClose(hitText)) {\n            counts[bracket.index]--;\n          }\n          if (counts[bracket.index] === -1) {\n            return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n          }\n        }\n        searchStartOffset = r.endColumn - 1;\n      }\n      return null;\n    };\n    let languageId = null;\n    let modeBrackets = null;\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          resetCounts(languageId, modeBrackets);\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          resetCounts(languageId, modeBrackets);\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return stripBracketSearchCanceled(r);\n        }\n      }\n    }\n    return null;\n  }\n  _toFoundBracket(bracketConfig, r) {\n    if (!r) {\n      return null;\n    }\n    let text = this.textModel.getValueInRange(r);\n    text = text.toLowerCase();\n    const bracketInfo = bracketConfig.getBracketInfo(text);\n    if (!bracketInfo) {\n      return null;\n    }\n    return {\n      range: r,\n      bracketInfo\n    };\n  }\n}\nfunction createDisposableRef(object, disposable) {\n  return {\n    object,\n    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()\n  };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n  if (typeof maxDuration === 'undefined') {\n    return () => true;\n  } else {\n    const startTime = Date.now();\n    return () => {\n      return Date.now() - startTime <= maxDuration;\n    };\n  }\n}\nclass BracketSearchCanceled {\n  constructor() {\n    this._searchCanceledBrand = undefined;\n  }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n  if (result instanceof BracketSearchCanceled) {\n    return null;\n  }\n  return result;\n}","map":{"version":3,"names":["Emitter","Disposable","DisposableStore","MutableDisposable","Range","BracketPairsTree","ignoreBracketsInToken","BracketsUtils","compareBy","findLast","findLastMaxBy","BracketPairsTextModelPart","constructor","textModel","languageConfigurationService","bracketPairsTree","_register","onDidChangeEmitter","onDidChange","event","bracketsRequested","e","_a","languageId","value","object","didLanguageChange","clear","updateBracketPairsTree","canBuildAST","maxSupportedDocumentLength","getValueLength","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","change","handleContentChanged","handleDidChangeBackgroundTokenizationState","handleDidChangeTokens","store","createDisposableRef","add","getLanguageConfiguration","fire","getBracketPairsInRange","range","getBracketPairsInRangeWithMinIndentation","getBracketsInRange","findMatchingBracketUp","_bracket","_position","maxDuration","position","validatePosition","getLanguageIdAtPosition","lineNumber","column","closingBracketInfo","bracketsNew","getClosingBracketInfo","bracketPair","fromPositions","b","closes","openingBracketInfo","openingBracketRange","bracket","toLowerCase","bracketsSupport","brackets","data","textIsBracket","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","filter","item","closingBracketRange","undefined","containsPosition","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","lineTokens","modeBrackets","tokenIndex","tokenCount","getCount","currentLanguageId","getLanguageId","searchStartOffset","Math","max","maxBracketLength","i","tokenEndOffset","getEndOffset","getStandardTokenType","searchEndOffset","min","getLineContent","length","tokenStartOffset","getStartOffset","tokenization","getLineTokens","lineText","findTokenIndexAtOffset","currentModeBrackets","bestResult","foundBracket","findNextBracketInRange","forwardRegex","startColumn","endColumn","foundBracketText","substring","r","_matchFoundBracket","textIsOpenBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","findPrevBracketInRange","reversedRegex","isOpen","matched","_findMatchingBracketDown","getEndPosition","getStartPosition","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","lineCount","getLineCount","findPrevBracket","getFirstBracketBefore","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","getFirstBracketAfter","findEnclosingBrackets","strictContainsRange","savedCounts","Map","counts","resetCounts","has","tmp","len","set","get","searchInRange","index","text","getValueInRange","bracketInfo","getBracketInfo","disposable","dispose","startTime","Date","now","_searchCanceledBrand","result"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { compareBy, findLast, findLastMaxBy } from '../../../../base/common/arrays.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || [];\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || [];\n    }\n    getBracketsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range)) || [];\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = findLast(this.getBracketPairsInRange(Range.fromPositions(_position, _position)) || [], (b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = findLastMaxBy(this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))), compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = findLast(this.getBracketPairsInRange(Range.fromPositions(position, position)), (item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}