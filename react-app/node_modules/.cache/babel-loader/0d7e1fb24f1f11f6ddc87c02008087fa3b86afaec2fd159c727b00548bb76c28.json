{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nimport { CancellationTokenSource } from './cancellation.js';\nimport { CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { toDisposable } from './lifecycle.js';\nimport { setTimeout0 } from './platform.js';\nexport function isThenable(obj) {\n  return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n  const source = new CancellationTokenSource();\n  const thenable = callback(source.token);\n  const promise = new Promise((resolve, reject) => {\n    const subscription = source.token.onCancellationRequested(() => {\n      subscription.dispose();\n      source.dispose();\n      reject(new CancellationError());\n    });\n    Promise.resolve(thenable).then(value => {\n      subscription.dispose();\n      source.dispose();\n      resolve(value);\n    }, err => {\n      subscription.dispose();\n      source.dispose();\n      reject(err);\n    });\n  });\n  return new class {\n    cancel() {\n      source.cancel();\n    }\n    then(resolve, reject) {\n      return promise.then(resolve, reject);\n    }\n    catch(reject) {\n      return this.then(undefined, reject);\n    }\n    finally(onfinally) {\n      return promise.finally(onfinally);\n    }\n  }();\n}\nexport function raceCancellation(promise, token, defaultValue) {\n  return new Promise((resolve, reject) => {\n    const ref = token.onCancellationRequested(() => {\n      ref.dispose();\n      resolve(defaultValue);\n    });\n    promise.then(resolve, reject).finally(() => ref.dispose());\n  });\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n  constructor() {\n    this.activePromise = null;\n    this.queuedPromise = null;\n    this.queuedPromiseFactory = null;\n  }\n  queue(promiseFactory) {\n    if (this.activePromise) {\n      this.queuedPromiseFactory = promiseFactory;\n      if (!this.queuedPromise) {\n        const onComplete = () => {\n          this.queuedPromise = null;\n          const result = this.queue(this.queuedPromiseFactory);\n          this.queuedPromiseFactory = null;\n          return result;\n        };\n        this.queuedPromise = new Promise(resolve => {\n          this.activePromise.then(onComplete, onComplete).then(resolve);\n        });\n      }\n      return new Promise((resolve, reject) => {\n        this.queuedPromise.then(resolve, reject);\n      });\n    }\n    this.activePromise = promiseFactory();\n    return new Promise((resolve, reject) => {\n      this.activePromise.then(result => {\n        this.activePromise = null;\n        resolve(result);\n      }, err => {\n        this.activePromise = null;\n        reject(err);\n      });\n    });\n  }\n}\nconst timeoutDeferred = (timeout, fn) => {\n  let scheduled = true;\n  const handle = setTimeout(() => {\n    scheduled = false;\n    fn();\n  }, timeout);\n  return {\n    isTriggered: () => scheduled,\n    dispose: () => {\n      clearTimeout(handle);\n      scheduled = false;\n    }\n  };\n};\nconst microtaskDeferred = fn => {\n  let scheduled = true;\n  queueMicrotask(() => {\n    if (scheduled) {\n      scheduled = false;\n      fn();\n    }\n  });\n  return {\n    isTriggered: () => scheduled,\n    dispose: () => {\n      scheduled = false;\n    }\n  };\n};\n/** Can be passed into the Delayed to defer using a microtask */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer {\n  constructor(defaultDelay) {\n    this.defaultDelay = defaultDelay;\n    this.deferred = null;\n    this.completionPromise = null;\n    this.doResolve = null;\n    this.doReject = null;\n    this.task = null;\n  }\n  trigger(task) {\n    let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultDelay;\n    this.task = task;\n    this.cancelTimeout();\n    if (!this.completionPromise) {\n      this.completionPromise = new Promise((resolve, reject) => {\n        this.doResolve = resolve;\n        this.doReject = reject;\n      }).then(() => {\n        this.completionPromise = null;\n        this.doResolve = null;\n        if (this.task) {\n          const task = this.task;\n          this.task = null;\n          return task();\n        }\n        return undefined;\n      });\n    }\n    const fn = () => {\n      var _a;\n      this.deferred = null;\n      (_a = this.doResolve) === null || _a === void 0 ? void 0 : _a.call(this, null);\n    };\n    this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n    return this.completionPromise;\n  }\n  isTriggered() {\n    var _a;\n    return !!((_a = this.deferred) === null || _a === void 0 ? void 0 : _a.isTriggered());\n  }\n  cancel() {\n    var _a;\n    this.cancelTimeout();\n    if (this.completionPromise) {\n      (_a = this.doReject) === null || _a === void 0 ? void 0 : _a.call(this, new CancellationError());\n      this.completionPromise = null;\n    }\n  }\n  cancelTimeout() {\n    var _a;\n    (_a = this.deferred) === null || _a === void 0 ? void 0 : _a.dispose();\n    this.deferred = null;\n  }\n  dispose() {\n    this.cancel();\n  }\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer {\n  constructor(defaultDelay) {\n    this.delayer = new Delayer(defaultDelay);\n    this.throttler = new Throttler();\n  }\n  trigger(promiseFactory, delay) {\n    return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n  }\n  dispose() {\n    this.delayer.dispose();\n  }\n}\nexport function timeout(millis, token) {\n  if (!token) {\n    return createCancelablePromise(token => timeout(millis, token));\n  }\n  return new Promise((resolve, reject) => {\n    const handle = setTimeout(() => {\n      disposable.dispose();\n      resolve();\n    }, millis);\n    const disposable = token.onCancellationRequested(() => {\n      clearTimeout(handle);\n      disposable.dispose();\n      reject(new CancellationError());\n    });\n  });\n}\nexport function disposableTimeout(handler) {\n  let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const timer = setTimeout(handler, timeout);\n  return toDisposable(() => clearTimeout(timer));\n}\nexport function first(promiseFactories) {\n  let shouldStop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t => !!t;\n  let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let index = 0;\n  const len = promiseFactories.length;\n  const loop = () => {\n    if (index >= len) {\n      return Promise.resolve(defaultValue);\n    }\n    const factory = promiseFactories[index++];\n    const promise = Promise.resolve(factory());\n    return promise.then(result => {\n      if (shouldStop(result)) {\n        return Promise.resolve(result);\n      }\n      return loop();\n    });\n  };\n  return loop();\n}\nexport class TimeoutTimer {\n  constructor(runner, timeout) {\n    this._token = -1;\n    if (typeof runner === 'function' && typeof timeout === 'number') {\n      this.setIfNotSet(runner, timeout);\n    }\n  }\n  dispose() {\n    this.cancel();\n  }\n  cancel() {\n    if (this._token !== -1) {\n      clearTimeout(this._token);\n      this._token = -1;\n    }\n  }\n  cancelAndSet(runner, timeout) {\n    this.cancel();\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n  setIfNotSet(runner, timeout) {\n    if (this._token !== -1) {\n      // timer is already set\n      return;\n    }\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n}\nexport class IntervalTimer {\n  constructor() {\n    this._token = -1;\n  }\n  dispose() {\n    this.cancel();\n  }\n  cancel() {\n    if (this._token !== -1) {\n      clearInterval(this._token);\n      this._token = -1;\n    }\n  }\n  cancelAndSet(runner, interval) {\n    this.cancel();\n    this._token = setInterval(() => {\n      runner();\n    }, interval);\n  }\n}\nexport class RunOnceScheduler {\n  constructor(runner, delay) {\n    this.timeoutToken = -1;\n    this.runner = runner;\n    this.timeout = delay;\n    this.timeoutHandler = this.onTimeout.bind(this);\n  }\n  /**\n   * Dispose RunOnceScheduler\n   */\n  dispose() {\n    this.cancel();\n    this.runner = null;\n  }\n  /**\n   * Cancel current scheduled runner (if any).\n   */\n  cancel() {\n    if (this.isScheduled()) {\n      clearTimeout(this.timeoutToken);\n      this.timeoutToken = -1;\n    }\n  }\n  /**\n   * Cancel previous runner (if any) & schedule a new runner.\n   */\n  schedule() {\n    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.cancel();\n    this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n  }\n  get delay() {\n    return this.timeout;\n  }\n  set delay(value) {\n    this.timeout = value;\n  }\n  /**\n   * Returns true if scheduled.\n   */\n  isScheduled() {\n    return this.timeoutToken !== -1;\n  }\n  onTimeout() {\n    this.timeoutToken = -1;\n    if (this.runner) {\n      this.doRun();\n    }\n  }\n  doRun() {\n    var _a;\n    (_a = this.runner) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle;\n(function () {\n  if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n    runWhenIdle = runner => {\n      setTimeout0(() => {\n        if (disposed) {\n          return;\n        }\n        const end = Date.now() + 15; // one frame at 64fps\n        runner(Object.freeze({\n          didTimeout: true,\n          timeRemaining() {\n            return Math.max(0, end - Date.now());\n          }\n        }));\n      });\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n        }\n      };\n    };\n  } else {\n    runWhenIdle = (runner, timeout) => {\n      const handle = requestIdleCallback(runner, typeof timeout === 'number' ? {\n        timeout\n      } : undefined);\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n          cancelIdleCallback(handle);\n        }\n      };\n    };\n  }\n})();\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue {\n  constructor(executor) {\n    this._didRun = false;\n    this._executor = () => {\n      try {\n        this._value = executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    };\n    this._handle = runWhenIdle(() => this._executor());\n  }\n  dispose() {\n    this._handle.dispose();\n  }\n  get value() {\n    if (!this._didRun) {\n      this._handle.dispose();\n      this._executor();\n    }\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n  get isInitialized() {\n    return this._didRun;\n  }\n}\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise {\n  constructor() {\n    this.rejected = false;\n    this.resolved = false;\n    this.p = new Promise((c, e) => {\n      this.completeCallback = c;\n      this.errorCallback = e;\n    });\n  }\n  get isRejected() {\n    return this.rejected;\n  }\n  get isSettled() {\n    return this.rejected || this.resolved;\n  }\n  complete(value) {\n    return new Promise(resolve => {\n      this.completeCallback(value);\n      this.resolved = true;\n      resolve();\n    });\n  }\n  cancel() {\n    new Promise(resolve => {\n      this.errorCallback(new CancellationError());\n      this.rejected = true;\n      resolve();\n    });\n  }\n}\n//#endregion\n//#region Promises\nexport var Promises;\n(function (Promises) {\n  /**\n   * A drop-in replacement for `Promise.all` with the only difference\n   * that the method awaits every promise to either fulfill or reject.\n   *\n   * Similar to `Promise.all`, only the first error will be returned\n   * if any.\n   */\n  function settled(promises) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let firstError = undefined;\n      const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {\n        if (!firstError) {\n          firstError = error;\n        }\n        return undefined; // do not rethrow so that other promises can settle\n      })));\n\n      if (typeof firstError !== 'undefined') {\n        throw firstError;\n      }\n      return result; // cast is needed and protected by the `throw` above\n    });\n  }\n\n  Promises.settled = settled;\n  /**\n   * A helper to create a new `Promise<T>` with a body that is a promise\n   * itself. By default, an error that raises from the async body will\n   * end up as a unhandled rejection, so this utility properly awaits the\n   * body and rejects the promise as a normal promise does without async\n   * body.\n   *\n   * This method should only be used in rare cases where otherwise `async`\n   * cannot be used (e.g. when callbacks are involved that require this).\n   */\n  function withAsyncBody(bodyFn) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield bodyFn(resolve, reject);\n      } catch (error) {\n        reject(error);\n      }\n    }));\n  }\n  Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject {\n  constructor(executor) {\n    this._state = 0 /* AsyncIterableSourceState.Initial */;\n    this._results = [];\n    this._error = null;\n    this._onStateChanged = new Emitter();\n    queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {\n      const writer = {\n        emitOne: item => this.emitOne(item),\n        emitMany: items => this.emitMany(items),\n        reject: error => this.reject(error)\n      };\n      try {\n        yield Promise.resolve(executor(writer));\n        this.resolve();\n      } catch (err) {\n        this.reject(err);\n      } finally {\n        writer.emitOne = undefined;\n        writer.emitMany = undefined;\n        writer.reject = undefined;\n      }\n    }));\n  }\n  static fromArray(items) {\n    return new AsyncIterableObject(writer => {\n      writer.emitMany(items);\n    });\n  }\n  static fromPromise(promise) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      emitter.emitMany(yield promise);\n    }));\n  }\n  static fromPromises(promises) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      yield Promise.all(promises.map(p => __awaiter(this, void 0, void 0, function* () {\n        return emitter.emitOne(yield p);\n      })));\n    }));\n  }\n  static merge(iterables) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      yield Promise.all(iterables.map(iterable => {\n        var iterable_1, iterable_1_1;\n        return __awaiter(this, void 0, void 0, function* () {\n          var e_1, _a;\n          try {\n            for (iterable_1 = __asyncValues(iterable); iterable_1_1 = yield iterable_1.next(), !iterable_1_1.done;) {\n              const item = iterable_1_1.value;\n              emitter.emitOne(item);\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield _a.call(iterable_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        });\n      }));\n    }));\n  }\n  [Symbol.asyncIterator]() {\n    let i = 0;\n    return {\n      next: () => __awaiter(this, void 0, void 0, function* () {\n        do {\n          if (this._state === 2 /* AsyncIterableSourceState.DoneError */) {\n            throw this._error;\n          }\n          if (i < this._results.length) {\n            return {\n              done: false,\n              value: this._results[i++]\n            };\n          }\n          if (this._state === 1 /* AsyncIterableSourceState.DoneOK */) {\n            return {\n              done: true,\n              value: undefined\n            };\n          }\n          yield Event.toPromise(this._onStateChanged.event);\n        } while (true);\n      })\n    };\n  }\n  static map(iterable, mapFn) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      var e_2, _a;\n      try {\n        for (var iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield iterable_2.next(), !iterable_2_1.done;) {\n          const item = iterable_2_1.value;\n          emitter.emitOne(mapFn(item));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (iterable_2_1 && !iterable_2_1.done && (_a = iterable_2.return)) yield _a.call(iterable_2);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }));\n  }\n  map(mapFn) {\n    return AsyncIterableObject.map(this, mapFn);\n  }\n  static filter(iterable, filterFn) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      var e_3, _a;\n      try {\n        for (var iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield iterable_3.next(), !iterable_3_1.done;) {\n          const item = iterable_3_1.value;\n          if (filterFn(item)) {\n            emitter.emitOne(item);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (iterable_3_1 && !iterable_3_1.done && (_a = iterable_3.return)) yield _a.call(iterable_3);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }));\n  }\n  filter(filterFn) {\n    return AsyncIterableObject.filter(this, filterFn);\n  }\n  static coalesce(iterable) {\n    return AsyncIterableObject.filter(iterable, item => !!item);\n  }\n  coalesce() {\n    return AsyncIterableObject.coalesce(this);\n  }\n  static toPromise(iterable) {\n    var iterable_4, iterable_4_1;\n    var e_4, _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = [];\n      try {\n        for (iterable_4 = __asyncValues(iterable); iterable_4_1 = yield iterable_4.next(), !iterable_4_1.done;) {\n          const item = iterable_4_1.value;\n          result.push(item);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (iterable_4_1 && !iterable_4_1.done && (_a = iterable_4.return)) yield _a.call(iterable_4);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n      return result;\n    });\n  }\n  toPromise() {\n    return AsyncIterableObject.toPromise(this);\n  }\n  /**\n   * The value will be appended at the end.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  emitOne(value) {\n    if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n      return;\n    }\n    // it is important to add new values at the end,\n    // as we may have iterators already running on the array\n    this._results.push(value);\n    this._onStateChanged.fire();\n  }\n  /**\n   * The values will be appended at the end.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  emitMany(values) {\n    if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n      return;\n    }\n    // it is important to add new values at the end,\n    // as we may have iterators already running on the array\n    this._results = this._results.concat(values);\n    this._onStateChanged.fire();\n  }\n  /**\n   * Calling `resolve()` will mark the result array as complete.\n   *\n   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  resolve() {\n    if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n      return;\n    }\n    this._state = 1 /* AsyncIterableSourceState.DoneOK */;\n    this._onStateChanged.fire();\n  }\n  /**\n   * Writing an error will permanently invalidate this iterable.\n   * The current users will receive an error thrown, as will all future users.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  reject(error) {\n    if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n      return;\n    }\n    this._state = 2 /* AsyncIterableSourceState.DoneError */;\n    this._error = error;\n    this._onStateChanged.fire();\n  }\n}\nAsyncIterableObject.EMPTY = AsyncIterableObject.fromArray([]);\nexport class CancelableAsyncIterableObject extends AsyncIterableObject {\n  constructor(_source, executor) {\n    super(executor);\n    this._source = _source;\n  }\n  cancel() {\n    this._source.cancel();\n  }\n}\nexport function createCancelableAsyncIterable(callback) {\n  const source = new CancellationTokenSource();\n  const innerIterable = callback(source.token);\n  return new CancelableAsyncIterableObject(source, emitter => __awaiter(this, void 0, void 0, function* () {\n    var e_5, _a;\n    const subscription = source.token.onCancellationRequested(() => {\n      subscription.dispose();\n      source.dispose();\n      emitter.reject(new CancellationError());\n    });\n    try {\n      try {\n        for (var innerIterable_1 = __asyncValues(innerIterable), innerIterable_1_1; innerIterable_1_1 = yield innerIterable_1.next(), !innerIterable_1_1.done;) {\n          const item = innerIterable_1_1.value;\n          if (source.token.isCancellationRequested) {\n            // canceled in the meantime\n            return;\n          }\n          emitter.emitOne(item);\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (innerIterable_1_1 && !innerIterable_1_1.done && (_a = innerIterable_1.return)) yield _a.call(innerIterable_1);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n      subscription.dispose();\n      source.dispose();\n    } catch (err) {\n      subscription.dispose();\n      source.dispose();\n      emitter.reject(err);\n    }\n  }));\n}\n//#endregion","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","settle","d","CancellationTokenSource","CancellationError","Emitter","Event","toDisposable","setTimeout0","isThenable","obj","createCancelablePromise","callback","source","thenable","token","promise","subscription","onCancellationRequested","dispose","err","cancel","catch","undefined","finally","onfinally","raceCancellation","defaultValue","ref","Throttler","constructor","activePromise","queuedPromise","queuedPromiseFactory","queue","promiseFactory","onComplete","timeoutDeferred","timeout","fn","scheduled","handle","setTimeout","isTriggered","clearTimeout","microtaskDeferred","queueMicrotask","MicrotaskDelay","Delayer","defaultDelay","deferred","completionPromise","doResolve","doReject","task","trigger","delay","cancelTimeout","_a","ThrottledDelayer","delayer","throttler","millis","disposable","disposableTimeout","handler","timer","first","promiseFactories","shouldStop","t","index","len","length","loop","factory","TimeoutTimer","runner","_token","setIfNotSet","cancelAndSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","bind","isScheduled","schedule","doRun","runWhenIdle","requestIdleCallback","cancelIdleCallback","disposed","end","Date","now","Object","freeze","didTimeout","timeRemaining","Math","max","IdleValue","executor","_didRun","_executor","_value","_error","_handle","isInitialized","DeferredPromise","resolved","p","c","completeCallback","errorCallback","isRejected","isSettled","complete","Promises","settled","promises","firstError","all","map","error","withAsyncBody","bodyFn","AsyncIterableObject","_state","_results","_onStateChanged","writer","emitOne","item","emitMany","items","fromArray","fromPromise","emitter","fromPromises","merge","iterables","iterable","iterable_1","iterable_1_1","e_1","e_1_1","return","toPromise","event","mapFn","e_2","iterable_2","iterable_2_1","e_2_1","filter","filterFn","e_3","iterable_3","iterable_3_1","e_3_1","coalesce","iterable_4","iterable_4_1","e_4","push","e_4_1","fire","values","concat","EMPTY","CancelableAsyncIterableObject","_source","createCancelableAsyncIterable","innerIterable","e_5","innerIterable_1","innerIterable_1_1","isCancellationRequested","e_5_1"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/base/common/async.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { CancellationTokenSource } from './cancellation.js';\nimport { CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { toDisposable } from './lifecycle.js';\nimport { setTimeout0 } from './platform.js';\nexport function isThenable(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n    const source = new CancellationTokenSource();\n    const thenable = callback(source.token);\n    const promise = new Promise((resolve, reject) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            source.dispose();\n            reject(new CancellationError());\n        });\n        Promise.resolve(thenable).then(value => {\n            subscription.dispose();\n            source.dispose();\n            resolve(value);\n        }, err => {\n            subscription.dispose();\n            source.dispose();\n            reject(err);\n        });\n    });\n    return new class {\n        cancel() {\n            source.cancel();\n        }\n        then(resolve, reject) {\n            return promise.then(resolve, reject);\n        }\n        catch(reject) {\n            return this.then(undefined, reject);\n        }\n        finally(onfinally) {\n            return promise.finally(onfinally);\n        }\n    };\n}\nexport function raceCancellation(promise, token, defaultValue) {\n    return new Promise((resolve, reject) => {\n        const ref = token.onCancellationRequested(() => {\n            ref.dispose();\n            resolve(defaultValue);\n        });\n        promise.then(resolve, reject).finally(() => ref.dispose());\n    });\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n    constructor() {\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    queue(promiseFactory) {\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                const onComplete = () => {\n                    this.queuedPromise = null;\n                    const result = this.queue(this.queuedPromiseFactory);\n                    this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new Promise(resolve => {\n                    this.activePromise.then(onComplete, onComplete).then(resolve);\n                });\n            }\n            return new Promise((resolve, reject) => {\n                this.queuedPromise.then(resolve, reject);\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new Promise((resolve, reject) => {\n            this.activePromise.then((result) => {\n                this.activePromise = null;\n                resolve(result);\n            }, (err) => {\n                this.activePromise = null;\n                reject(err);\n            });\n        });\n    }\n}\nconst timeoutDeferred = (timeout, fn) => {\n    let scheduled = true;\n    const handle = setTimeout(() => {\n        scheduled = false;\n        fn();\n    }, timeout);\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => {\n            clearTimeout(handle);\n            scheduled = false;\n        },\n    };\n};\nconst microtaskDeferred = (fn) => {\n    let scheduled = true;\n    queueMicrotask(() => {\n        if (scheduled) {\n            scheduled = false;\n            fn();\n        }\n    });\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => { scheduled = false; },\n    };\n};\n/** Can be passed into the Delayed to defer using a microtask */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.deferred = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.doReject = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((resolve, reject) => {\n                this.doResolve = resolve;\n                this.doReject = reject;\n            }).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                if (this.task) {\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                }\n                return undefined;\n            });\n        }\n        const fn = () => {\n            var _a;\n            this.deferred = null;\n            (_a = this.doResolve) === null || _a === void 0 ? void 0 : _a.call(this, null);\n        };\n        this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        var _a;\n        return !!((_a = this.deferred) === null || _a === void 0 ? void 0 : _a.isTriggered());\n    }\n    cancel() {\n        var _a;\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            (_a = this.doReject) === null || _a === void 0 ? void 0 : _a.call(this, new CancellationError());\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        var _a;\n        (_a = this.deferred) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.deferred = null;\n    }\n    dispose() {\n        this.cancel();\n    }\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer {\n    constructor(defaultDelay) {\n        this.delayer = new Delayer(defaultDelay);\n        this.throttler = new Throttler();\n    }\n    trigger(promiseFactory, delay) {\n        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n    }\n    dispose() {\n        this.delayer.dispose();\n    }\n}\nexport function timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(token => timeout(millis, token));\n    }\n    return new Promise((resolve, reject) => {\n        const handle = setTimeout(() => {\n            disposable.dispose();\n            resolve();\n        }, millis);\n        const disposable = token.onCancellationRequested(() => {\n            clearTimeout(handle);\n            disposable.dispose();\n            reject(new CancellationError());\n        });\n    });\n}\nexport function disposableTimeout(handler, timeout = 0) {\n    const timer = setTimeout(handler, timeout);\n    return toDisposable(() => clearTimeout(timer));\n}\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n    let index = 0;\n    const len = promiseFactories.length;\n    const loop = () => {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        const factory = promiseFactories[index++];\n        const promise = Promise.resolve(factory());\n        return promise.then(result => {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\nexport class TimeoutTimer {\n    constructor(runner, timeout) {\n        this._token = -1;\n        if (typeof runner === 'function' && typeof timeout === 'number') {\n            this.setIfNotSet(runner, timeout);\n        }\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, timeout) {\n        this.cancel();\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n    setIfNotSet(runner, timeout) {\n        if (this._token !== -1) {\n            // timer is already set\n            return;\n        }\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n}\nexport class IntervalTimer {\n    constructor() {\n        this._token = -1;\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearInterval(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, interval) {\n        this.cancel();\n        this._token = setInterval(() => {\n            runner();\n        }, interval);\n    }\n}\nexport class RunOnceScheduler {\n    constructor(runner, delay) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = delay;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    /**\n     * Dispose RunOnceScheduler\n     */\n    dispose() {\n        this.cancel();\n        this.runner = null;\n    }\n    /**\n     * Cancel current scheduled runner (if any).\n     */\n    cancel() {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    }\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    schedule(delay = this.timeout) {\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    }\n    get delay() {\n        return this.timeout;\n    }\n    set delay(value) {\n        this.timeout = value;\n    }\n    /**\n     * Returns true if scheduled.\n     */\n    isScheduled() {\n        return this.timeoutToken !== -1;\n    }\n    onTimeout() {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.doRun();\n        }\n    }\n    doRun() {\n        var _a;\n        (_a = this.runner) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle;\n(function () {\n    if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n        runWhenIdle = (runner) => {\n            setTimeout0(() => {\n                if (disposed) {\n                    return;\n                }\n                const end = Date.now() + 15; // one frame at 64fps\n                runner(Object.freeze({\n                    didTimeout: true,\n                    timeRemaining() {\n                        return Math.max(0, end - Date.now());\n                    }\n                }));\n            });\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                }\n            };\n        };\n    }\n    else {\n        runWhenIdle = (runner, timeout) => {\n            const handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    cancelIdleCallback(handle);\n                }\n            };\n        };\n    }\n})();\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue {\n    constructor(executor) {\n        this._didRun = false;\n        this._executor = () => {\n            try {\n                this._value = executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        };\n        this._handle = runWhenIdle(() => this._executor());\n    }\n    dispose() {\n        this._handle.dispose();\n    }\n    get value() {\n        if (!this._didRun) {\n            this._handle.dispose();\n            this._executor();\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    get isInitialized() {\n        return this._didRun;\n    }\n}\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise {\n    constructor() {\n        this.rejected = false;\n        this.resolved = false;\n        this.p = new Promise((c, e) => {\n            this.completeCallback = c;\n            this.errorCallback = e;\n        });\n    }\n    get isRejected() {\n        return this.rejected;\n    }\n    get isSettled() {\n        return this.rejected || this.resolved;\n    }\n    complete(value) {\n        return new Promise(resolve => {\n            this.completeCallback(value);\n            this.resolved = true;\n            resolve();\n        });\n    }\n    cancel() {\n        new Promise(resolve => {\n            this.errorCallback(new CancellationError());\n            this.rejected = true;\n            resolve();\n        });\n    }\n}\n//#endregion\n//#region Promises\nexport var Promises;\n(function (Promises) {\n    /**\n     * A drop-in replacement for `Promise.all` with the only difference\n     * that the method awaits every promise to either fulfill or reject.\n     *\n     * Similar to `Promise.all`, only the first error will be returned\n     * if any.\n     */\n    function settled(promises) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let firstError = undefined;\n            const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {\n                if (!firstError) {\n                    firstError = error;\n                }\n                return undefined; // do not rethrow so that other promises can settle\n            })));\n            if (typeof firstError !== 'undefined') {\n                throw firstError;\n            }\n            return result; // cast is needed and protected by the `throw` above\n        });\n    }\n    Promises.settled = settled;\n    /**\n     * A helper to create a new `Promise<T>` with a body that is a promise\n     * itself. By default, an error that raises from the async body will\n     * end up as a unhandled rejection, so this utility properly awaits the\n     * body and rejects the promise as a normal promise does without async\n     * body.\n     *\n     * This method should only be used in rare cases where otherwise `async`\n     * cannot be used (e.g. when callbacks are involved that require this).\n     */\n    function withAsyncBody(bodyFn) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield bodyFn(resolve, reject);\n            }\n            catch (error) {\n                reject(error);\n            }\n        }));\n    }\n    Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject {\n    constructor(executor) {\n        this._state = 0 /* AsyncIterableSourceState.Initial */;\n        this._results = [];\n        this._error = null;\n        this._onStateChanged = new Emitter();\n        queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {\n            const writer = {\n                emitOne: (item) => this.emitOne(item),\n                emitMany: (items) => this.emitMany(items),\n                reject: (error) => this.reject(error)\n            };\n            try {\n                yield Promise.resolve(executor(writer));\n                this.resolve();\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            finally {\n                writer.emitOne = undefined;\n                writer.emitMany = undefined;\n                writer.reject = undefined;\n            }\n        }));\n    }\n    static fromArray(items) {\n        return new AsyncIterableObject((writer) => {\n            writer.emitMany(items);\n        });\n    }\n    static fromPromise(promise) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            emitter.emitMany(yield promise);\n        }));\n    }\n    static fromPromises(promises) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            yield Promise.all(promises.map((p) => __awaiter(this, void 0, void 0, function* () { return emitter.emitOne(yield p); })));\n        }));\n    }\n    static merge(iterables) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            yield Promise.all(iterables.map((iterable) => { var iterable_1, iterable_1_1; return __awaiter(this, void 0, void 0, function* () {\n                var e_1, _a;\n                try {\n                    for (iterable_1 = __asyncValues(iterable); iterable_1_1 = yield iterable_1.next(), !iterable_1_1.done;) {\n                        const item = iterable_1_1.value;\n                        emitter.emitOne(item);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield _a.call(iterable_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }); }));\n        }));\n    }\n    [Symbol.asyncIterator]() {\n        let i = 0;\n        return {\n            next: () => __awaiter(this, void 0, void 0, function* () {\n                do {\n                    if (this._state === 2 /* AsyncIterableSourceState.DoneError */) {\n                        throw this._error;\n                    }\n                    if (i < this._results.length) {\n                        return { done: false, value: this._results[i++] };\n                    }\n                    if (this._state === 1 /* AsyncIterableSourceState.DoneOK */) {\n                        return { done: true, value: undefined };\n                    }\n                    yield Event.toPromise(this._onStateChanged.event);\n                } while (true);\n            })\n        };\n    }\n    static map(iterable, mapFn) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            var e_2, _a;\n            try {\n                for (var iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield iterable_2.next(), !iterable_2_1.done;) {\n                    const item = iterable_2_1.value;\n                    emitter.emitOne(mapFn(item));\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (iterable_2_1 && !iterable_2_1.done && (_a = iterable_2.return)) yield _a.call(iterable_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }));\n    }\n    map(mapFn) {\n        return AsyncIterableObject.map(this, mapFn);\n    }\n    static filter(iterable, filterFn) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            var e_3, _a;\n            try {\n                for (var iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield iterable_3.next(), !iterable_3_1.done;) {\n                    const item = iterable_3_1.value;\n                    if (filterFn(item)) {\n                        emitter.emitOne(item);\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (iterable_3_1 && !iterable_3_1.done && (_a = iterable_3.return)) yield _a.call(iterable_3);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }));\n    }\n    filter(filterFn) {\n        return AsyncIterableObject.filter(this, filterFn);\n    }\n    static coalesce(iterable) {\n        return AsyncIterableObject.filter(iterable, item => !!item);\n    }\n    coalesce() {\n        return AsyncIterableObject.coalesce(this);\n    }\n    static toPromise(iterable) {\n        var iterable_4, iterable_4_1;\n        var e_4, _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = [];\n            try {\n                for (iterable_4 = __asyncValues(iterable); iterable_4_1 = yield iterable_4.next(), !iterable_4_1.done;) {\n                    const item = iterable_4_1.value;\n                    result.push(item);\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (iterable_4_1 && !iterable_4_1.done && (_a = iterable_4.return)) yield _a.call(iterable_4);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n            return result;\n        });\n    }\n    toPromise() {\n        return AsyncIterableObject.toPromise(this);\n    }\n    /**\n     * The value will be appended at the end.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    emitOne(value) {\n        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n            return;\n        }\n        // it is important to add new values at the end,\n        // as we may have iterators already running on the array\n        this._results.push(value);\n        this._onStateChanged.fire();\n    }\n    /**\n     * The values will be appended at the end.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    emitMany(values) {\n        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n            return;\n        }\n        // it is important to add new values at the end,\n        // as we may have iterators already running on the array\n        this._results = this._results.concat(values);\n        this._onStateChanged.fire();\n    }\n    /**\n     * Calling `resolve()` will mark the result array as complete.\n     *\n     * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    resolve() {\n        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n            return;\n        }\n        this._state = 1 /* AsyncIterableSourceState.DoneOK */;\n        this._onStateChanged.fire();\n    }\n    /**\n     * Writing an error will permanently invalidate this iterable.\n     * The current users will receive an error thrown, as will all future users.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    reject(error) {\n        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n            return;\n        }\n        this._state = 2 /* AsyncIterableSourceState.DoneError */;\n        this._error = error;\n        this._onStateChanged.fire();\n    }\n}\nAsyncIterableObject.EMPTY = AsyncIterableObject.fromArray([]);\nexport class CancelableAsyncIterableObject extends AsyncIterableObject {\n    constructor(_source, executor) {\n        super(executor);\n        this._source = _source;\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nexport function createCancelableAsyncIterable(callback) {\n    const source = new CancellationTokenSource();\n    const innerIterable = callback(source.token);\n    return new CancelableAsyncIterableObject(source, (emitter) => __awaiter(this, void 0, void 0, function* () {\n        var e_5, _a;\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(new CancellationError());\n        });\n        try {\n            try {\n                for (var innerIterable_1 = __asyncValues(innerIterable), innerIterable_1_1; innerIterable_1_1 = yield innerIterable_1.next(), !innerIterable_1_1.done;) {\n                    const item = innerIterable_1_1.value;\n                    if (source.token.isCancellationRequested) {\n                        // canceled in the meantime\n                        return;\n                    }\n                    emitter.emitOne(item);\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (innerIterable_1_1 && !innerIterable_1_1.done && (_a = innerIterable_1.return)) yield _a.call(innerIterable_1);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n            subscription.dispose();\n            source.dispose();\n        }\n        catch (err) {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(err);\n        }\n    }));\n}\n//#endregion\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}