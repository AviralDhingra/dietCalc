{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { once } from './functional.js';\nimport { Iterable } from './iterator.js';\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n  disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n  const __is_disposable_tracked__ = '__is_disposable_tracked__';\n  setDisposableTracker(new class {\n    trackDisposable(x) {\n      const stack = new Error('Potentially leaked disposable').stack;\n      setTimeout(() => {\n        if (!x[__is_disposable_tracked__]) {\n          console.log(stack);\n        }\n      }, 3000);\n    }\n    setParent(child, parent) {\n      if (child && child !== Disposable.None) {\n        try {\n          child[__is_disposable_tracked__] = true;\n        } catch (_a) {\n          // noop\n        }\n      }\n    }\n    markAsDisposed(disposable) {\n      if (disposable && disposable !== Disposable.None) {\n        try {\n          disposable[__is_disposable_tracked__] = true;\n        } catch (_a) {\n          // noop\n        }\n      }\n    }\n    markAsSingleton(disposable) {}\n  }());\n}\nfunction trackDisposable(x) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n  return x;\n}\nfunction markAsDisposed(disposable) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n  if (!disposableTracker) {\n    return;\n  }\n  for (const child of children) {\n    disposableTracker.setParent(child, parent);\n  }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton(singleton) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\n  return singleton;\n}\nexport class MultiDisposeError extends Error {\n  constructor(errors) {\n    super(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);\n    this.errors = errors;\n  }\n}\nexport function isDisposable(thing) {\n  return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n  if (Iterable.is(arg)) {\n    const errors = [];\n    for (const d of arg) {\n      if (d) {\n        try {\n          d.dispose();\n        } catch (e) {\n          errors.push(e);\n        }\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      throw new MultiDisposeError(errors);\n    }\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    arg.dispose();\n    return arg;\n  }\n}\nexport function combinedDisposable() {\n  for (var _len = arguments.length, disposables = new Array(_len), _key = 0; _key < _len; _key++) {\n    disposables[_key] = arguments[_key];\n  }\n  const parent = toDisposable(() => dispose(disposables));\n  setParentOfDisposables(disposables, parent);\n  return parent;\n}\nexport function toDisposable(fn) {\n  const self = trackDisposable({\n    dispose: once(() => {\n      markAsDisposed(self);\n      fn();\n    })\n  });\n  return self;\n}\nexport class DisposableStore {\n  constructor() {\n    this._toDispose = new Set();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Dispose of all registered disposables and mark this object as disposed.\n   *\n   * Any future disposables added to this object will be disposed of on `add`.\n   */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clear();\n  }\n  /**\n   * Returns `true` if this object has been disposed\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Dispose of all registered disposables but do not mark this object as disposed.\n   */\n  clear() {\n    try {\n      dispose(this._toDispose.values());\n    } finally {\n      this._toDispose.clear();\n    }\n  }\n  add(o) {\n    if (!o) {\n      return o;\n    }\n    if (o === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    setParentOfDisposable(o, this);\n    if (this._isDisposed) {\n      if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n        console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n      }\n    } else {\n      this._toDispose.add(o);\n    }\n    return o;\n  }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport class Disposable {\n  constructor() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n    setParentOfDisposable(this._store, this);\n  }\n  dispose() {\n    markAsDisposed(this);\n    this._store.dispose();\n  }\n  _register(o) {\n    if (o === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    return this._store.add(o);\n  }\n}\nDisposable.None = Object.freeze({\n  dispose() {}\n});\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable {\n  constructor() {\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  get value() {\n    return this._isDisposed ? undefined : this._value;\n  }\n  set value(value) {\n    var _a;\n    if (this._isDisposed || value === this._value) {\n      return;\n    }\n    (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n    if (value) {\n      setParentOfDisposable(value, this);\n    }\n    this._value = value;\n  }\n  clear() {\n    this.value = undefined;\n  }\n  dispose() {\n    var _a;\n    this._isDisposed = true;\n    markAsDisposed(this);\n    (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._value = undefined;\n  }\n  /**\n   * Clears the value, but does not dispose it.\n   * The old value is returned.\n  */\n  clearAndLeak() {\n    const oldValue = this._value;\n    this._value = undefined;\n    if (oldValue) {\n      setParentOfDisposable(oldValue, null);\n    }\n    return oldValue;\n  }\n}\nexport class RefCountedDisposable {\n  constructor(_disposable) {\n    this._disposable = _disposable;\n    this._counter = 1;\n  }\n  acquire() {\n    this._counter++;\n    return this;\n  }\n  release() {\n    if (--this._counter === 0) {\n      this._disposable.dispose();\n    }\n    return this;\n  }\n}\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nexport class SafeDisposable {\n  constructor() {\n    this.dispose = () => {};\n    this.unset = () => {};\n    this.isset = () => false;\n    trackDisposable(this);\n  }\n  set(fn) {\n    let callback = fn;\n    this.unset = () => callback = undefined;\n    this.isset = () => callback !== undefined;\n    this.dispose = () => {\n      if (callback) {\n        callback();\n        callback = undefined;\n        markAsDisposed(this);\n      }\n    };\n    return this;\n  }\n}\nexport class ImmortalReference {\n  constructor(object) {\n    this.object = object;\n  }\n  dispose() {}\n}","map":{"version":3,"names":["once","Iterable","TRACK_DISPOSABLES","disposableTracker","setDisposableTracker","tracker","__is_disposable_tracked__","trackDisposable","x","stack","Error","setTimeout","console","log","setParent","child","parent","Disposable","None","_a","markAsDisposed","disposable","markAsSingleton","setParentOfDisposable","setParentOfDisposables","children","singleton","MultiDisposeError","constructor","errors","join","isDisposable","thing","dispose","length","arg","is","d","e","push","Array","isArray","combinedDisposable","disposables","toDisposable","fn","self","DisposableStore","_toDispose","Set","_isDisposed","clear","isDisposed","values","add","o","DISABLE_DISPOSED_WARNING","warn","_store","_register","Object","freeze","MutableDisposable","value","undefined","_value","clearAndLeak","oldValue","RefCountedDisposable","_disposable","_counter","acquire","release","SafeDisposable","unset","isset","set","callback","ImmortalReference","object"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { once } from './functional.js';\nimport { Iterable } from './iterator.js';\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    setDisposableTracker(new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        setParent(child, parent) {\n            if (child && child !== Disposable.None) {\n                try {\n                    child[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsDisposed(disposable) {\n            if (disposable && disposable !== Disposable.None) {\n                try {\n                    disposable[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsSingleton(disposable) { }\n    });\n}\nfunction trackDisposable(x) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n    return x;\n}\nfunction markAsDisposed(disposable) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton(singleton) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\n    return singleton;\n}\nexport class MultiDisposeError extends Error {\n    constructor(errors) {\n        super(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);\n        this.errors = errors;\n    }\n}\nexport function isDisposable(thing) {\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n    if (Iterable.is(arg)) {\n        const errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new MultiDisposeError(errors);\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\nexport function combinedDisposable(...disposables) {\n    const parent = toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\nexport function toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: once(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\nexport class DisposableStore {\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * Returns `true` if this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        try {\n            dispose(this._toDispose.values());\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport class Disposable {\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    _register(o) {\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(o);\n    }\n}\nDisposable.None = Object.freeze({ dispose() { } });\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        var _a;\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        var _a;\n        this._isDisposed = true;\n        markAsDisposed(this);\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._value = undefined;\n    }\n    /**\n     * Clears the value, but does not dispose it.\n     * The old value is returned.\n    */\n    clearAndLeak() {\n        const oldValue = this._value;\n        this._value = undefined;\n        if (oldValue) {\n            setParentOfDisposable(oldValue, null);\n        }\n        return oldValue;\n    }\n}\nexport class RefCountedDisposable {\n    constructor(_disposable) {\n        this._disposable = _disposable;\n        this._counter = 1;\n    }\n    acquire() {\n        this._counter++;\n        return this;\n    }\n    release() {\n        if (--this._counter === 0) {\n            this._disposable.dispose();\n        }\n        return this;\n    }\n}\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nexport class SafeDisposable {\n    constructor() {\n        this.dispose = () => { };\n        this.unset = () => { };\n        this.isset = () => false;\n        trackDisposable(this);\n    }\n    set(fn) {\n        let callback = fn;\n        this.unset = () => callback = undefined;\n        this.isset = () => callback !== undefined;\n        this.dispose = () => {\n            if (callback) {\n                callback();\n                callback = undefined;\n                markAsDisposed(this);\n            }\n        };\n        return this;\n    }\n}\nexport class ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}