{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n  static has(key) {\n    return ContextKeyDefinedExpr.create(key);\n  }\n  static equals(key, value) {\n    return ContextKeyEqualsExpr.create(key, value);\n  }\n  static regex(key, value) {\n    return ContextKeyRegexExpr.create(key, value);\n  }\n  static not(key) {\n    return ContextKeyNotExpr.create(key);\n  }\n  static and() {\n    for (var _len = arguments.length, expr = new Array(_len), _key = 0; _key < _len; _key++) {\n      expr[_key] = arguments[_key];\n    }\n    return ContextKeyAndExpr.create(expr, null);\n  }\n  static or() {\n    for (var _len2 = arguments.length, expr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      expr[_key2] = arguments[_key2];\n    }\n    return ContextKeyOrExpr.create(expr, null, true);\n  }\n  static deserialize(serialized) {\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!serialized) {\n      return undefined;\n    }\n    return this._deserializeOrExpression(serialized, strict);\n  }\n  static _deserializeOrExpression(serialized, strict) {\n    const pieces = serialized.split('||');\n    return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)), null, true);\n  }\n  static _deserializeAndExpression(serialized, strict) {\n    const pieces = serialized.split('&&');\n    return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)), null);\n  }\n  static _deserializeOne(serializedOne, strict) {\n    serializedOne = serializedOne.trim();\n    if (serializedOne.indexOf('!=') >= 0) {\n      const pieces = serializedOne.split('!=');\n      return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n    if (serializedOne.indexOf('==') >= 0) {\n      const pieces = serializedOne.split('==');\n      return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n    if (serializedOne.indexOf('=~') >= 0) {\n      const pieces = serializedOne.split('=~');\n      return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n    }\n    if (serializedOne.indexOf(' not in ') >= 0) {\n      const pieces = serializedOne.split(' not in ');\n      return ContextKeyNotInExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (serializedOne.indexOf(' in ') >= 0) {\n      const pieces = serializedOne.split(' in ');\n      return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('>=');\n      return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('>');\n      return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('<=');\n      return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('<');\n      return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^\\!\\s*/.test(serializedOne)) {\n      return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n    }\n    return ContextKeyDefinedExpr.create(serializedOne);\n  }\n  static _deserializeValue(serializedValue, strict) {\n    serializedValue = serializedValue.trim();\n    if (serializedValue === 'true') {\n      return true;\n    }\n    if (serializedValue === 'false') {\n      return false;\n    }\n    const m = /^'([^']*)'$/.exec(serializedValue);\n    if (m) {\n      return m[1].trim();\n    }\n    return serializedValue;\n  }\n  static _deserializeRegexValue(serializedValue, strict) {\n    if (isFalsyOrWhitespace(serializedValue)) {\n      if (strict) {\n        throw new Error('missing regexp-value for =~-expression');\n      } else {\n        console.warn('missing regexp-value for =~-expression');\n      }\n      return null;\n    }\n    const start = serializedValue.indexOf('/');\n    const end = serializedValue.lastIndexOf('/');\n    if (start === end || start < 0 /* || to < 0 */) {\n      if (strict) {\n        throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n      } else {\n        console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n      }\n      return null;\n    }\n    const value = serializedValue.slice(start + 1, end);\n    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n    try {\n      return new RegExp(value, caseIgnoreFlag);\n    } catch (e) {\n      if (strict) {\n        throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n      } else {\n        console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n      }\n      return null;\n    }\n  }\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n  const aExpr = a ? a.substituteConstants() : undefined;\n  const bExpr = b ? b.substituteConstants() : undefined;\n  if (!aExpr && !bExpr) {\n    return true;\n  }\n  if (!aExpr || !bExpr) {\n    return false;\n  }\n  return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n  return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n  constructor() {\n    this.type = 0 /* ContextKeyExprType.False */;\n  }\n\n  cmp(other) {\n    return this.type - other.type;\n  }\n  equals(other) {\n    return other.type === this.type;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return false;\n  }\n  serialize() {\n    return 'false';\n  }\n  keys() {\n    return [];\n  }\n  negate() {\n    return ContextKeyTrueExpr.INSTANCE;\n  }\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n  constructor() {\n    this.type = 1 /* ContextKeyExprType.True */;\n  }\n\n  cmp(other) {\n    return this.type - other.type;\n  }\n  equals(other) {\n    return other.type === this.type;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return true;\n  }\n  serialize() {\n    return 'true';\n  }\n  keys() {\n    return [];\n  }\n  negate() {\n    return ContextKeyFalseExpr.INSTANCE;\n  }\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 2 /* ContextKeyExprType.Defined */;\n  }\n\n  static create(key) {\n    let negated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return new ContextKeyDefinedExpr(key, negated);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp1(this.key, other.key);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    return !!context.getValue(this.key);\n  }\n  serialize() {\n    return this.key;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotExpr.create(this.key, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 4 /* ContextKeyExprType.Equals */;\n  }\n\n  static create(key, value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (typeof value === 'boolean') {\n      return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);\n    }\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return new ContextKeyEqualsExpr(key, value, negated);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    // Intentional ==\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) == this.value;\n  }\n  serialize() {\n    return `${this.key} == '${this.value}'`;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyInExpr {\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 10 /* ContextKeyExprType.In */;\n    this.negated = null;\n  }\n  static create(key, valueKey) {\n    return new ContextKeyInExpr(key, valueKey);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.valueKey === other.valueKey;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    const source = context.getValue(this.valueKey);\n    const item = context.getValue(this.key);\n    if (Array.isArray(source)) {\n      return source.includes(item);\n    }\n    if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n      return hasOwnProperty.call(source, item);\n    }\n    return false;\n  }\n  serialize() {\n    return `${this.key} in '${this.valueKey}'`;\n  }\n  keys() {\n    return [this.key, this.valueKey];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyNotInExpr {\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 11 /* ContextKeyExprType.NotIn */;\n    this._negated = ContextKeyInExpr.create(key, valueKey);\n  }\n  static create(key, valueKey) {\n    return new ContextKeyNotInExpr(key, valueKey);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return this._negated.cmp(other._negated);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this._negated.equals(other._negated);\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return !this._negated.evaluate(context);\n  }\n  serialize() {\n    return `${this.key} not in '${this.valueKey}'`;\n  }\n  keys() {\n    return this._negated.keys();\n  }\n  negate() {\n    return this._negated;\n  }\n}\nexport class ContextKeyNotEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 5 /* ContextKeyExprType.NotEquals */;\n  }\n\n  static create(key, value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (typeof value === 'boolean') {\n      if (value) {\n        return ContextKeyNotExpr.create(key, negated);\n      }\n      return ContextKeyDefinedExpr.create(key, negated);\n    }\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return new ContextKeyNotEqualsExpr(key, value, negated);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    // Intentional !=\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) != this.value;\n  }\n  serialize() {\n    return `${this.key} != '${this.value}'`;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyNotExpr {\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 3 /* ContextKeyExprType.Not */;\n  }\n\n  static create(key) {\n    let negated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return new ContextKeyNotExpr(key, negated);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp1(this.key, other.key);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    return !context.getValue(this.key);\n  }\n  serialize() {\n    return `!${this.key}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyDefinedExpr.create(this.key, this);\n    }\n    return this.negated;\n  }\n}\nfunction withFloatOrStr(value, callback) {\n  if (typeof value === 'string') {\n    const n = parseFloat(value);\n    if (!isNaN(n)) {\n      value = n;\n    }\n  }\n  if (typeof value === 'string' || typeof value === 'number') {\n    return callback(value);\n  }\n  return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 12 /* ContextKeyExprType.Greater */;\n  }\n\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeyGreaterExpr(key, value, negated));\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) > this.value;\n  }\n  serialize() {\n    return `${this.key} > ${this.value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyGreaterEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 13 /* ContextKeyExprType.GreaterEquals */;\n  }\n\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeyGreaterEqualsExpr(key, value, negated));\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) >= this.value;\n  }\n  serialize() {\n    return `${this.key} >= ${this.value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeySmallerExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 14 /* ContextKeyExprType.Smaller */;\n  }\n\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeySmallerExpr(key, value, negated));\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) < this.value;\n  }\n  serialize() {\n    return `${this.key} < ${this.value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeySmallerEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 15 /* ContextKeyExprType.SmallerEquals */;\n  }\n\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeySmallerEqualsExpr(key, value, negated));\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) <= this.value;\n  }\n  serialize() {\n    return `${this.key} <= ${this.value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyRegexExpr {\n  constructor(key, regexp) {\n    this.key = key;\n    this.regexp = regexp;\n    this.type = 7 /* ContextKeyExprType.Regex */;\n    this.negated = null;\n    //\n  }\n\n  static create(key, regexp) {\n    return new ContextKeyRegexExpr(key, regexp);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.key < other.key) {\n      return -1;\n    }\n    if (this.key > other.key) {\n      return 1;\n    }\n    const thisSource = this.regexp ? this.regexp.source : '';\n    const otherSource = other.regexp ? other.regexp.source : '';\n    if (thisSource < otherSource) {\n      return -1;\n    }\n    if (thisSource > otherSource) {\n      return 1;\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      const thisSource = this.regexp ? this.regexp.source : '';\n      const otherSource = other.regexp ? other.regexp.source : '';\n      return this.key === other.key && thisSource === otherSource;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    const value = context.getValue(this.key);\n    return this.regexp ? this.regexp.test(value) : false;\n  }\n  serialize() {\n    const value = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}` : '/invalid/';\n    return `${this.key} =~ ${value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotRegexExpr.create(this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyNotRegexExpr {\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 8 /* ContextKeyExprType.NotRegex */;\n    //\n  }\n\n  static create(actual) {\n    return new ContextKeyNotRegexExpr(actual);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return this._actual.cmp(other._actual);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n  serialize() {\n    throw new Error('Method not implemented.');\n  }\n  keys() {\n    return this._actual.keys();\n  }\n  negate() {\n    return this._actual;\n  }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n  // Allocate array only if there is a difference\n  let newArr = null;\n  for (let i = 0, len = arr.length; i < len; i++) {\n    const newExpr = arr[i].substituteConstants();\n    if (arr[i] !== newExpr) {\n      // something has changed!\n      // allocate array on first difference\n      if (newArr === null) {\n        newArr = [];\n        for (let j = 0; j < i; j++) {\n          newArr[j] = arr[j];\n        }\n      }\n    }\n    if (newArr !== null) {\n      newArr[i] = newExpr;\n    }\n  }\n  if (newArr === null) {\n    return arr;\n  }\n  return newArr;\n}\nclass ContextKeyAndExpr {\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 6 /* ContextKeyExprType.And */;\n  }\n\n  static create(_expr, negated) {\n    return ContextKeyAndExpr._normalizeArr(_expr, negated);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n    if (exprArr === this.expr) {\n      // no change\n      return this;\n    }\n    return ContextKeyAndExpr.create(exprArr, this.negated);\n  }\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (!this.expr[i].evaluate(context)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _normalizeArr(arr, negated) {\n    const expr = [];\n    let hasTrue = false;\n    for (const e of arr) {\n      if (!e) {\n        continue;\n      }\n      if (e.type === 1 /* ContextKeyExprType.True */) {\n        // anything && true ==> anything\n        hasTrue = true;\n        continue;\n      }\n      if (e.type === 0 /* ContextKeyExprType.False */) {\n        // anything && false ==> false\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n      if (e.type === 6 /* ContextKeyExprType.And */) {\n        expr.push(...e.expr);\n        continue;\n      }\n      expr.push(e);\n    }\n    if (expr.length === 0 && hasTrue) {\n      return ContextKeyTrueExpr.INSTANCE;\n    }\n    if (expr.length === 0) {\n      return undefined;\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    expr.sort(cmp);\n    // eliminate duplicate terms\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    // We must distribute any OR expression because we don't support parens\n    // OR extensions will be at the end (due to sorting rules)\n    while (expr.length > 1) {\n      const lastElement = expr[expr.length - 1];\n      if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {\n        break;\n      }\n      // pop the last element\n      expr.pop();\n      // pop the second to last element\n      const secondToLastElement = expr.pop();\n      const isFinished = expr.length === 0;\n      // distribute `lastElement` over `secondToLastElement`\n      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null)), null, isFinished);\n      if (resultElement) {\n        expr.push(resultElement);\n        expr.sort(cmp);\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    return new ContextKeyAndExpr(expr, negated);\n  }\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' && ');\n  }\n  keys() {\n    const result = [];\n    for (const expr of this.expr) {\n      result.push(...expr.keys());\n    }\n    return result;\n  }\n  negate() {\n    if (!this.negated) {\n      const result = [];\n      for (const expr of this.expr) {\n        result.push(expr.negate());\n      }\n      this.negated = ContextKeyOrExpr.create(result, this, true);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyOrExpr {\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 9 /* ContextKeyExprType.Or */;\n  }\n\n  static create(_expr, negated, extraRedundantCheck) {\n    return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n    if (exprArr === this.expr) {\n      // no change\n      return this;\n    }\n    return ContextKeyOrExpr.create(exprArr, this.negated, false);\n  }\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (this.expr[i].evaluate(context)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static _normalizeArr(arr, negated, extraRedundantCheck) {\n    let expr = [];\n    let hasFalse = false;\n    if (arr) {\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const e = arr[i];\n        if (!e) {\n          continue;\n        }\n        if (e.type === 0 /* ContextKeyExprType.False */) {\n          // anything || false ==> anything\n          hasFalse = true;\n          continue;\n        }\n        if (e.type === 1 /* ContextKeyExprType.True */) {\n          // anything || true ==> true\n          return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (e.type === 9 /* ContextKeyExprType.Or */) {\n          expr = expr.concat(e.expr);\n          continue;\n        }\n        expr.push(e);\n      }\n      if (expr.length === 0 && hasFalse) {\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n      expr.sort(cmp);\n    }\n    if (expr.length === 0) {\n      return undefined;\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    // eliminate duplicate terms\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    // eliminate redundant terms\n    if (extraRedundantCheck) {\n      for (let i = 0; i < expr.length; i++) {\n        for (let j = i + 1; j < expr.length; j++) {\n          if (implies(expr[i], expr[j])) {\n            expr.splice(j, 1);\n            j--;\n          }\n        }\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n    }\n    return new ContextKeyOrExpr(expr, negated);\n  }\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' || ');\n  }\n  keys() {\n    const result = [];\n    for (const expr of this.expr) {\n      result.push(...expr.keys());\n    }\n    return result;\n  }\n  negate() {\n    if (!this.negated) {\n      const result = [];\n      for (const expr of this.expr) {\n        result.push(expr.negate());\n      }\n      // We don't support parens, so here we distribute the AND over the OR terminals\n      // We always take the first 2 AND pairs and distribute them\n      while (result.length > 1) {\n        const LEFT = result.shift();\n        const RIGHT = result.shift();\n        const all = [];\n        for (const left of getTerminals(LEFT)) {\n          for (const right of getTerminals(RIGHT)) {\n            all.push(ContextKeyAndExpr.create([left, right], null));\n          }\n        }\n        const isFinished = result.length === 0;\n        result.unshift(ContextKeyOrExpr.create(all, null, isFinished));\n      }\n      this.negated = result[0];\n    }\n    return this.negated;\n  }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n  constructor(key, defaultValue, metaOrHide) {\n    super(key, null);\n    this._defaultValue = defaultValue;\n    // collect all context keys into a central place\n    if (typeof metaOrHide === 'object') {\n      RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), {\n        key\n      }));\n    } else if (metaOrHide !== true) {\n      RawContextKey._info.push({\n        key,\n        description: metaOrHide,\n        type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined\n      });\n    }\n  }\n  static all() {\n    return RawContextKey._info.values();\n  }\n  bindTo(target) {\n    return target.createKey(this.key, this._defaultValue);\n  }\n  getValue(target) {\n    return target.getContextKeyValue(this.key);\n  }\n  toNegated() {\n    return this.negate();\n  }\n  isEqualTo(value) {\n    return ContextKeyEqualsExpr.create(this.key, value);\n  }\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\nfunction cmp1(key1, key2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  if (value1 < value2) {\n    return -1;\n  }\n  if (value1 > value2) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n  if (q.type === 6 /* ContextKeyExprType.And */ && p.type !== 9 /* ContextKeyExprType.Or */ && p.type !== 6 /* ContextKeyExprType.And */) {\n    // covers the case: A implies A && B\n    for (const qTerm of q.expr) {\n      if (p.equals(qTerm)) {\n        return true;\n      }\n    }\n  }\n  const notP = p.negate();\n  const expr = getTerminals(notP).concat(getTerminals(q));\n  expr.sort(cmp);\n  for (let i = 0; i < expr.length; i++) {\n    const a = expr[i];\n    const notA = a.negate();\n    for (let j = i + 1; j < expr.length; j++) {\n      const b = expr[j];\n      if (notA.equals(b)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction getTerminals(node) {\n  if (node.type === 9 /* ContextKeyExprType.Or */) {\n    return node.expr;\n  }\n  return [node];\n}","map":{"version":3,"names":["isChrome","isEdge","isFirefox","isLinux","isMacintosh","isSafari","isWeb","isWindows","isFalsyOrWhitespace","createDecorator","CONSTANT_VALUES","Map","set","hasOwnProperty","Object","prototype","ContextKeyExpr","has","key","ContextKeyDefinedExpr","create","equals","value","ContextKeyEqualsExpr","regex","ContextKeyRegexExpr","not","ContextKeyNotExpr","and","expr","ContextKeyAndExpr","or","ContextKeyOrExpr","deserialize","serialized","strict","undefined","_deserializeOrExpression","pieces","split","map","p","_deserializeAndExpression","_deserializeOne","serializedOne","trim","indexOf","ContextKeyNotEqualsExpr","_deserializeValue","_deserializeRegexValue","ContextKeyNotInExpr","ContextKeyInExpr","test","ContextKeyGreaterEqualsExpr","ContextKeyGreaterExpr","ContextKeySmallerEqualsExpr","ContextKeySmallerExpr","substr","serializedValue","m","exec","Error","console","warn","start","end","lastIndexOf","slice","caseIgnoreFlag","RegExp","e","expressionsAreEqualWithConstantSubstitution","a","b","aExpr","substituteConstants","bExpr","cmp","ContextKeyFalseExpr","constructor","type","other","evaluate","context","serialize","keys","negate","ContextKeyTrueExpr","INSTANCE","negated","constantValue","get","cmp1","getValue","trueValue","cmp2","valueKey","source","item","Array","isArray","includes","call","_negated","falseValue","withFloatOrStr","callback","n","parseFloat","isNaN","_value","regexp","thisSource","otherSource","ignoreCase","ContextKeyNotRegexExpr","_actual","actual","eliminateConstantsInArray","arr","newArr","i","len","length","newExpr","j","_expr","_normalizeArr","r","exprArr","hasTrue","push","sort","splice","lastElement","pop","secondToLastElement","isFinished","resultElement","el","join","result","extraRedundantCheck","hasFalse","concat","implies","LEFT","shift","RIGHT","all","left","getTerminals","right","unshift","RawContextKey","defaultValue","metaOrHide","_defaultValue","_info","assign","description","values","bindTo","target","createKey","getContextKeyValue","toNegated","isEqualTo","IContextKeyService","SET_CONTEXT_COMMAND_ID","key1","key2","value1","value2","q","qTerm","notP","notA","node"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static deserialize(serialized, strict = false) {\n        if (!serialized) {\n            return undefined;\n        }\n        return this._deserializeOrExpression(serialized, strict);\n    }\n    static _deserializeOrExpression(serialized, strict) {\n        const pieces = serialized.split('||');\n        return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)), null, true);\n    }\n    static _deserializeAndExpression(serialized, strict) {\n        const pieces = serialized.split('&&');\n        return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)), null);\n    }\n    static _deserializeOne(serializedOne, strict) {\n        serializedOne = serializedOne.trim();\n        if (serializedOne.indexOf('!=') >= 0) {\n            const pieces = serializedOne.split('!=');\n            return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('==') >= 0) {\n            const pieces = serializedOne.split('==');\n            return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('=~') >= 0) {\n            const pieces = serializedOne.split('=~');\n            return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf(' not in ') >= 0) {\n            const pieces = serializedOne.split(' not in ');\n            return ContextKeyNotInExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (serializedOne.indexOf(' in ') >= 0) {\n            const pieces = serializedOne.split(' in ');\n            return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>=');\n            return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>');\n            return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<=');\n            return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<');\n            return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^\\!\\s*/.test(serializedOne)) {\n            return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n        }\n        return ContextKeyDefinedExpr.create(serializedOne);\n    }\n    static _deserializeValue(serializedValue, strict) {\n        serializedValue = serializedValue.trim();\n        if (serializedValue === 'true') {\n            return true;\n        }\n        if (serializedValue === 'false') {\n            return false;\n        }\n        const m = /^'([^']*)'$/.exec(serializedValue);\n        if (m) {\n            return m[1].trim();\n        }\n        return serializedValue;\n    }\n    static _deserializeRegexValue(serializedValue, strict) {\n        if (isFalsyOrWhitespace(serializedValue)) {\n            if (strict) {\n                throw new Error('missing regexp-value for =~-expression');\n            }\n            else {\n                console.warn('missing regexp-value for =~-expression');\n            }\n            return null;\n        }\n        const start = serializedValue.indexOf('/');\n        const end = serializedValue.lastIndexOf('/');\n        if (start === end || start < 0 /* || to < 0 */) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            return null;\n        }\n        const value = serializedValue.slice(start + 1, end);\n        const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n        try {\n            return new RegExp(value, caseIgnoreFlag);\n        }\n        catch (e) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            return null;\n        }\n    }\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    constructor() {\n        this.type = 0 /* ContextKeyExprType.False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n    constructor() {\n        this.type = 1 /* ContextKeyExprType.True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 /* ContextKeyExprType.Defined */;\n    }\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 /* ContextKeyExprType.Equals */;\n    }\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyInExpr {\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* ContextKeyExprType.In */;\n        this.negated = null;\n    }\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return source.includes(item);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotInExpr {\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 11 /* ContextKeyExprType.NotIn */;\n        this._negated = ContextKeyInExpr.create(key, valueKey);\n    }\n    static create(key, valueKey) {\n        return new ContextKeyNotInExpr(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._negated.cmp(other._negated);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._negated.equals(other._negated);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._negated.evaluate(context);\n    }\n    serialize() {\n        return `${this.key} not in '${this.valueKey}'`;\n    }\n    keys() {\n        return this._negated.keys();\n    }\n    negate() {\n        return this._negated;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 /* ContextKeyExprType.NotEquals */;\n    }\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key, negated);\n            }\n            return ContextKeyDefinedExpr.create(key, negated);\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotExpr {\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 /* ContextKeyExprType.Not */;\n    }\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyDefinedExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 /* ContextKeyExprType.Greater */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 /* ContextKeyExprType.GreaterEquals */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 /* ContextKeyExprType.Smaller */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 /* ContextKeyExprType.SmallerEquals */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyRegexExpr {\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* ContextKeyExprType.Regex */;\n        this.negated = null;\n        //\n    }\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* ContextKeyExprType.NotRegex */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n    // Allocate array only if there is a difference\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            // something has changed!\n            // allocate array on first difference\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nclass ContextKeyAndExpr {\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 /* ContextKeyExprType.And */;\n    }\n    static create(_expr, negated) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* ContextKeyExprType.True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* ContextKeyExprType.False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* ContextKeyExprType.And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null)), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        return new ContextKeyAndExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyOrExpr {\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 /* ContextKeyExprType.Or */;\n    }\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* ContextKeyExprType.False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* ContextKeyExprType.True */) {\n                    // anything || true ==> true\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 /* ContextKeyExprType.Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate redundant terms\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (implies(expr[i], expr[j])) {\n                        expr.splice(j, 1);\n                        j--;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyOrExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            // We don't support parens, so here we distribute the AND over the OR terminals\n            // We always take the first 2 AND pairs and distribute them\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null));\n                    }\n                }\n                const isFinished = (result.length === 0);\n                result.unshift(ContextKeyOrExpr.create(all, null, isFinished));\n            }\n            this.negated = result[0];\n        }\n        return this.negated;\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    static all() {\n        return RawContextKey._info.values();\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return this.negate();\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n    if (q.type === 6 /* ContextKeyExprType.And */ && (p.type !== 9 /* ContextKeyExprType.Or */ && p.type !== 6 /* ContextKeyExprType.And */)) {\n        // covers the case: A implies A && B\n        for (const qTerm of q.expr) {\n            if (p.equals(qTerm)) {\n                return true;\n            }\n        }\n    }\n    const notP = p.negate();\n    const expr = getTerminals(notP).concat(getTerminals(q));\n    expr.sort(cmp);\n    for (let i = 0; i < expr.length; i++) {\n        const a = expr[i];\n        const notA = a.negate();\n        for (let j = i + 1; j < expr.length; j++) {\n            const b = expr[j];\n            if (notA.equals(b)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction getTerminals(node) {\n    if (node.type === 9 /* ContextKeyExprType.Or */) {\n        return node.expr;\n    }\n    return [node];\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,SAAS,EAAEC,OAAO,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,SAAS,QAAQ,kCAAkC;AAChI,SAASC,mBAAmB,QAAQ,iCAAiC;AACrE,SAASC,eAAe,QAAQ,6CAA6C;AAC7E,MAAMC,eAAe,GAAG,IAAIC,GAAG,EAAE;AACjCD,eAAe,CAACE,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC;AACnCF,eAAe,CAACE,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC;AACjCF,eAAe,CAACE,GAAG,CAAC,OAAO,EAAER,WAAW,CAAC;AACzCM,eAAe,CAACE,GAAG,CAAC,SAAS,EAAET,OAAO,CAAC;AACvCO,eAAe,CAACE,GAAG,CAAC,WAAW,EAAEL,SAAS,CAAC;AAC3CG,eAAe,CAACE,GAAG,CAAC,OAAO,EAAEN,KAAK,CAAC;AACnCI,eAAe,CAACE,GAAG,CAAC,aAAa,EAAER,WAAW,IAAI,CAACE,KAAK,CAAC;AACzDI,eAAe,CAACE,GAAG,CAAC,QAAQ,EAAEX,MAAM,CAAC;AACrCS,eAAe,CAACE,GAAG,CAAC,WAAW,EAAEV,SAAS,CAAC;AAC3CQ,eAAe,CAACE,GAAG,CAAC,UAAU,EAAEZ,QAAQ,CAAC;AACzCU,eAAe,CAACE,GAAG,CAAC,UAAU,EAAEP,QAAQ,CAAC;AACzC,MAAMQ,cAAc,GAAGC,MAAM,CAACC,SAAS,CAACF,cAAc;AACtD,OAAO,MAAMG,cAAc,CAAC;EACxB,OAAOC,GAAG,CAACC,GAAG,EAAE;IACZ,OAAOC,qBAAqB,CAACC,MAAM,CAACF,GAAG,CAAC;EAC5C;EACA,OAAOG,MAAM,CAACH,GAAG,EAAEI,KAAK,EAAE;IACtB,OAAOC,oBAAoB,CAACH,MAAM,CAACF,GAAG,EAAEI,KAAK,CAAC;EAClD;EACA,OAAOE,KAAK,CAACN,GAAG,EAAEI,KAAK,EAAE;IACrB,OAAOG,mBAAmB,CAACL,MAAM,CAACF,GAAG,EAAEI,KAAK,CAAC;EACjD;EACA,OAAOI,GAAG,CAACR,GAAG,EAAE;IACZ,OAAOS,iBAAiB,CAACP,MAAM,CAACF,GAAG,CAAC;EACxC;EACA,OAAOU,GAAG,GAAU;IAAA,kCAANC,IAAI;MAAJA,IAAI;IAAA;IACd,OAAOC,iBAAiB,CAACV,MAAM,CAACS,IAAI,EAAE,IAAI,CAAC;EAC/C;EACA,OAAOE,EAAE,GAAU;IAAA,mCAANF,IAAI;MAAJA,IAAI;IAAA;IACb,OAAOG,gBAAgB,CAACZ,MAAM,CAACS,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;EACpD;EACA,OAAOI,WAAW,CAACC,UAAU,EAAkB;IAAA,IAAhBC,MAAM,uEAAG,KAAK;IACzC,IAAI,CAACD,UAAU,EAAE;MACb,OAAOE,SAAS;IACpB;IACA,OAAO,IAAI,CAACC,wBAAwB,CAACH,UAAU,EAAEC,MAAM,CAAC;EAC5D;EACA,OAAOE,wBAAwB,CAACH,UAAU,EAAEC,MAAM,EAAE;IAChD,MAAMG,MAAM,GAAGJ,UAAU,CAACK,KAAK,CAAC,IAAI,CAAC;IACrC,OAAOP,gBAAgB,CAACZ,MAAM,CAACkB,MAAM,CAACE,GAAG,CAACC,CAAC,IAAI,IAAI,CAACC,yBAAyB,CAACD,CAAC,EAAEN,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;EAC1G;EACA,OAAOO,yBAAyB,CAACR,UAAU,EAAEC,MAAM,EAAE;IACjD,MAAMG,MAAM,GAAGJ,UAAU,CAACK,KAAK,CAAC,IAAI,CAAC;IACrC,OAAOT,iBAAiB,CAACV,MAAM,CAACkB,MAAM,CAACE,GAAG,CAACC,CAAC,IAAI,IAAI,CAACE,eAAe,CAACF,CAAC,EAAEN,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC;EAC3F;EACA,OAAOQ,eAAe,CAACC,aAAa,EAAET,MAAM,EAAE;IAC1CS,aAAa,GAAGA,aAAa,CAACC,IAAI,EAAE;IACpC,IAAID,aAAa,CAACE,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;MAClC,MAAMR,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,IAAI,CAAC;MACxC,OAAOQ,uBAAuB,CAAC3B,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAE,IAAI,CAACG,iBAAiB,CAACV,MAAM,CAAC,CAAC,CAAC,EAAEH,MAAM,CAAC,CAAC;IACtG;IACA,IAAIS,aAAa,CAACE,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;MAClC,MAAMR,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,IAAI,CAAC;MACxC,OAAOhB,oBAAoB,CAACH,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAE,IAAI,CAACG,iBAAiB,CAACV,MAAM,CAAC,CAAC,CAAC,EAAEH,MAAM,CAAC,CAAC;IACnG;IACA,IAAIS,aAAa,CAACE,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;MAClC,MAAMR,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,IAAI,CAAC;MACxC,OAAOd,mBAAmB,CAACL,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAE,IAAI,CAACI,sBAAsB,CAACX,MAAM,CAAC,CAAC,CAAC,EAAEH,MAAM,CAAC,CAAC;IACvG;IACA,IAAIS,aAAa,CAACE,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;MACxC,MAAMR,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,UAAU,CAAC;MAC9C,OAAOW,mBAAmB,CAAC9B,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,CAAC;IACzE;IACA,IAAID,aAAa,CAACE,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;MACpC,MAAMR,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,MAAM,CAAC;MAC1C,OAAOY,gBAAgB,CAAC/B,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,CAAC;IACtE;IACA,IAAI,oBAAoB,CAACO,IAAI,CAACR,aAAa,CAAC,EAAE;MAC1C,MAAMN,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,IAAI,CAAC;MACxC,OAAOc,2BAA2B,CAACjC,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,CAAC;IACjF;IACA,IAAI,mBAAmB,CAACO,IAAI,CAACR,aAAa,CAAC,EAAE;MACzC,MAAMN,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,GAAG,CAAC;MACvC,OAAOe,qBAAqB,CAAClC,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,CAAC;IAC3E;IACA,IAAI,oBAAoB,CAACO,IAAI,CAACR,aAAa,CAAC,EAAE;MAC1C,MAAMN,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,IAAI,CAAC;MACxC,OAAOgB,2BAA2B,CAACnC,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,CAAC;IACjF;IACA,IAAI,mBAAmB,CAACO,IAAI,CAACR,aAAa,CAAC,EAAE;MACzC,MAAMN,MAAM,GAAGM,aAAa,CAACL,KAAK,CAAC,GAAG,CAAC;MACvC,OAAOiB,qBAAqB,CAACpC,MAAM,CAACkB,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACO,IAAI,EAAE,CAAC;IAC3E;IACA,IAAI,QAAQ,CAACO,IAAI,CAACR,aAAa,CAAC,EAAE;MAC9B,OAAOjB,iBAAiB,CAACP,MAAM,CAACwB,aAAa,CAACa,MAAM,CAAC,CAAC,CAAC,CAACZ,IAAI,EAAE,CAAC;IACnE;IACA,OAAO1B,qBAAqB,CAACC,MAAM,CAACwB,aAAa,CAAC;EACtD;EACA,OAAOI,iBAAiB,CAACU,eAAe,EAAEvB,MAAM,EAAE;IAC9CuB,eAAe,GAAGA,eAAe,CAACb,IAAI,EAAE;IACxC,IAAIa,eAAe,KAAK,MAAM,EAAE;MAC5B,OAAO,IAAI;IACf;IACA,IAAIA,eAAe,KAAK,OAAO,EAAE;MAC7B,OAAO,KAAK;IAChB;IACA,MAAMC,CAAC,GAAG,aAAa,CAACC,IAAI,CAACF,eAAe,CAAC;IAC7C,IAAIC,CAAC,EAAE;MACH,OAAOA,CAAC,CAAC,CAAC,CAAC,CAACd,IAAI,EAAE;IACtB;IACA,OAAOa,eAAe;EAC1B;EACA,OAAOT,sBAAsB,CAACS,eAAe,EAAEvB,MAAM,EAAE;IACnD,IAAI3B,mBAAmB,CAACkD,eAAe,CAAC,EAAE;MACtC,IAAIvB,MAAM,EAAE;QACR,MAAM,IAAI0B,KAAK,CAAC,wCAAwC,CAAC;MAC7D,CAAC,MACI;QACDC,OAAO,CAACC,IAAI,CAAC,wCAAwC,CAAC;MAC1D;MACA,OAAO,IAAI;IACf;IACA,MAAMC,KAAK,GAAGN,eAAe,CAACZ,OAAO,CAAC,GAAG,CAAC;IAC1C,MAAMmB,GAAG,GAAGP,eAAe,CAACQ,WAAW,CAAC,GAAG,CAAC;IAC5C,IAAIF,KAAK,KAAKC,GAAG,IAAID,KAAK,GAAG,CAAC,CAAC,iBAAiB;MAC5C,IAAI7B,MAAM,EAAE;QACR,MAAM,IAAI0B,KAAK,CAAE,qBAAoBH,eAAgB,wBAAuB,CAAC;MACjF,CAAC,MACI;QACDI,OAAO,CAACC,IAAI,CAAE,qBAAoBL,eAAgB,wBAAuB,CAAC;MAC9E;MACA,OAAO,IAAI;IACf;IACA,MAAMpC,KAAK,GAAGoC,eAAe,CAACS,KAAK,CAACH,KAAK,GAAG,CAAC,EAAEC,GAAG,CAAC;IACnD,MAAMG,cAAc,GAAGV,eAAe,CAACO,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,EAAE;IAClE,IAAI;MACA,OAAO,IAAII,MAAM,CAAC/C,KAAK,EAAE8C,cAAc,CAAC;IAC5C,CAAC,CACD,OAAOE,CAAC,EAAE;MACN,IAAInC,MAAM,EAAE;QACR,MAAM,IAAI0B,KAAK,CAAE,qBAAoBH,eAAgB,mBAAkBY,CAAE,EAAC,CAAC;MAC/E,CAAC,MACI;QACDR,OAAO,CAACC,IAAI,CAAE,qBAAoBL,eAAgB,mBAAkBY,CAAE,EAAC,CAAC;MAC5E;MACA,OAAO,IAAI;IACf;EACJ;AACJ;AACA,OAAO,SAASC,2CAA2C,CAACC,CAAC,EAAEC,CAAC,EAAE;EAC9D,MAAMC,KAAK,GAAGF,CAAC,GAAGA,CAAC,CAACG,mBAAmB,EAAE,GAAGvC,SAAS;EACrD,MAAMwC,KAAK,GAAGH,CAAC,GAAGA,CAAC,CAACE,mBAAmB,EAAE,GAAGvC,SAAS;EACrD,IAAI,CAACsC,KAAK,IAAI,CAACE,KAAK,EAAE;IAClB,OAAO,IAAI;EACf;EACA,IAAI,CAACF,KAAK,IAAI,CAACE,KAAK,EAAE;IAClB,OAAO,KAAK;EAChB;EACA,OAAOF,KAAK,CAACrD,MAAM,CAACuD,KAAK,CAAC;AAC9B;AACA,SAASC,GAAG,CAACL,CAAC,EAAEC,CAAC,EAAE;EACf,OAAOD,CAAC,CAACK,GAAG,CAACJ,CAAC,CAAC;AACnB;AACA,OAAO,MAAMK,mBAAmB,CAAC;EAC7BC,WAAW,GAAG;IACV,IAAI,CAACC,IAAI,GAAG,CAAC,CAAC;EAClB;;EACAH,GAAG,CAACI,KAAK,EAAE;IACP,OAAO,IAAI,CAACD,IAAI,GAAGC,KAAK,CAACD,IAAI;EACjC;EACA3D,MAAM,CAAC4D,KAAK,EAAE;IACV,OAAQA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI;EACpC;EACAL,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,OAAO,KAAK;EAChB;EACAC,SAAS,GAAG;IACR,OAAO,OAAO;EAClB;EACAC,IAAI,GAAG;IACH,OAAO,EAAE;EACb;EACAC,MAAM,GAAG;IACL,OAAOC,kBAAkB,CAACC,QAAQ;EACtC;AACJ;AACAV,mBAAmB,CAACU,QAAQ,GAAG,IAAIV,mBAAmB,EAAE;AACxD,OAAO,MAAMS,kBAAkB,CAAC;EAC5BR,WAAW,GAAG;IACV,IAAI,CAACC,IAAI,GAAG,CAAC,CAAC;EAClB;;EACAH,GAAG,CAACI,KAAK,EAAE;IACP,OAAO,IAAI,CAACD,IAAI,GAAGC,KAAK,CAACD,IAAI;EACjC;EACA3D,MAAM,CAAC4D,KAAK,EAAE;IACV,OAAQA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI;EACpC;EACAL,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,OAAO,IAAI;EACf;EACAC,SAAS,GAAG;IACR,OAAO,MAAM;EACjB;EACAC,IAAI,GAAG;IACH,OAAO,EAAE;EACb;EACAC,MAAM,GAAG;IACL,OAAOR,mBAAmB,CAACU,QAAQ;EACvC;AACJ;AACAD,kBAAkB,CAACC,QAAQ,GAAG,IAAID,kBAAkB,EAAE;AACtD,OAAO,MAAMpE,qBAAqB,CAAC;EAC/B4D,WAAW,CAAC7D,GAAG,EAAEuE,OAAO,EAAE;IACtB,IAAI,CAACvE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACuE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC;EAClB;;EACA,OAAO5D,MAAM,CAACF,GAAG,EAAkB;IAAA,IAAhBuE,OAAO,uEAAG,IAAI;IAC7B,MAAMC,aAAa,GAAGhF,eAAe,CAACiF,GAAG,CAACzE,GAAG,CAAC;IAC9C,IAAI,OAAOwE,aAAa,KAAK,SAAS,EAAE;MACpC,OAAOA,aAAa,GAAGH,kBAAkB,CAACC,QAAQ,GAAGV,mBAAmB,CAACU,QAAQ;IACrF;IACA,OAAO,IAAIrE,qBAAqB,CAACD,GAAG,EAAEuE,OAAO,CAAC;EAClD;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOY,IAAI,CAAC,IAAI,CAAC1E,GAAG,EAAE+D,KAAK,CAAC/D,GAAG,CAAC;EACpC;EACAG,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG;IAClC;IACA,OAAO,KAAK;EAChB;EACAyD,mBAAmB,GAAG;IAClB,MAAMe,aAAa,GAAGhF,eAAe,CAACiF,GAAG,CAAC,IAAI,CAACzE,GAAG,CAAC;IACnD,IAAI,OAAOwE,aAAa,KAAK,SAAS,EAAE;MACpC,OAAOA,aAAa,GAAGH,kBAAkB,CAACC,QAAQ,GAAGV,mBAAmB,CAACU,QAAQ;IACrF;IACA,OAAO,IAAI;EACf;EACAN,QAAQ,CAACC,OAAO,EAAE;IACd,OAAQ,CAAC,CAACA,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC;EACxC;EACAkE,SAAS,GAAG;IACR,OAAO,IAAI,CAAClE,GAAG;EACnB;EACAmE,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAG9D,iBAAiB,CAACP,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAAC;IAC3D;IACA,OAAO,IAAI,CAACuE,OAAO;EACvB;AACJ;AACA,OAAO,MAAMlE,oBAAoB,CAAC;EAC9BwD,WAAW,CAAC7D,GAAG,EAAEI,KAAK,EAAEmE,OAAO,EAAE;IAC7B,IAAI,CAACvE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACI,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC;EAClB;;EACA,OAAO5D,MAAM,CAACF,GAAG,EAAEI,KAAK,EAAkB;IAAA,IAAhBmE,OAAO,uEAAG,IAAI;IACpC,IAAI,OAAOnE,KAAK,KAAK,SAAS,EAAE;MAC5B,OAAQA,KAAK,GAAGH,qBAAqB,CAACC,MAAM,CAACF,GAAG,EAAEuE,OAAO,CAAC,GAAG9D,iBAAiB,CAACP,MAAM,CAACF,GAAG,EAAEuE,OAAO,CAAC;IACvG;IACA,MAAMC,aAAa,GAAGhF,eAAe,CAACiF,GAAG,CAACzE,GAAG,CAAC;IAC9C,IAAI,OAAOwE,aAAa,KAAK,SAAS,EAAE;MACpC,MAAMI,SAAS,GAAGJ,aAAa,GAAG,MAAM,GAAG,OAAO;MAClD,OAAQpE,KAAK,KAAKwE,SAAS,GAAGP,kBAAkB,CAACC,QAAQ,GAAGV,mBAAmB,CAACU,QAAQ;IAC5F;IACA,OAAO,IAAIjE,oBAAoB,CAACL,GAAG,EAAEI,KAAK,EAAEmE,OAAO,CAAC;EACxD;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOe,IAAI,CAAC,IAAI,CAAC7E,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE2D,KAAK,CAAC/D,GAAG,EAAE+D,KAAK,CAAC3D,KAAK,CAAC;EAC7D;EACAD,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG,IAAI,IAAI,CAACI,KAAK,KAAK2D,KAAK,CAAC3D,KAAK;IAChE;IACA,OAAO,KAAK;EAChB;EACAqD,mBAAmB,GAAG;IAClB,MAAMe,aAAa,GAAGhF,eAAe,CAACiF,GAAG,CAAC,IAAI,CAACzE,GAAG,CAAC;IACnD,IAAI,OAAOwE,aAAa,KAAK,SAAS,EAAE;MACpC,MAAMI,SAAS,GAAGJ,aAAa,GAAG,MAAM,GAAG,OAAO;MAClD,OAAQ,IAAI,CAACpE,KAAK,KAAKwE,SAAS,GAAGP,kBAAkB,CAACC,QAAQ,GAAGV,mBAAmB,CAACU,QAAQ;IACjG;IACA,OAAO,IAAI;EACf;EACAN,QAAQ,CAACC,OAAO,EAAE;IACd;IACA;IACA,OAAQA,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC,IAAI,IAAI,CAACI,KAAK;EACpD;EACA8D,SAAS,GAAG;IACR,OAAQ,GAAE,IAAI,CAAClE,GAAI,QAAO,IAAI,CAACI,KAAM,GAAE;EAC3C;EACA+D,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAG1C,uBAAuB,CAAC3B,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE,IAAI,CAAC;IAC7E;IACA,OAAO,IAAI,CAACmE,OAAO;EACvB;AACJ;AACA,OAAO,MAAMtC,gBAAgB,CAAC;EAC1B4B,WAAW,CAAC7D,GAAG,EAAE8E,QAAQ,EAAE;IACvB,IAAI,CAAC9E,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC8E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAChB,IAAI,GAAG,EAAE,CAAC;IACf,IAAI,CAACS,OAAO,GAAG,IAAI;EACvB;EACA,OAAOrE,MAAM,CAACF,GAAG,EAAE8E,QAAQ,EAAE;IACzB,OAAO,IAAI7C,gBAAgB,CAACjC,GAAG,EAAE8E,QAAQ,CAAC;EAC9C;EACAnB,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOe,IAAI,CAAC,IAAI,CAAC7E,GAAG,EAAE,IAAI,CAAC8E,QAAQ,EAAEf,KAAK,CAAC/D,GAAG,EAAE+D,KAAK,CAACe,QAAQ,CAAC;EACnE;EACA3E,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG,IAAI,IAAI,CAAC8E,QAAQ,KAAKf,KAAK,CAACe,QAAQ;IACtE;IACA,OAAO,KAAK;EAChB;EACArB,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,MAAMc,MAAM,GAAGd,OAAO,CAACU,QAAQ,CAAC,IAAI,CAACG,QAAQ,CAAC;IAC9C,MAAME,IAAI,GAAGf,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC;IACvC,IAAIiF,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,EAAE;MACvB,OAAOA,MAAM,CAACI,QAAQ,CAACH,IAAI,CAAC;IAChC;IACA,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAI,OAAOD,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAK,IAAI,EAAE;MAC3E,OAAOpF,cAAc,CAACyF,IAAI,CAACL,MAAM,EAAEC,IAAI,CAAC;IAC5C;IACA,OAAO,KAAK;EAChB;EACAd,SAAS,GAAG;IACR,OAAQ,GAAE,IAAI,CAAClE,GAAI,QAAO,IAAI,CAAC8E,QAAS,GAAE;EAC9C;EACAX,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,EAAE,IAAI,CAAC8E,QAAQ,CAAC;EACpC;EACAV,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAGvC,mBAAmB,CAAC9B,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAAC8E,QAAQ,CAAC;IACtE;IACA,OAAO,IAAI,CAACP,OAAO;EACvB;AACJ;AACA,OAAO,MAAMvC,mBAAmB,CAAC;EAC7B6B,WAAW,CAAC7D,GAAG,EAAE8E,QAAQ,EAAE;IACvB,IAAI,CAAC9E,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC8E,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAChB,IAAI,GAAG,EAAE,CAAC;IACf,IAAI,CAACuB,QAAQ,GAAGpD,gBAAgB,CAAC/B,MAAM,CAACF,GAAG,EAAE8E,QAAQ,CAAC;EAC1D;EACA,OAAO5E,MAAM,CAACF,GAAG,EAAE8E,QAAQ,EAAE;IACzB,OAAO,IAAI9C,mBAAmB,CAAChC,GAAG,EAAE8E,QAAQ,CAAC;EACjD;EACAnB,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAO,IAAI,CAACuB,QAAQ,CAAC1B,GAAG,CAACI,KAAK,CAACsB,QAAQ,CAAC;EAC5C;EACAlF,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACuB,QAAQ,CAAClF,MAAM,CAAC4D,KAAK,CAACsB,QAAQ,CAAC;IAC/C;IACA,OAAO,KAAK;EAChB;EACA5B,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,OAAO,CAAC,IAAI,CAACoB,QAAQ,CAACrB,QAAQ,CAACC,OAAO,CAAC;EAC3C;EACAC,SAAS,GAAG;IACR,OAAQ,GAAE,IAAI,CAAClE,GAAI,YAAW,IAAI,CAAC8E,QAAS,GAAE;EAClD;EACAX,IAAI,GAAG;IACH,OAAO,IAAI,CAACkB,QAAQ,CAAClB,IAAI,EAAE;EAC/B;EACAC,MAAM,GAAG;IACL,OAAO,IAAI,CAACiB,QAAQ;EACxB;AACJ;AACA,OAAO,MAAMxD,uBAAuB,CAAC;EACjCgC,WAAW,CAAC7D,GAAG,EAAEI,KAAK,EAAEmE,OAAO,EAAE;IAC7B,IAAI,CAACvE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACI,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC;EAClB;;EACA,OAAO5D,MAAM,CAACF,GAAG,EAAEI,KAAK,EAAkB;IAAA,IAAhBmE,OAAO,uEAAG,IAAI;IACpC,IAAI,OAAOnE,KAAK,KAAK,SAAS,EAAE;MAC5B,IAAIA,KAAK,EAAE;QACP,OAAOK,iBAAiB,CAACP,MAAM,CAACF,GAAG,EAAEuE,OAAO,CAAC;MACjD;MACA,OAAOtE,qBAAqB,CAACC,MAAM,CAACF,GAAG,EAAEuE,OAAO,CAAC;IACrD;IACA,MAAMC,aAAa,GAAGhF,eAAe,CAACiF,GAAG,CAACzE,GAAG,CAAC;IAC9C,IAAI,OAAOwE,aAAa,KAAK,SAAS,EAAE;MACpC,MAAMc,UAAU,GAAGd,aAAa,GAAG,MAAM,GAAG,OAAO;MACnD,OAAQpE,KAAK,KAAKkF,UAAU,GAAG1B,mBAAmB,CAACU,QAAQ,GAAGD,kBAAkB,CAACC,QAAQ;IAC7F;IACA,OAAO,IAAIzC,uBAAuB,CAAC7B,GAAG,EAAEI,KAAK,EAAEmE,OAAO,CAAC;EAC3D;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOe,IAAI,CAAC,IAAI,CAAC7E,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE2D,KAAK,CAAC/D,GAAG,EAAE+D,KAAK,CAAC3D,KAAK,CAAC;EAC7D;EACAD,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG,IAAI,IAAI,CAACI,KAAK,KAAK2D,KAAK,CAAC3D,KAAK;IAChE;IACA,OAAO,KAAK;EAChB;EACAqD,mBAAmB,GAAG;IAClB,MAAMe,aAAa,GAAGhF,eAAe,CAACiF,GAAG,CAAC,IAAI,CAACzE,GAAG,CAAC;IACnD,IAAI,OAAOwE,aAAa,KAAK,SAAS,EAAE;MACpC,MAAMc,UAAU,GAAGd,aAAa,GAAG,MAAM,GAAG,OAAO;MACnD,OAAQ,IAAI,CAACpE,KAAK,KAAKkF,UAAU,GAAG1B,mBAAmB,CAACU,QAAQ,GAAGD,kBAAkB,CAACC,QAAQ;IAClG;IACA,OAAO,IAAI;EACf;EACAN,QAAQ,CAACC,OAAO,EAAE;IACd;IACA;IACA,OAAQA,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC,IAAI,IAAI,CAACI,KAAK;EACpD;EACA8D,SAAS,GAAG;IACR,OAAQ,GAAE,IAAI,CAAClE,GAAI,QAAO,IAAI,CAACI,KAAM,GAAE;EAC3C;EACA+D,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAGlE,oBAAoB,CAACH,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE,IAAI,CAAC;IAC1E;IACA,OAAO,IAAI,CAACmE,OAAO;EACvB;AACJ;AACA,OAAO,MAAM9D,iBAAiB,CAAC;EAC3BoD,WAAW,CAAC7D,GAAG,EAAEuE,OAAO,EAAE;IACtB,IAAI,CAACvE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACuE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC;EAClB;;EACA,OAAO5D,MAAM,CAACF,GAAG,EAAkB;IAAA,IAAhBuE,OAAO,uEAAG,IAAI;IAC7B,MAAMC,aAAa,GAAGhF,eAAe,CAACiF,GAAG,CAACzE,GAAG,CAAC;IAC9C,IAAI,OAAOwE,aAAa,KAAK,SAAS,EAAE;MACpC,OAAQA,aAAa,GAAGZ,mBAAmB,CAACU,QAAQ,GAAGD,kBAAkB,CAACC,QAAQ;IACtF;IACA,OAAO,IAAI7D,iBAAiB,CAACT,GAAG,EAAEuE,OAAO,CAAC;EAC9C;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOY,IAAI,CAAC,IAAI,CAAC1E,GAAG,EAAE+D,KAAK,CAAC/D,GAAG,CAAC;EACpC;EACAG,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG;IAClC;IACA,OAAO,KAAK;EAChB;EACAyD,mBAAmB,GAAG;IAClB,MAAMe,aAAa,GAAGhF,eAAe,CAACiF,GAAG,CAAC,IAAI,CAACzE,GAAG,CAAC;IACnD,IAAI,OAAOwE,aAAa,KAAK,SAAS,EAAE;MACpC,OAAQA,aAAa,GAAGZ,mBAAmB,CAACU,QAAQ,GAAGD,kBAAkB,CAACC,QAAQ;IACtF;IACA,OAAO,IAAI;EACf;EACAN,QAAQ,CAACC,OAAO,EAAE;IACd,OAAQ,CAACA,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC;EACvC;EACAkE,SAAS,GAAG;IACR,OAAQ,IAAG,IAAI,CAAClE,GAAI,EAAC;EACzB;EACAmE,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAGtE,qBAAqB,CAACC,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAAC;IAC/D;IACA,OAAO,IAAI,CAACuE,OAAO;EACvB;AACJ;AACA,SAASgB,cAAc,CAACnF,KAAK,EAAEoF,QAAQ,EAAE;EACrC,IAAI,OAAOpF,KAAK,KAAK,QAAQ,EAAE;IAC3B,MAAMqF,CAAC,GAAGC,UAAU,CAACtF,KAAK,CAAC;IAC3B,IAAI,CAACuF,KAAK,CAACF,CAAC,CAAC,EAAE;MACXrF,KAAK,GAAGqF,CAAC;IACb;EACJ;EACA,IAAI,OAAOrF,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IACxD,OAAOoF,QAAQ,CAACpF,KAAK,CAAC;EAC1B;EACA,OAAOwD,mBAAmB,CAACU,QAAQ;AACvC;AACA,OAAO,MAAMlC,qBAAqB,CAAC;EAC/ByB,WAAW,CAAC7D,GAAG,EAAEI,KAAK,EAAEmE,OAAO,EAAE;IAC7B,IAAI,CAACvE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACI,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,EAAE,CAAC;EACnB;;EACA,OAAO5D,MAAM,CAACF,GAAG,EAAE4F,MAAM,EAAkB;IAAA,IAAhBrB,OAAO,uEAAG,IAAI;IACrC,OAAOgB,cAAc,CAACK,MAAM,EAAGxF,KAAK,IAAK,IAAIgC,qBAAqB,CAACpC,GAAG,EAAEI,KAAK,EAAEmE,OAAO,CAAC,CAAC;EAC5F;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOe,IAAI,CAAC,IAAI,CAAC7E,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE2D,KAAK,CAAC/D,GAAG,EAAE+D,KAAK,CAAC3D,KAAK,CAAC;EAC7D;EACAD,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG,IAAI,IAAI,CAACI,KAAK,KAAK2D,KAAK,CAAC3D,KAAK;IAChE;IACA,OAAO,KAAK;EAChB;EACAqD,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,IAAI,OAAO,IAAI,CAAC7D,KAAK,KAAK,QAAQ,EAAE;MAChC,OAAO,KAAK;IAChB;IACA,OAAQsF,UAAU,CAACzB,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC,CAAC,GAAG,IAAI,CAACI,KAAK;EAC/D;EACA8D,SAAS,GAAG;IACR,OAAQ,GAAE,IAAI,CAAClE,GAAI,MAAK,IAAI,CAACI,KAAM,EAAC;EACxC;EACA+D,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAGlC,2BAA2B,CAACnC,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE,IAAI,CAAC;IACjF;IACA,OAAO,IAAI,CAACmE,OAAO;EACvB;AACJ;AACA,OAAO,MAAMpC,2BAA2B,CAAC;EACrC0B,WAAW,CAAC7D,GAAG,EAAEI,KAAK,EAAEmE,OAAO,EAAE;IAC7B,IAAI,CAACvE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACI,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,EAAE,CAAC;EACnB;;EACA,OAAO5D,MAAM,CAACF,GAAG,EAAE4F,MAAM,EAAkB;IAAA,IAAhBrB,OAAO,uEAAG,IAAI;IACrC,OAAOgB,cAAc,CAACK,MAAM,EAAGxF,KAAK,IAAK,IAAI+B,2BAA2B,CAACnC,GAAG,EAAEI,KAAK,EAAEmE,OAAO,CAAC,CAAC;EAClG;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOe,IAAI,CAAC,IAAI,CAAC7E,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE2D,KAAK,CAAC/D,GAAG,EAAE+D,KAAK,CAAC3D,KAAK,CAAC;EAC7D;EACAD,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG,IAAI,IAAI,CAACI,KAAK,KAAK2D,KAAK,CAAC3D,KAAK;IAChE;IACA,OAAO,KAAK;EAChB;EACAqD,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,IAAI,OAAO,IAAI,CAAC7D,KAAK,KAAK,QAAQ,EAAE;MAChC,OAAO,KAAK;IAChB;IACA,OAAQsF,UAAU,CAACzB,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC,CAAC,IAAI,IAAI,CAACI,KAAK;EAChE;EACA8D,SAAS,GAAG;IACR,OAAQ,GAAE,IAAI,CAAClE,GAAI,OAAM,IAAI,CAACI,KAAM,EAAC;EACzC;EACA+D,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAGjC,qBAAqB,CAACpC,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE,IAAI,CAAC;IAC3E;IACA,OAAO,IAAI,CAACmE,OAAO;EACvB;AACJ;AACA,OAAO,MAAMjC,qBAAqB,CAAC;EAC/BuB,WAAW,CAAC7D,GAAG,EAAEI,KAAK,EAAEmE,OAAO,EAAE;IAC7B,IAAI,CAACvE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACI,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,EAAE,CAAC;EACnB;;EACA,OAAO5D,MAAM,CAACF,GAAG,EAAE4F,MAAM,EAAkB;IAAA,IAAhBrB,OAAO,uEAAG,IAAI;IACrC,OAAOgB,cAAc,CAACK,MAAM,EAAGxF,KAAK,IAAK,IAAIkC,qBAAqB,CAACtC,GAAG,EAAEI,KAAK,EAAEmE,OAAO,CAAC,CAAC;EAC5F;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOe,IAAI,CAAC,IAAI,CAAC7E,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE2D,KAAK,CAAC/D,GAAG,EAAE+D,KAAK,CAAC3D,KAAK,CAAC;EAC7D;EACAD,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG,IAAI,IAAI,CAACI,KAAK,KAAK2D,KAAK,CAAC3D,KAAK;IAChE;IACA,OAAO,KAAK;EAChB;EACAqD,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,IAAI,OAAO,IAAI,CAAC7D,KAAK,KAAK,QAAQ,EAAE;MAChC,OAAO,KAAK;IAChB;IACA,OAAQsF,UAAU,CAACzB,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC,CAAC,GAAG,IAAI,CAACI,KAAK;EAC/D;EACA8D,SAAS,GAAG;IACR,OAAQ,GAAE,IAAI,CAAClE,GAAI,MAAK,IAAI,CAACI,KAAM,EAAC;EACxC;EACA+D,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAGpC,2BAA2B,CAACjC,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE,IAAI,CAAC;IACjF;IACA,OAAO,IAAI,CAACmE,OAAO;EACvB;AACJ;AACA,OAAO,MAAMlC,2BAA2B,CAAC;EACrCwB,WAAW,CAAC7D,GAAG,EAAEI,KAAK,EAAEmE,OAAO,EAAE;IAC7B,IAAI,CAACvE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACI,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACmE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,EAAE,CAAC;EACnB;;EACA,OAAO5D,MAAM,CAACF,GAAG,EAAE4F,MAAM,EAAkB;IAAA,IAAhBrB,OAAO,uEAAG,IAAI;IACrC,OAAOgB,cAAc,CAACK,MAAM,EAAGxF,KAAK,IAAK,IAAIiC,2BAA2B,CAACrC,GAAG,EAAEI,KAAK,EAAEmE,OAAO,CAAC,CAAC;EAClG;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAOe,IAAI,CAAC,IAAI,CAAC7E,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE2D,KAAK,CAAC/D,GAAG,EAAE+D,KAAK,CAAC3D,KAAK,CAAC;EAC7D;EACAD,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAQ,IAAI,CAAC9D,GAAG,KAAK+D,KAAK,CAAC/D,GAAG,IAAI,IAAI,CAACI,KAAK,KAAK2D,KAAK,CAAC3D,KAAK;IAChE;IACA,OAAO,KAAK;EAChB;EACAqD,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,IAAI,OAAO,IAAI,CAAC7D,KAAK,KAAK,QAAQ,EAAE;MAChC,OAAO,KAAK;IAChB;IACA,OAAQsF,UAAU,CAACzB,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC,CAAC,IAAI,IAAI,CAACI,KAAK;EAChE;EACA8D,SAAS,GAAG;IACR,OAAQ,GAAE,IAAI,CAAClE,GAAI,OAAM,IAAI,CAACI,KAAM,EAAC;EACzC;EACA+D,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAGnC,qBAAqB,CAAClC,MAAM,CAAC,IAAI,CAACF,GAAG,EAAE,IAAI,CAACI,KAAK,EAAE,IAAI,CAAC;IAC3E;IACA,OAAO,IAAI,CAACmE,OAAO;EACvB;AACJ;AACA,OAAO,MAAMhE,mBAAmB,CAAC;EAC7BsD,WAAW,CAAC7D,GAAG,EAAE6F,MAAM,EAAE;IACrB,IAAI,CAAC7F,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC6F,MAAM,GAAGA,MAAM;IACpB,IAAI,CAAC/B,IAAI,GAAG,CAAC,CAAC;IACd,IAAI,CAACS,OAAO,GAAG,IAAI;IACnB;EACJ;;EACA,OAAOrE,MAAM,CAACF,GAAG,EAAE6F,MAAM,EAAE;IACvB,OAAO,IAAItF,mBAAmB,CAACP,GAAG,EAAE6F,MAAM,CAAC;EAC/C;EACAlC,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,IAAI,IAAI,CAAC9D,GAAG,GAAG+D,KAAK,CAAC/D,GAAG,EAAE;MACtB,OAAO,CAAC,CAAC;IACb;IACA,IAAI,IAAI,CAACA,GAAG,GAAG+D,KAAK,CAAC/D,GAAG,EAAE;MACtB,OAAO,CAAC;IACZ;IACA,MAAM8F,UAAU,GAAG,IAAI,CAACD,MAAM,GAAG,IAAI,CAACA,MAAM,CAACd,MAAM,GAAG,EAAE;IACxD,MAAMgB,WAAW,GAAGhC,KAAK,CAAC8B,MAAM,GAAG9B,KAAK,CAAC8B,MAAM,CAACd,MAAM,GAAG,EAAE;IAC3D,IAAIe,UAAU,GAAGC,WAAW,EAAE;MAC1B,OAAO,CAAC,CAAC;IACb;IACA,IAAID,UAAU,GAAGC,WAAW,EAAE;MAC1B,OAAO,CAAC;IACZ;IACA,OAAO,CAAC;EACZ;EACA5F,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,MAAMgC,UAAU,GAAG,IAAI,CAACD,MAAM,GAAG,IAAI,CAACA,MAAM,CAACd,MAAM,GAAG,EAAE;MACxD,MAAMgB,WAAW,GAAGhC,KAAK,CAAC8B,MAAM,GAAG9B,KAAK,CAAC8B,MAAM,CAACd,MAAM,GAAG,EAAE;MAC3D,OAAQ,IAAI,CAAC/E,GAAG,KAAK+D,KAAK,CAAC/D,GAAG,IAAI8F,UAAU,KAAKC,WAAW;IAChE;IACA,OAAO,KAAK;EAChB;EACAtC,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,MAAM7D,KAAK,GAAG6D,OAAO,CAACU,QAAQ,CAAC,IAAI,CAAC3E,GAAG,CAAC;IACxC,OAAO,IAAI,CAAC6F,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC3D,IAAI,CAAC9B,KAAK,CAAC,GAAG,KAAK;EACxD;EACA8D,SAAS,GAAG;IACR,MAAM9D,KAAK,GAAG,IAAI,CAACyF,MAAM,GAClB,IAAG,IAAI,CAACA,MAAM,CAACd,MAAO,IAAG,IAAI,CAACc,MAAM,CAACG,UAAU,GAAG,GAAG,GAAG,EAAG,EAAC,GAC7D,WAAW;IACjB,OAAQ,GAAE,IAAI,CAAChG,GAAI,OAAMI,KAAM,EAAC;EACpC;EACA+D,IAAI,GAAG;IACH,OAAO,CAAC,IAAI,CAACnE,GAAG,CAAC;EACrB;EACAoE,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,IAAI,CAACA,OAAO,GAAG0B,sBAAsB,CAAC/F,MAAM,CAAC,IAAI,CAAC;IACtD;IACA,OAAO,IAAI,CAACqE,OAAO;EACvB;AACJ;AACA,OAAO,MAAM0B,sBAAsB,CAAC;EAChCpC,WAAW,CAACqC,OAAO,EAAE;IACjB,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACpC,IAAI,GAAG,CAAC,CAAC;IACd;EACJ;;EACA,OAAO5D,MAAM,CAACiG,MAAM,EAAE;IAClB,OAAO,IAAIF,sBAAsB,CAACE,MAAM,CAAC;EAC7C;EACAxC,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,OAAO,IAAI,CAACoC,OAAO,CAACvC,GAAG,CAACI,KAAK,CAACmC,OAAO,CAAC;EAC1C;EACA/F,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACoC,OAAO,CAAC/F,MAAM,CAAC4D,KAAK,CAACmC,OAAO,CAAC;IAC7C;IACA,OAAO,KAAK;EAChB;EACAzC,mBAAmB,GAAG;IAClB,OAAO,IAAI;EACf;EACAO,QAAQ,CAACC,OAAO,EAAE;IACd,OAAO,CAAC,IAAI,CAACiC,OAAO,CAAClC,QAAQ,CAACC,OAAO,CAAC;EAC1C;EACAC,SAAS,GAAG;IACR,MAAM,IAAIvB,KAAK,CAAC,yBAAyB,CAAC;EAC9C;EACAwB,IAAI,GAAG;IACH,OAAO,IAAI,CAAC+B,OAAO,CAAC/B,IAAI,EAAE;EAC9B;EACAC,MAAM,GAAG;IACL,OAAO,IAAI,CAAC8B,OAAO;EACvB;AACJ;AACA;AACA;AACA;AACA,SAASE,yBAAyB,CAACC,GAAG,EAAE;EACpC;EACA,IAAIC,MAAM,GAAG,IAAI;EACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,GAAG,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IAC5C,MAAMG,OAAO,GAAGL,GAAG,CAACE,CAAC,CAAC,CAAC9C,mBAAmB,EAAE;IAC5C,IAAI4C,GAAG,CAACE,CAAC,CAAC,KAAKG,OAAO,EAAE;MACpB;MACA;MACA,IAAIJ,MAAM,KAAK,IAAI,EAAE;QACjBA,MAAM,GAAG,EAAE;QACX,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,CAAC,EAAEI,CAAC,EAAE,EAAE;UACxBL,MAAM,CAACK,CAAC,CAAC,GAAGN,GAAG,CAACM,CAAC,CAAC;QACtB;MACJ;IACJ;IACA,IAAIL,MAAM,KAAK,IAAI,EAAE;MACjBA,MAAM,CAACC,CAAC,CAAC,GAAGG,OAAO;IACvB;EACJ;EACA,IAAIJ,MAAM,KAAK,IAAI,EAAE;IACjB,OAAOD,GAAG;EACd;EACA,OAAOC,MAAM;AACjB;AACA,MAAM1F,iBAAiB,CAAC;EACpBiD,WAAW,CAAClD,IAAI,EAAE4D,OAAO,EAAE;IACvB,IAAI,CAAC5D,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC4D,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC;EAClB;;EACA,OAAO5D,MAAM,CAAC0G,KAAK,EAAErC,OAAO,EAAE;IAC1B,OAAO3D,iBAAiB,CAACiG,aAAa,CAACD,KAAK,EAAErC,OAAO,CAAC;EAC1D;EACAZ,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,IAAI,IAAI,CAACnD,IAAI,CAAC8F,MAAM,GAAG1C,KAAK,CAACpD,IAAI,CAAC8F,MAAM,EAAE;MACtC,OAAO,CAAC,CAAC;IACb;IACA,IAAI,IAAI,CAAC9F,IAAI,CAAC8F,MAAM,GAAG1C,KAAK,CAACpD,IAAI,CAAC8F,MAAM,EAAE;MACtC,OAAO,CAAC;IACZ;IACA,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC7F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAClD,MAAMO,CAAC,GAAGnD,GAAG,CAAC,IAAI,CAAChD,IAAI,CAAC4F,CAAC,CAAC,EAAExC,KAAK,CAACpD,IAAI,CAAC4F,CAAC,CAAC,CAAC;MAC1C,IAAIO,CAAC,KAAK,CAAC,EAAE;QACT,OAAOA,CAAC;MACZ;IACJ;IACA,OAAO,CAAC;EACZ;EACA3G,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,IAAI,IAAI,CAACnD,IAAI,CAAC8F,MAAM,KAAK1C,KAAK,CAACpD,IAAI,CAAC8F,MAAM,EAAE;QACxC,OAAO,KAAK;MAChB;MACA,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC7F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAClD,IAAI,CAAC,IAAI,CAAC5F,IAAI,CAAC4F,CAAC,CAAC,CAACpG,MAAM,CAAC4D,KAAK,CAACpD,IAAI,CAAC4F,CAAC,CAAC,CAAC,EAAE;UACrC,OAAO,KAAK;QAChB;MACJ;MACA,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA9C,mBAAmB,GAAG;IAClB,MAAMsD,OAAO,GAAGX,yBAAyB,CAAC,IAAI,CAACzF,IAAI,CAAC;IACpD,IAAIoG,OAAO,KAAK,IAAI,CAACpG,IAAI,EAAE;MACvB;MACA,OAAO,IAAI;IACf;IACA,OAAOC,iBAAiB,CAACV,MAAM,CAAC6G,OAAO,EAAE,IAAI,CAACxC,OAAO,CAAC;EAC1D;EACAP,QAAQ,CAACC,OAAO,EAAE;IACd,KAAK,IAAIsC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC7F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAClD,IAAI,CAAC,IAAI,CAAC5F,IAAI,CAAC4F,CAAC,CAAC,CAACvC,QAAQ,CAACC,OAAO,CAAC,EAAE;QACjC,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAO4C,aAAa,CAACR,GAAG,EAAE9B,OAAO,EAAE;IAC/B,MAAM5D,IAAI,GAAG,EAAE;IACf,IAAIqG,OAAO,GAAG,KAAK;IACnB,KAAK,MAAM5D,CAAC,IAAIiD,GAAG,EAAE;MACjB,IAAI,CAACjD,CAAC,EAAE;QACJ;MACJ;MACA,IAAIA,CAAC,CAACU,IAAI,KAAK,CAAC,CAAC,+BAA+B;QAC5C;QACAkD,OAAO,GAAG,IAAI;QACd;MACJ;MACA,IAAI5D,CAAC,CAACU,IAAI,KAAK,CAAC,CAAC,gCAAgC;QAC7C;QACA,OAAOF,mBAAmB,CAACU,QAAQ;MACvC;MACA,IAAIlB,CAAC,CAACU,IAAI,KAAK,CAAC,CAAC,8BAA8B;QAC3CnD,IAAI,CAACsG,IAAI,CAAC,GAAG7D,CAAC,CAACzC,IAAI,CAAC;QACpB;MACJ;MACAA,IAAI,CAACsG,IAAI,CAAC7D,CAAC,CAAC;IAChB;IACA,IAAIzC,IAAI,CAAC8F,MAAM,KAAK,CAAC,IAAIO,OAAO,EAAE;MAC9B,OAAO3C,kBAAkB,CAACC,QAAQ;IACtC;IACA,IAAI3D,IAAI,CAAC8F,MAAM,KAAK,CAAC,EAAE;MACnB,OAAOvF,SAAS;IACpB;IACA,IAAIP,IAAI,CAAC8F,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO9F,IAAI,CAAC,CAAC,CAAC;IAClB;IACAA,IAAI,CAACuG,IAAI,CAACvD,GAAG,CAAC;IACd;IACA,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,EAAE,EAAE;MAClC,IAAI5F,IAAI,CAAC4F,CAAC,GAAG,CAAC,CAAC,CAACpG,MAAM,CAACQ,IAAI,CAAC4F,CAAC,CAAC,CAAC,EAAE;QAC7B5F,IAAI,CAACwG,MAAM,CAACZ,CAAC,EAAE,CAAC,CAAC;QACjBA,CAAC,EAAE;MACP;IACJ;IACA,IAAI5F,IAAI,CAAC8F,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO9F,IAAI,CAAC,CAAC,CAAC;IAClB;IACA;IACA;IACA,OAAOA,IAAI,CAAC8F,MAAM,GAAG,CAAC,EAAE;MACpB,MAAMW,WAAW,GAAGzG,IAAI,CAACA,IAAI,CAAC8F,MAAM,GAAG,CAAC,CAAC;MACzC,IAAIW,WAAW,CAACtD,IAAI,KAAK,CAAC,CAAC,6BAA6B;QACpD;MACJ;MACA;MACAnD,IAAI,CAAC0G,GAAG,EAAE;MACV;MACA,MAAMC,mBAAmB,GAAG3G,IAAI,CAAC0G,GAAG,EAAE;MACtC,MAAME,UAAU,GAAI5G,IAAI,CAAC8F,MAAM,KAAK,CAAE;MACtC;MACA,MAAMe,aAAa,GAAG1G,gBAAgB,CAACZ,MAAM,CAACkH,WAAW,CAACzG,IAAI,CAACW,GAAG,CAACmG,EAAE,IAAI7G,iBAAiB,CAACV,MAAM,CAAC,CAACuH,EAAE,EAAEH,mBAAmB,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,EAAEC,UAAU,CAAC;MACtJ,IAAIC,aAAa,EAAE;QACf7G,IAAI,CAACsG,IAAI,CAACO,aAAa,CAAC;QACxB7G,IAAI,CAACuG,IAAI,CAACvD,GAAG,CAAC;MAClB;IACJ;IACA,IAAIhD,IAAI,CAAC8F,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO9F,IAAI,CAAC,CAAC,CAAC;IAClB;IACA,OAAO,IAAIC,iBAAiB,CAACD,IAAI,EAAE4D,OAAO,CAAC;EAC/C;EACAL,SAAS,GAAG;IACR,OAAO,IAAI,CAACvD,IAAI,CAACW,GAAG,CAAC8B,CAAC,IAAIA,CAAC,CAACc,SAAS,EAAE,CAAC,CAACwD,IAAI,CAAC,MAAM,CAAC;EACzD;EACAvD,IAAI,GAAG;IACH,MAAMwD,MAAM,GAAG,EAAE;IACjB,KAAK,MAAMhH,IAAI,IAAI,IAAI,CAACA,IAAI,EAAE;MAC1BgH,MAAM,CAACV,IAAI,CAAC,GAAGtG,IAAI,CAACwD,IAAI,EAAE,CAAC;IAC/B;IACA,OAAOwD,MAAM;EACjB;EACAvD,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,MAAMoD,MAAM,GAAG,EAAE;MACjB,KAAK,MAAMhH,IAAI,IAAI,IAAI,CAACA,IAAI,EAAE;QAC1BgH,MAAM,CAACV,IAAI,CAACtG,IAAI,CAACyD,MAAM,EAAE,CAAC;MAC9B;MACA,IAAI,CAACG,OAAO,GAAGzD,gBAAgB,CAACZ,MAAM,CAACyH,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC;IAC9D;IACA,OAAO,IAAI,CAACpD,OAAO;EACvB;AACJ;AACA,MAAMzD,gBAAgB,CAAC;EACnB+C,WAAW,CAAClD,IAAI,EAAE4D,OAAO,EAAE;IACvB,IAAI,CAAC5D,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC4D,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACT,IAAI,GAAG,CAAC,CAAC;EAClB;;EACA,OAAO5D,MAAM,CAAC0G,KAAK,EAAErC,OAAO,EAAEqD,mBAAmB,EAAE;IAC/C,OAAO9G,gBAAgB,CAAC+F,aAAa,CAACD,KAAK,EAAErC,OAAO,EAAEqD,mBAAmB,CAAC;EAC9E;EACAjE,GAAG,CAACI,KAAK,EAAE;IACP,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,OAAO,IAAI,CAACA,IAAI,GAAGC,KAAK,CAACD,IAAI;IACjC;IACA,IAAI,IAAI,CAACnD,IAAI,CAAC8F,MAAM,GAAG1C,KAAK,CAACpD,IAAI,CAAC8F,MAAM,EAAE;MACtC,OAAO,CAAC,CAAC;IACb;IACA,IAAI,IAAI,CAAC9F,IAAI,CAAC8F,MAAM,GAAG1C,KAAK,CAACpD,IAAI,CAAC8F,MAAM,EAAE;MACtC,OAAO,CAAC;IACZ;IACA,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC7F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAClD,MAAMO,CAAC,GAAGnD,GAAG,CAAC,IAAI,CAAChD,IAAI,CAAC4F,CAAC,CAAC,EAAExC,KAAK,CAACpD,IAAI,CAAC4F,CAAC,CAAC,CAAC;MAC1C,IAAIO,CAAC,KAAK,CAAC,EAAE;QACT,OAAOA,CAAC;MACZ;IACJ;IACA,OAAO,CAAC;EACZ;EACA3G,MAAM,CAAC4D,KAAK,EAAE;IACV,IAAIA,KAAK,CAACD,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;MAC1B,IAAI,IAAI,CAACnD,IAAI,CAAC8F,MAAM,KAAK1C,KAAK,CAACpD,IAAI,CAAC8F,MAAM,EAAE;QACxC,OAAO,KAAK;MAChB;MACA,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC7F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAClD,IAAI,CAAC,IAAI,CAAC5F,IAAI,CAAC4F,CAAC,CAAC,CAACpG,MAAM,CAAC4D,KAAK,CAACpD,IAAI,CAAC4F,CAAC,CAAC,CAAC,EAAE;UACrC,OAAO,KAAK;QAChB;MACJ;MACA,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA9C,mBAAmB,GAAG;IAClB,MAAMsD,OAAO,GAAGX,yBAAyB,CAAC,IAAI,CAACzF,IAAI,CAAC;IACpD,IAAIoG,OAAO,KAAK,IAAI,CAACpG,IAAI,EAAE;MACvB;MACA,OAAO,IAAI;IACf;IACA,OAAOG,gBAAgB,CAACZ,MAAM,CAAC6G,OAAO,EAAE,IAAI,CAACxC,OAAO,EAAE,KAAK,CAAC;EAChE;EACAP,QAAQ,CAACC,OAAO,EAAE;IACd,KAAK,IAAIsC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC7F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAClD,IAAI,IAAI,CAAC5F,IAAI,CAAC4F,CAAC,CAAC,CAACvC,QAAQ,CAACC,OAAO,CAAC,EAAE;QAChC,OAAO,IAAI;MACf;IACJ;IACA,OAAO,KAAK;EAChB;EACA,OAAO4C,aAAa,CAACR,GAAG,EAAE9B,OAAO,EAAEqD,mBAAmB,EAAE;IACpD,IAAIjH,IAAI,GAAG,EAAE;IACb,IAAIkH,QAAQ,GAAG,KAAK;IACpB,IAAIxB,GAAG,EAAE;MACL,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,GAAG,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAC5C,MAAMnD,CAAC,GAAGiD,GAAG,CAACE,CAAC,CAAC;QAChB,IAAI,CAACnD,CAAC,EAAE;UACJ;QACJ;QACA,IAAIA,CAAC,CAACU,IAAI,KAAK,CAAC,CAAC,gCAAgC;UAC7C;UACA+D,QAAQ,GAAG,IAAI;UACf;QACJ;QACA,IAAIzE,CAAC,CAACU,IAAI,KAAK,CAAC,CAAC,+BAA+B;UAC5C;UACA,OAAOO,kBAAkB,CAACC,QAAQ;QACtC;QACA,IAAIlB,CAAC,CAACU,IAAI,KAAK,CAAC,CAAC,6BAA6B;UAC1CnD,IAAI,GAAGA,IAAI,CAACmH,MAAM,CAAC1E,CAAC,CAACzC,IAAI,CAAC;UAC1B;QACJ;QACAA,IAAI,CAACsG,IAAI,CAAC7D,CAAC,CAAC;MAChB;MACA,IAAIzC,IAAI,CAAC8F,MAAM,KAAK,CAAC,IAAIoB,QAAQ,EAAE;QAC/B,OAAOjE,mBAAmB,CAACU,QAAQ;MACvC;MACA3D,IAAI,CAACuG,IAAI,CAACvD,GAAG,CAAC;IAClB;IACA,IAAIhD,IAAI,CAAC8F,MAAM,KAAK,CAAC,EAAE;MACnB,OAAOvF,SAAS;IACpB;IACA,IAAIP,IAAI,CAAC8F,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO9F,IAAI,CAAC,CAAC,CAAC;IAClB;IACA;IACA,KAAK,IAAI4F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,EAAE,EAAE;MAClC,IAAI5F,IAAI,CAAC4F,CAAC,GAAG,CAAC,CAAC,CAACpG,MAAM,CAACQ,IAAI,CAAC4F,CAAC,CAAC,CAAC,EAAE;QAC7B5F,IAAI,CAACwG,MAAM,CAACZ,CAAC,EAAE,CAAC,CAAC;QACjBA,CAAC,EAAE;MACP;IACJ;IACA,IAAI5F,IAAI,CAAC8F,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO9F,IAAI,CAAC,CAAC,CAAC;IAClB;IACA;IACA,IAAIiH,mBAAmB,EAAE;MACrB,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,EAAE,EAAE;QAClC,KAAK,IAAII,CAAC,GAAGJ,CAAC,GAAG,CAAC,EAAEI,CAAC,GAAGhG,IAAI,CAAC8F,MAAM,EAAEE,CAAC,EAAE,EAAE;UACtC,IAAIoB,OAAO,CAACpH,IAAI,CAAC4F,CAAC,CAAC,EAAE5F,IAAI,CAACgG,CAAC,CAAC,CAAC,EAAE;YAC3BhG,IAAI,CAACwG,MAAM,CAACR,CAAC,EAAE,CAAC,CAAC;YACjBA,CAAC,EAAE;UACP;QACJ;MACJ;MACA,IAAIhG,IAAI,CAAC8F,MAAM,KAAK,CAAC,EAAE;QACnB,OAAO9F,IAAI,CAAC,CAAC,CAAC;MAClB;IACJ;IACA,OAAO,IAAIG,gBAAgB,CAACH,IAAI,EAAE4D,OAAO,CAAC;EAC9C;EACAL,SAAS,GAAG;IACR,OAAO,IAAI,CAACvD,IAAI,CAACW,GAAG,CAAC8B,CAAC,IAAIA,CAAC,CAACc,SAAS,EAAE,CAAC,CAACwD,IAAI,CAAC,MAAM,CAAC;EACzD;EACAvD,IAAI,GAAG;IACH,MAAMwD,MAAM,GAAG,EAAE;IACjB,KAAK,MAAMhH,IAAI,IAAI,IAAI,CAACA,IAAI,EAAE;MAC1BgH,MAAM,CAACV,IAAI,CAAC,GAAGtG,IAAI,CAACwD,IAAI,EAAE,CAAC;IAC/B;IACA,OAAOwD,MAAM;EACjB;EACAvD,MAAM,GAAG;IACL,IAAI,CAAC,IAAI,CAACG,OAAO,EAAE;MACf,MAAMoD,MAAM,GAAG,EAAE;MACjB,KAAK,MAAMhH,IAAI,IAAI,IAAI,CAACA,IAAI,EAAE;QAC1BgH,MAAM,CAACV,IAAI,CAACtG,IAAI,CAACyD,MAAM,EAAE,CAAC;MAC9B;MACA;MACA;MACA,OAAOuD,MAAM,CAAClB,MAAM,GAAG,CAAC,EAAE;QACtB,MAAMuB,IAAI,GAAGL,MAAM,CAACM,KAAK,EAAE;QAC3B,MAAMC,KAAK,GAAGP,MAAM,CAACM,KAAK,EAAE;QAC5B,MAAME,GAAG,GAAG,EAAE;QACd,KAAK,MAAMC,IAAI,IAAIC,YAAY,CAACL,IAAI,CAAC,EAAE;UACnC,KAAK,MAAMM,KAAK,IAAID,YAAY,CAACH,KAAK,CAAC,EAAE;YACrCC,GAAG,CAAClB,IAAI,CAACrG,iBAAiB,CAACV,MAAM,CAAC,CAACkI,IAAI,EAAEE,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;UAC3D;QACJ;QACA,MAAMf,UAAU,GAAII,MAAM,CAAClB,MAAM,KAAK,CAAE;QACxCkB,MAAM,CAACY,OAAO,CAACzH,gBAAgB,CAACZ,MAAM,CAACiI,GAAG,EAAE,IAAI,EAAEZ,UAAU,CAAC,CAAC;MAClE;MACA,IAAI,CAAChD,OAAO,GAAGoD,MAAM,CAAC,CAAC,CAAC;IAC5B;IACA,OAAO,IAAI,CAACpD,OAAO;EACvB;AACJ;AACA,OAAO,MAAMiE,aAAa,SAASvI,qBAAqB,CAAC;EACrD4D,WAAW,CAAC7D,GAAG,EAAEyI,YAAY,EAAEC,UAAU,EAAE;IACvC,KAAK,CAAC1I,GAAG,EAAE,IAAI,CAAC;IAChB,IAAI,CAAC2I,aAAa,GAAGF,YAAY;IACjC;IACA,IAAI,OAAOC,UAAU,KAAK,QAAQ,EAAE;MAChCF,aAAa,CAACI,KAAK,CAAC3B,IAAI,CAACrH,MAAM,CAACiJ,MAAM,CAACjJ,MAAM,CAACiJ,MAAM,CAAC,CAAC,CAAC,EAAEH,UAAU,CAAC,EAAE;QAAE1I;MAAI,CAAC,CAAC,CAAC;IACnF,CAAC,MACI,IAAI0I,UAAU,KAAK,IAAI,EAAE;MAC1BF,aAAa,CAACI,KAAK,CAAC3B,IAAI,CAAC;QAAEjH,GAAG;QAAE8I,WAAW,EAAEJ,UAAU;QAAE5E,IAAI,EAAE2E,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAKvH,SAAS,GAAG,OAAOuH,YAAY,GAAGvH;MAAU,CAAC,CAAC;IAC3J;EACJ;EACA,OAAOiH,GAAG,GAAG;IACT,OAAOK,aAAa,CAACI,KAAK,CAACG,MAAM,EAAE;EACvC;EACAC,MAAM,CAACC,MAAM,EAAE;IACX,OAAOA,MAAM,CAACC,SAAS,CAAC,IAAI,CAAClJ,GAAG,EAAE,IAAI,CAAC2I,aAAa,CAAC;EACzD;EACAhE,QAAQ,CAACsE,MAAM,EAAE;IACb,OAAOA,MAAM,CAACE,kBAAkB,CAAC,IAAI,CAACnJ,GAAG,CAAC;EAC9C;EACAoJ,SAAS,GAAG;IACR,OAAO,IAAI,CAAChF,MAAM,EAAE;EACxB;EACAiF,SAAS,CAACjJ,KAAK,EAAE;IACb,OAAOC,oBAAoB,CAACH,MAAM,CAAC,IAAI,CAACF,GAAG,EAAEI,KAAK,CAAC;EACvD;AACJ;AACAoI,aAAa,CAACI,KAAK,GAAG,EAAE;AACxB,OAAO,MAAMU,kBAAkB,GAAG/J,eAAe,CAAC,mBAAmB,CAAC;AACtE,OAAO,MAAMgK,sBAAsB,GAAG,YAAY;AAClD,SAAS7E,IAAI,CAAC8E,IAAI,EAAEC,IAAI,EAAE;EACtB,IAAID,IAAI,GAAGC,IAAI,EAAE;IACb,OAAO,CAAC,CAAC;EACb;EACA,IAAID,IAAI,GAAGC,IAAI,EAAE;IACb,OAAO,CAAC;EACZ;EACA,OAAO,CAAC;AACZ;AACA,SAAS5E,IAAI,CAAC2E,IAAI,EAAEE,MAAM,EAAED,IAAI,EAAEE,MAAM,EAAE;EACtC,IAAIH,IAAI,GAAGC,IAAI,EAAE;IACb,OAAO,CAAC,CAAC;EACb;EACA,IAAID,IAAI,GAAGC,IAAI,EAAE;IACb,OAAO,CAAC;EACZ;EACA,IAAIC,MAAM,GAAGC,MAAM,EAAE;IACjB,OAAO,CAAC,CAAC;EACb;EACA,IAAID,MAAM,GAAGC,MAAM,EAAE;IACjB,OAAO,CAAC;EACZ;EACA,OAAO,CAAC;AACZ;AACA;AACA;AACA;AACA,OAAO,SAAS5B,OAAO,CAACxG,CAAC,EAAEqI,CAAC,EAAE;EAC1B,IAAIA,CAAC,CAAC9F,IAAI,KAAK,CAAC,CAAC,gCAAiCvC,CAAC,CAACuC,IAAI,KAAK,CAAC,CAAC,+BAA+BvC,CAAC,CAACuC,IAAI,KAAK,CAAC,CAAC,4BAA6B,EAAE;IACtI;IACA,KAAK,MAAM+F,KAAK,IAAID,CAAC,CAACjJ,IAAI,EAAE;MACxB,IAAIY,CAAC,CAACpB,MAAM,CAAC0J,KAAK,CAAC,EAAE;QACjB,OAAO,IAAI;MACf;IACJ;EACJ;EACA,MAAMC,IAAI,GAAGvI,CAAC,CAAC6C,MAAM,EAAE;EACvB,MAAMzD,IAAI,GAAG0H,YAAY,CAACyB,IAAI,CAAC,CAAChC,MAAM,CAACO,YAAY,CAACuB,CAAC,CAAC,CAAC;EACvDjJ,IAAI,CAACuG,IAAI,CAACvD,GAAG,CAAC;EACd,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5F,IAAI,CAAC8F,MAAM,EAAEF,CAAC,EAAE,EAAE;IAClC,MAAMjD,CAAC,GAAG3C,IAAI,CAAC4F,CAAC,CAAC;IACjB,MAAMwD,IAAI,GAAGzG,CAAC,CAACc,MAAM,EAAE;IACvB,KAAK,IAAIuC,CAAC,GAAGJ,CAAC,GAAG,CAAC,EAAEI,CAAC,GAAGhG,IAAI,CAAC8F,MAAM,EAAEE,CAAC,EAAE,EAAE;MACtC,MAAMpD,CAAC,GAAG5C,IAAI,CAACgG,CAAC,CAAC;MACjB,IAAIoD,IAAI,CAAC5J,MAAM,CAACoD,CAAC,CAAC,EAAE;QAChB,OAAO,IAAI;MACf;IACJ;EACJ;EACA,OAAO,KAAK;AAChB;AACA,SAAS8E,YAAY,CAAC2B,IAAI,EAAE;EACxB,IAAIA,IAAI,CAAClG,IAAI,KAAK,CAAC,CAAC,6BAA6B;IAC7C,OAAOkG,IAAI,CAACrJ,IAAI;EACpB;EACA,OAAO,CAACqJ,IAAI,CAAC;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}