{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IModelService } from './model.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from './semanticTokensDto.js';\nimport { Range } from '../core/range.js';\nimport { ILanguageFeaturesService } from './languageFeatures.js';\nexport function isSemanticTokens(v) {\n  return v && !!v.data;\n}\nexport function isSemanticTokensEdits(v) {\n  return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n  constructor(provider, tokens, error) {\n    this.provider = provider;\n    this.tokens = tokens;\n    this.error = error;\n  }\n}\nexport function hasDocumentSemanticTokensProvider(registry, model) {\n  return registry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(registry, model) {\n  const groups = registry.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\nexport function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getDocumentSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      let result;\n      let error = null;\n      try {\n        result = yield provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);\n      } catch (err) {\n        error = err;\n        result = null;\n      }\n      if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {\n        result = null;\n      }\n      return new DocumentSemanticTokensResult(provider, result, error);\n    })));\n    // Try to return the first result with actual tokens or\n    // the first result which threw an error (!!)\n    for (const result of results) {\n      if (result.error) {\n        throw result.error;\n      }\n      if (result.tokens) {\n        return result;\n      }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n      return results[0];\n    }\n    return null;\n  });\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry, model) {\n  const result = registry.orderedGroups(model);\n  return result.length > 0 ? result[0] : null;\n}\nclass DocumentRangeSemanticTokensResult {\n  constructor(provider, tokens) {\n    this.provider = provider;\n    this.tokens = tokens;\n  }\n}\nexport function hasDocumentRangeSemanticTokensProvider(providers, model) {\n  return providers.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(providers, model) {\n  const groups = providers.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\nexport function getDocumentRangeSemanticTokens(registry, model, range, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getDocumentRangeSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      let result;\n      try {\n        result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n      } catch (err) {\n        onUnexpectedExternalError(err);\n        result = null;\n      }\n      if (!result || !isSemanticTokens(result)) {\n        result = null;\n      }\n      return new DocumentRangeSemanticTokensResult(provider, result);\n    })));\n    // Try to return the first result with actual tokens\n    for (const result of results) {\n      if (result.tokens) {\n        return result;\n      }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n      return results[0];\n    }\n    return null;\n  });\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', function (accessor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n      return undefined;\n    }\n    const {\n      documentSemanticTokensProvider\n    } = accessor.get(ILanguageFeaturesService);\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n    if (!providers) {\n      // there is no provider => fall back to a document range semantic tokens provider\n      return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return providers[0].getLegend();\n  });\n});\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', function (accessor) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n      return undefined;\n    }\n    const {\n      documentSemanticTokensProvider\n    } = accessor.get(ILanguageFeaturesService);\n    if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n      // there is no provider => fall back to a document range semantic tokens provider\n      return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const r = yield getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n    if (!r) {\n      return undefined;\n    }\n    const {\n      provider,\n      tokens\n    } = r;\n    if (!tokens || !isSemanticTokens(tokens)) {\n      return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n      id: 0,\n      type: 'full',\n      data: tokens.data\n    });\n    if (tokens.resultId) {\n      provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n    return buff;\n  });\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', function (accessor) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n      return undefined;\n    }\n    const {\n      documentRangeSemanticTokensProvider\n    } = accessor.get(ILanguageFeaturesService);\n    const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n    if (providers.length === 0) {\n      // no providers\n      return undefined;\n    }\n    if (providers.length === 1) {\n      // straight forward case, just a single provider\n      return providers[0].getLegend();\n    }\n    if (!range || !Range.isIRange(range)) {\n      // if no range is provided, we cannot support multiple providers\n      // as we cannot fall back to the one which would give results\n      // => return the first legend for backwards compatibility and print a warning\n      console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n      return providers[0].getLegend();\n    }\n    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result) {\n      return undefined;\n    }\n    return result.provider.getLegend();\n  });\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', function (accessor) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  return __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n      return undefined;\n    }\n    const {\n      documentRangeSemanticTokensProvider\n    } = accessor.get(ILanguageFeaturesService);\n    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result || !result.tokens) {\n      // there is no provider or it didn't return tokens\n      return undefined;\n    }\n    return encodeSemanticTokensDto({\n      id: 0,\n      type: 'full',\n      data: result.tokens.data\n    });\n  });\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CancellationToken","onUnexpectedExternalError","URI","IModelService","CommandsRegistry","ICommandService","assertType","encodeSemanticTokensDto","Range","ILanguageFeaturesService","isSemanticTokens","v","data","isSemanticTokensEdits","Array","isArray","edits","DocumentSemanticTokensResult","constructor","provider","tokens","error","hasDocumentSemanticTokensProvider","registry","model","has","getDocumentSemanticTokensProviders","groups","orderedGroups","length","getDocumentSemanticTokens","lastProvider","lastResultId","token","providers","results","all","map","provideDocumentSemanticTokens","err","_getDocumentSemanticTokensProviderHighestGroup","DocumentRangeSemanticTokensResult","hasDocumentRangeSemanticTokensProvider","getDocumentRangeSemanticTokensProviders","getDocumentRangeSemanticTokens","range","provideDocumentRangeSemanticTokens","registerCommand","accessor","args","uri","get","getModel","undefined","documentSemanticTokensProvider","executeCommand","getLegend","getFullModelRange","r","None","buff","id","type","resultId","releaseDocumentSemanticTokens","documentRangeSemanticTokensProvider","isIRange","console","warn","lift"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/services/getSemanticTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IModelService } from './model.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from './semanticTokensDto.js';\nimport { Range } from '../core/range.js';\nimport { ILanguageFeaturesService } from './languageFeatures.js';\nexport function isSemanticTokens(v) {\n    return v && !!(v.data);\n}\nexport function isSemanticTokensEdits(v) {\n    return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n    constructor(provider, tokens, error) {\n        this.provider = provider;\n        this.tokens = tokens;\n        this.error = error;\n    }\n}\nexport function hasDocumentSemanticTokensProvider(registry, model) {\n    return registry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(registry, model) {\n    const groups = registry.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getDocumentSemanticTokensProviders(registry, model);\n        // Get tokens from all providers at the same time.\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            let result;\n            let error = null;\n            try {\n                result = yield provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n            }\n            catch (err) {\n                error = err;\n                result = null;\n            }\n            if (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n                result = null;\n            }\n            return new DocumentSemanticTokensResult(provider, result, error);\n        })));\n        // Try to return the first result with actual tokens or\n        // the first result which threw an error (!!)\n        for (const result of results) {\n            if (result.error) {\n                throw result.error;\n            }\n            if (result.tokens) {\n                return result;\n            }\n        }\n        // Return the first result, even if it doesn't have tokens\n        if (results.length > 0) {\n            return results[0];\n        }\n        return null;\n    });\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry, model) {\n    const result = registry.orderedGroups(model);\n    return (result.length > 0 ? result[0] : null);\n}\nclass DocumentRangeSemanticTokensResult {\n    constructor(provider, tokens) {\n        this.provider = provider;\n        this.tokens = tokens;\n    }\n}\nexport function hasDocumentRangeSemanticTokensProvider(providers, model) {\n    return providers.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(providers, model) {\n    const groups = providers.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport function getDocumentRangeSemanticTokens(registry, model, range, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getDocumentRangeSemanticTokensProviders(registry, model);\n        // Get tokens from all providers at the same time.\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            let result;\n            try {\n                result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n            }\n            catch (err) {\n                onUnexpectedExternalError(err);\n                result = null;\n            }\n            if (!result || !isSemanticTokens(result)) {\n                result = null;\n            }\n            return new DocumentRangeSemanticTokensResult(provider, result);\n        })));\n        // Try to return the first result with actual tokens\n        for (const result of results) {\n            if (result.tokens) {\n                return result;\n            }\n        }\n        // Return the first result, even if it doesn't have tokens\n        if (results.length > 0) {\n            return results[0];\n        }\n        return null;\n    });\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n    if (!providers) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return providers[0].getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const r = yield getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n    if (!r) {\n        return undefined;\n    }\n    const { provider, tokens } = r;\n    if (!tokens || !isSemanticTokens(tokens)) {\n        return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: tokens.data\n    });\n    if (tokens.resultId) {\n        provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n    return buff;\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n    if (providers.length === 0) {\n        // no providers\n        return undefined;\n    }\n    if (providers.length === 1) {\n        // straight forward case, just a single provider\n        return providers[0].getLegend();\n    }\n    if (!range || !Range.isIRange(range)) {\n        // if no range is provided, we cannot support multiple providers\n        // as we cannot fall back to the one which would give results\n        // => return the first legend for backwards compatibility and print a warning\n        console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n        return providers[0].getLegend();\n    }\n    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result) {\n        return undefined;\n    }\n    return result.provider.getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result || !result.tokens) {\n        // there is no provider or it didn't return tokens\n        return undefined;\n    }\n    return encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: result.tokens.data\n    });\n}));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAK,UAAUC,OAAO,EAAEC,UAAU,EAAEC,CAAC,EAAEC,SAAS,EAAE;EACrF,SAASC,KAAK,CAACC,KAAK,EAAE;IAAE,OAAOA,KAAK,YAAYH,CAAC,GAAGG,KAAK,GAAG,IAAIH,CAAC,CAAC,UAAUI,OAAO,EAAE;MAAEA,OAAO,CAACD,KAAK,CAAC;IAAE,CAAC,CAAC;EAAE;EAC3G,OAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAO,CAAC,EAAE,UAAUD,OAAO,EAAEE,MAAM,EAAE;IACvD,SAASC,SAAS,CAACJ,KAAK,EAAE;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAACQ,IAAI,CAACN,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOO,CAAC,EAAE;QAAEJ,MAAM,CAACI,CAAC,CAAC;MAAE;IAAE;IAC1F,SAASC,QAAQ,CAACR,KAAK,EAAE;MAAE,IAAI;QAAEK,IAAI,CAACP,SAAS,CAAC,OAAO,CAAC,CAACE,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOO,CAAC,EAAE;QAAEJ,MAAM,CAACI,CAAC,CAAC;MAAE;IAAE;IAC7F,SAASF,IAAI,CAACI,MAAM,EAAE;MAAEA,MAAM,CAACC,IAAI,GAAGT,OAAO,CAACQ,MAAM,CAACT,KAAK,CAAC,GAAGD,KAAK,CAACU,MAAM,CAACT,KAAK,CAAC,CAACW,IAAI,CAACP,SAAS,EAAEI,QAAQ,CAAC;IAAE;IAC7GH,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAK,CAACjB,OAAO,EAAEC,UAAU,IAAI,EAAE,CAAC,EAAEU,IAAI,EAAE,CAAC;EACzE,CAAC,CAAC;AACN,CAAC;AACD,SAASO,iBAAiB,QAAQ,sCAAsC;AACxE,SAASC,yBAAyB,QAAQ,gCAAgC;AAC1E,SAASC,GAAG,QAAQ,6BAA6B;AACjD,SAASC,aAAa,QAAQ,YAAY;AAC1C,SAASC,gBAAgB,EAAEC,eAAe,QAAQ,+CAA+C;AACjG,SAASC,UAAU,QAAQ,+BAA+B;AAC1D,SAASC,uBAAuB,QAAQ,wBAAwB;AAChE,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,wBAAwB,QAAQ,uBAAuB;AAChE,OAAO,SAASC,gBAAgB,CAACC,CAAC,EAAE;EAChC,OAAOA,CAAC,IAAI,CAAC,CAAEA,CAAC,CAACC,IAAK;AAC1B;AACA,OAAO,SAASC,qBAAqB,CAACF,CAAC,EAAE;EACrC,OAAOA,CAAC,IAAIG,KAAK,CAACC,OAAO,CAACJ,CAAC,CAACK,KAAK,CAAC;AACtC;AACA,OAAO,MAAMC,4BAA4B,CAAC;EACtCC,WAAW,CAACC,QAAQ,EAAEC,MAAM,EAAEC,KAAK,EAAE;IACjC,IAAI,CAACF,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACtB;AACJ;AACA,OAAO,SAASC,iCAAiC,CAACC,QAAQ,EAAEC,KAAK,EAAE;EAC/D,OAAOD,QAAQ,CAACE,GAAG,CAACD,KAAK,CAAC;AAC9B;AACA,SAASE,kCAAkC,CAACH,QAAQ,EAAEC,KAAK,EAAE;EACzD,MAAMG,MAAM,GAAGJ,QAAQ,CAACK,aAAa,CAACJ,KAAK,CAAC;EAC5C,OAAQG,MAAM,CAACE,MAAM,GAAG,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE;AAC9C;AACA,OAAO,SAASG,yBAAyB,CAACP,QAAQ,EAAEC,KAAK,EAAEO,YAAY,EAAEC,YAAY,EAAEC,KAAK,EAAE;EAC1F,OAAOpD,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IAChD,MAAMqD,SAAS,GAAGR,kCAAkC,CAACH,QAAQ,EAAEC,KAAK,CAAC;IACrE;IACA,MAAMW,OAAO,GAAG,MAAM9C,OAAO,CAAC+C,GAAG,CAACF,SAAS,CAACG,GAAG,CAAElB,QAAQ,IAAKtC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MACvG,IAAIe,MAAM;MACV,IAAIyB,KAAK,GAAG,IAAI;MAChB,IAAI;QACAzB,MAAM,GAAG,MAAMuB,QAAQ,CAACmB,6BAA6B,CAACd,KAAK,EAAGL,QAAQ,KAAKY,YAAY,GAAGC,YAAY,GAAG,IAAI,EAAGC,KAAK,CAAC;MAC1H,CAAC,CACD,OAAOM,GAAG,EAAE;QACRlB,KAAK,GAAGkB,GAAG;QACX3C,MAAM,GAAG,IAAI;MACjB;MACA,IAAI,CAACA,MAAM,IAAK,CAACc,gBAAgB,CAACd,MAAM,CAAC,IAAI,CAACiB,qBAAqB,CAACjB,MAAM,CAAE,EAAE;QAC1EA,MAAM,GAAG,IAAI;MACjB;MACA,OAAO,IAAIqB,4BAA4B,CAACE,QAAQ,EAAEvB,MAAM,EAAEyB,KAAK,CAAC;IACpE,CAAC,CAAC,CAAC,CAAC;IACJ;IACA;IACA,KAAK,MAAMzB,MAAM,IAAIuC,OAAO,EAAE;MAC1B,IAAIvC,MAAM,CAACyB,KAAK,EAAE;QACd,MAAMzB,MAAM,CAACyB,KAAK;MACtB;MACA,IAAIzB,MAAM,CAACwB,MAAM,EAAE;QACf,OAAOxB,MAAM;MACjB;IACJ;IACA;IACA,IAAIuC,OAAO,CAACN,MAAM,GAAG,CAAC,EAAE;MACpB,OAAOM,OAAO,CAAC,CAAC,CAAC;IACrB;IACA,OAAO,IAAI;EACf,CAAC,CAAC;AACN;AACA,SAASK,8CAA8C,CAACjB,QAAQ,EAAEC,KAAK,EAAE;EACrE,MAAM5B,MAAM,GAAG2B,QAAQ,CAACK,aAAa,CAACJ,KAAK,CAAC;EAC5C,OAAQ5B,MAAM,CAACiC,MAAM,GAAG,CAAC,GAAGjC,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI;AAChD;AACA,MAAM6C,iCAAiC,CAAC;EACpCvB,WAAW,CAACC,QAAQ,EAAEC,MAAM,EAAE;IAC1B,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;EACxB;AACJ;AACA,OAAO,SAASsB,sCAAsC,CAACR,SAAS,EAAEV,KAAK,EAAE;EACrE,OAAOU,SAAS,CAACT,GAAG,CAACD,KAAK,CAAC;AAC/B;AACA,SAASmB,uCAAuC,CAACT,SAAS,EAAEV,KAAK,EAAE;EAC/D,MAAMG,MAAM,GAAGO,SAAS,CAACN,aAAa,CAACJ,KAAK,CAAC;EAC7C,OAAQG,MAAM,CAACE,MAAM,GAAG,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE;AAC9C;AACA,OAAO,SAASiB,8BAA8B,CAACrB,QAAQ,EAAEC,KAAK,EAAEqB,KAAK,EAAEZ,KAAK,EAAE;EAC1E,OAAOpD,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IAChD,MAAMqD,SAAS,GAAGS,uCAAuC,CAACpB,QAAQ,EAAEC,KAAK,CAAC;IAC1E;IACA,MAAMW,OAAO,GAAG,MAAM9C,OAAO,CAAC+C,GAAG,CAACF,SAAS,CAACG,GAAG,CAAElB,QAAQ,IAAKtC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MACvG,IAAIe,MAAM;MACV,IAAI;QACAA,MAAM,GAAG,MAAMuB,QAAQ,CAAC2B,kCAAkC,CAACtB,KAAK,EAAEqB,KAAK,EAAEZ,KAAK,CAAC;MACnF,CAAC,CACD,OAAOM,GAAG,EAAE;QACRtC,yBAAyB,CAACsC,GAAG,CAAC;QAC9B3C,MAAM,GAAG,IAAI;MACjB;MACA,IAAI,CAACA,MAAM,IAAI,CAACc,gBAAgB,CAACd,MAAM,CAAC,EAAE;QACtCA,MAAM,GAAG,IAAI;MACjB;MACA,OAAO,IAAI6C,iCAAiC,CAACtB,QAAQ,EAAEvB,MAAM,CAAC;IAClE,CAAC,CAAC,CAAC,CAAC;IACJ;IACA,KAAK,MAAMA,MAAM,IAAIuC,OAAO,EAAE;MAC1B,IAAIvC,MAAM,CAACwB,MAAM,EAAE;QACf,OAAOxB,MAAM;MACjB;IACJ;IACA;IACA,IAAIuC,OAAO,CAACN,MAAM,GAAG,CAAC,EAAE;MACpB,OAAOM,OAAO,CAAC,CAAC,CAAC;IACrB;IACA,OAAO,IAAI;EACf,CAAC,CAAC;AACN;AACA/B,gBAAgB,CAAC2C,eAAe,CAAC,sCAAsC,EAAE,UAACC,QAAQ;EAAA,kCAAKC,IAAI;IAAJA,IAAI;EAAA;EAAA,OAAKpE,SAAS,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IAC3I,MAAM,CAACqE,GAAG,CAAC,GAAGD,IAAI;IAClB3C,UAAU,CAAC4C,GAAG,YAAYhD,GAAG,CAAC;IAC9B,MAAMsB,KAAK,GAAGwB,QAAQ,CAACG,GAAG,CAAChD,aAAa,CAAC,CAACiD,QAAQ,CAACF,GAAG,CAAC;IACvD,IAAI,CAAC1B,KAAK,EAAE;MACR,OAAO6B,SAAS;IACpB;IACA,MAAM;MAAEC;IAA+B,CAAC,GAAGN,QAAQ,CAACG,GAAG,CAAC1C,wBAAwB,CAAC;IACjF,MAAMyB,SAAS,GAAGM,8CAA8C,CAACc,8BAA8B,EAAE9B,KAAK,CAAC;IACvG,IAAI,CAACU,SAAS,EAAE;MACZ;MACA,OAAOc,QAAQ,CAACG,GAAG,CAAC9C,eAAe,CAAC,CAACkD,cAAc,CAAC,2CAA2C,EAAEL,GAAG,CAAC;IACzG;IACA,OAAOhB,SAAS,CAAC,CAAC,CAAC,CAACsB,SAAS,EAAE;EACnC,CAAC,CAAC;AAAA,EAAC;AACHpD,gBAAgB,CAAC2C,eAAe,CAAC,gCAAgC,EAAE,UAACC,QAAQ;EAAA,mCAAKC,IAAI;IAAJA,IAAI;EAAA;EAAA,OAAKpE,SAAS,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IACrI,MAAM,CAACqE,GAAG,CAAC,GAAGD,IAAI;IAClB3C,UAAU,CAAC4C,GAAG,YAAYhD,GAAG,CAAC;IAC9B,MAAMsB,KAAK,GAAGwB,QAAQ,CAACG,GAAG,CAAChD,aAAa,CAAC,CAACiD,QAAQ,CAACF,GAAG,CAAC;IACvD,IAAI,CAAC1B,KAAK,EAAE;MACR,OAAO6B,SAAS;IACpB;IACA,MAAM;MAAEC;IAA+B,CAAC,GAAGN,QAAQ,CAACG,GAAG,CAAC1C,wBAAwB,CAAC;IACjF,IAAI,CAACa,iCAAiC,CAACgC,8BAA8B,EAAE9B,KAAK,CAAC,EAAE;MAC3E;MACA,OAAOwB,QAAQ,CAACG,GAAG,CAAC9C,eAAe,CAAC,CAACkD,cAAc,CAAC,qCAAqC,EAAEL,GAAG,EAAE1B,KAAK,CAACiC,iBAAiB,EAAE,CAAC;IAC9H;IACA,MAAMC,CAAC,GAAG,MAAM5B,yBAAyB,CAACwB,8BAA8B,EAAE9B,KAAK,EAAE,IAAI,EAAE,IAAI,EAAExB,iBAAiB,CAAC2D,IAAI,CAAC;IACpH,IAAI,CAACD,CAAC,EAAE;MACJ,OAAOL,SAAS;IACpB;IACA,MAAM;MAAElC,QAAQ;MAAEC;IAAO,CAAC,GAAGsC,CAAC;IAC9B,IAAI,CAACtC,MAAM,IAAI,CAACV,gBAAgB,CAACU,MAAM,CAAC,EAAE;MACtC,OAAOiC,SAAS;IACpB;IACA,MAAMO,IAAI,GAAGrD,uBAAuB,CAAC;MACjCsD,EAAE,EAAE,CAAC;MACLC,IAAI,EAAE,MAAM;MACZlD,IAAI,EAAEQ,MAAM,CAACR;IACjB,CAAC,CAAC;IACF,IAAIQ,MAAM,CAAC2C,QAAQ,EAAE;MACjB5C,QAAQ,CAAC6C,6BAA6B,CAAC5C,MAAM,CAAC2C,QAAQ,CAAC;IAC3D;IACA,OAAOH,IAAI;EACf,CAAC,CAAC;AAAA,EAAC;AACHxD,gBAAgB,CAAC2C,eAAe,CAAC,2CAA2C,EAAE,UAACC,QAAQ;EAAA,mCAAKC,IAAI;IAAJA,IAAI;EAAA;EAAA,OAAKpE,SAAS,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IAChJ,MAAM,CAACqE,GAAG,EAAEL,KAAK,CAAC,GAAGI,IAAI;IACzB3C,UAAU,CAAC4C,GAAG,YAAYhD,GAAG,CAAC;IAC9B,MAAMsB,KAAK,GAAGwB,QAAQ,CAACG,GAAG,CAAChD,aAAa,CAAC,CAACiD,QAAQ,CAACF,GAAG,CAAC;IACvD,IAAI,CAAC1B,KAAK,EAAE;MACR,OAAO6B,SAAS;IACpB;IACA,MAAM;MAAEY;IAAoC,CAAC,GAAGjB,QAAQ,CAACG,GAAG,CAAC1C,wBAAwB,CAAC;IACtF,MAAMyB,SAAS,GAAGS,uCAAuC,CAACsB,mCAAmC,EAAEzC,KAAK,CAAC;IACrG,IAAIU,SAAS,CAACL,MAAM,KAAK,CAAC,EAAE;MACxB;MACA,OAAOwB,SAAS;IACpB;IACA,IAAInB,SAAS,CAACL,MAAM,KAAK,CAAC,EAAE;MACxB;MACA,OAAOK,SAAS,CAAC,CAAC,CAAC,CAACsB,SAAS,EAAE;IACnC;IACA,IAAI,CAACX,KAAK,IAAI,CAACrC,KAAK,CAAC0D,QAAQ,CAACrB,KAAK,CAAC,EAAE;MAClC;MACA;MACA;MACAsB,OAAO,CAACC,IAAI,CAAE,4IAA2I,CAAC;MAC1J,OAAOlC,SAAS,CAAC,CAAC,CAAC,CAACsB,SAAS,EAAE;IACnC;IACA,MAAM5D,MAAM,GAAG,MAAMgD,8BAA8B,CAACqB,mCAAmC,EAAEzC,KAAK,EAAEhB,KAAK,CAAC6D,IAAI,CAACxB,KAAK,CAAC,EAAE7C,iBAAiB,CAAC2D,IAAI,CAAC;IAC1I,IAAI,CAAC/D,MAAM,EAAE;MACT,OAAOyD,SAAS;IACpB;IACA,OAAOzD,MAAM,CAACuB,QAAQ,CAACqC,SAAS,EAAE;EACtC,CAAC,CAAC;AAAA,EAAC;AACHpD,gBAAgB,CAAC2C,eAAe,CAAC,qCAAqC,EAAE,UAACC,QAAQ;EAAA,mCAAKC,IAAI;IAAJA,IAAI;EAAA;EAAA,OAAKpE,SAAS,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IAC1I,MAAM,CAACqE,GAAG,EAAEL,KAAK,CAAC,GAAGI,IAAI;IACzB3C,UAAU,CAAC4C,GAAG,YAAYhD,GAAG,CAAC;IAC9BI,UAAU,CAACE,KAAK,CAAC0D,QAAQ,CAACrB,KAAK,CAAC,CAAC;IACjC,MAAMrB,KAAK,GAAGwB,QAAQ,CAACG,GAAG,CAAChD,aAAa,CAAC,CAACiD,QAAQ,CAACF,GAAG,CAAC;IACvD,IAAI,CAAC1B,KAAK,EAAE;MACR,OAAO6B,SAAS;IACpB;IACA,MAAM;MAAEY;IAAoC,CAAC,GAAGjB,QAAQ,CAACG,GAAG,CAAC1C,wBAAwB,CAAC;IACtF,MAAMb,MAAM,GAAG,MAAMgD,8BAA8B,CAACqB,mCAAmC,EAAEzC,KAAK,EAAEhB,KAAK,CAAC6D,IAAI,CAACxB,KAAK,CAAC,EAAE7C,iBAAiB,CAAC2D,IAAI,CAAC;IAC1I,IAAI,CAAC/D,MAAM,IAAI,CAACA,MAAM,CAACwB,MAAM,EAAE;MAC3B;MACA,OAAOiC,SAAS;IACpB;IACA,OAAO9C,uBAAuB,CAAC;MAC3BsD,EAAE,EAAE,CAAC;MACLC,IAAI,EAAE,MAAM;MACZlD,IAAI,EAAEhB,MAAM,CAACwB,MAAM,CAACR;IACxB,CAAC,CAAC;EACN,CAAC,CAAC;AAAA,EAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}