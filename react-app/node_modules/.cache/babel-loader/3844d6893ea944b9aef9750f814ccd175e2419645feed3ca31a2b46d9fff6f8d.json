{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n  constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService) {\n    super();\n    this.languageConfigurationService = languageConfigurationService;\n    this._themeService = _themeService;\n    this._editorId = editorId;\n    this._configuration = configuration;\n    this.model = model;\n    this._eventDispatcher = new ViewModelEventDispatcher();\n    this.onEvent = this._eventDispatcher.onEvent;\n    this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n    this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n    this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n    this._hasFocus = false;\n    this._viewportStart = ViewportStart.create(this.model);\n    if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n      this._lines = new ViewModelLinesFromModelAsIs(this.model);\n    } else {\n      const options = this._configuration.options;\n      const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n      const wrappingStrategy = options.get(127 /* EditorOption.wrappingStrategy */);\n      const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n      const wrappingIndent = options.get(126 /* EditorOption.wrappingIndent */);\n      this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n    }\n    this.coordinatesConverter = this._lines.createCoordinatesConverter();\n    this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n    this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n    this._register(this.viewLayout.onDidScroll(e => {\n      if (e.scrollTopChanged) {\n        this._tokenizeViewportSoon.schedule();\n      }\n      if (e.scrollTopChanged) {\n        this._viewportStart.invalidate();\n      }\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n      this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n    }));\n    this._register(this.viewLayout.onDidContentSizeChange(e => {\n      this._eventDispatcher.emitOutgoingEvent(e);\n    }));\n    this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n    this._registerModelEvents();\n    this._register(this._configuration.onDidChangeFast(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        this._onConfigurationChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n    }));\n    this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n    }));\n    this._register(this._themeService.onDidColorThemeChange(theme => {\n      this._invalidateDecorationsColorCache();\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n    }));\n    this._updateConfigurationViewLineCountNow();\n  }\n  dispose() {\n    // First remove listeners, as disposing the lines might end up sending\n    // model decoration changed events ... and we no longer care about them ...\n    super.dispose();\n    this._decorations.dispose();\n    this._lines.dispose();\n    this._viewportStart.dispose();\n    this._eventDispatcher.dispose();\n  }\n  createLineBreaksComputer() {\n    return this._lines.createLineBreaksComputer();\n  }\n  addViewEventHandler(eventHandler) {\n    this._eventDispatcher.addViewEventHandler(eventHandler);\n  }\n  removeViewEventHandler(eventHandler) {\n    this._eventDispatcher.removeViewEventHandler(eventHandler);\n  }\n  _updateConfigurationViewLineCountNow() {\n    this._configuration.setViewLineCount(this._lines.getViewLineCount());\n  }\n  tokenizeViewport() {\n    const linesViewportData = this.viewLayout.getLinesViewportData();\n    const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n    const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n    for (const modelVisibleRange of modelVisibleRanges) {\n      this.model.tokenization.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n    }\n  }\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n    this._cursor.setHasFocus(hasFocus);\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n    this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n  }\n  onCompositionStart() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n  }\n  onCompositionEnd() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n  }\n  _onConfigurationChanged(eventsCollector, e) {\n    // We might need to restore the current centered view range, so save it (if available)\n    let previousViewportStartModelPosition = null;\n    if (this._viewportStart.isValid) {\n      const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n      previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n    }\n    let restorePreviousViewportStart = false;\n    const options = this._configuration.options;\n    const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n    const wrappingStrategy = options.get(127 /* EditorOption.wrappingStrategy */);\n    const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n    const wrappingIndent = options.get(126 /* EditorOption.wrappingIndent */);\n    if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n      eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n      this._cursor.onLineMappingChanged(eventsCollector);\n      this._decorations.onLineMappingChanged();\n      this.viewLayout.onFlushed(this.getLineCount());\n      if (this.viewLayout.getCurrentScrollTop() !== 0) {\n        // Never change the scroll position from 0 to something else...\n        restorePreviousViewportStart = true;\n      }\n      this._updateConfigurationViewLineCount.schedule();\n    }\n    if (e.hasChanged(83 /* EditorOption.readOnly */)) {\n      // Must read again all decorations due to readOnly filtering\n      this._decorations.reset();\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n    }\n    eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n    this.viewLayout.onConfigurationChanged(e);\n    if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n      const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n      const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n      this.viewLayout.setScrollPosition({\n        scrollTop: viewPositionTop + this._viewportStart.startLineDelta\n      }, 1 /* ScrollType.Immediate */);\n    }\n\n    if (CursorConfiguration.shouldRecreate(e)) {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }\n  }\n  _registerModelEvents() {\n    this._register(this.model.onDidChangeContentOrInjectedText(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        let hadOtherModelChange = false;\n        let hadModelLineChangeThatChangedLineMapping = false;\n        const changes = e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes;\n        const versionId = e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null;\n        // Do a first pass to compute line mappings, and a second pass to actually interpret them\n        const lineBreaksComputer = this._lines.createLineBreaksComputer();\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 4 /* textModelEvents.RawContentChangedType.LinesInserted */:\n              {\n                for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                  const line = change.detail[lineIdx];\n                  let injectedText = change.injectedTexts[lineIdx];\n                  if (injectedText) {\n                    injectedText = injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);\n                  }\n                  lineBreaksComputer.addRequest(line, injectedText, null);\n                }\n                break;\n              }\n            case 2 /* textModelEvents.RawContentChangedType.LineChanged */:\n              {\n                let injectedText = null;\n                if (change.injectedText) {\n                  injectedText = change.injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);\n                }\n                lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                break;\n              }\n          }\n        }\n        const lineBreaks = lineBreaksComputer.finalize();\n        const lineBreakQueue = new ArrayQueue(lineBreaks);\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 1 /* textModelEvents.RawContentChangedType.Flush */:\n              {\n                this._lines.onModelFlushed();\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                this._decorations.reset();\n                this.viewLayout.onFlushed(this.getLineCount());\n                hadOtherModelChange = true;\n                break;\n              }\n            case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */:\n              {\n                const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                if (linesDeletedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n                hadOtherModelChange = true;\n                break;\n              }\n            case 4 /* textModelEvents.RawContentChangedType.LinesInserted */:\n              {\n                const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                if (linesInsertedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n                hadOtherModelChange = true;\n                break;\n              }\n            case 2 /* textModelEvents.RawContentChangedType.LineChanged */:\n              {\n                const changedLineBreakData = lineBreakQueue.dequeue();\n                const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                if (linesChangedEvent) {\n                  eventsCollector.emitViewEvent(linesChangedEvent);\n                }\n                if (linesInsertedEvent) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n                if (linesDeletedEvent) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n                break;\n              }\n            case 5 /* textModelEvents.RawContentChangedType.EOLChanged */:\n              {\n                // Nothing to do. The new version will be accepted below\n                break;\n              }\n          }\n        }\n        if (versionId !== null) {\n          this._lines.acceptVersionId(versionId);\n        }\n        this.viewLayout.onHeightMaybeChanged();\n        if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n          this._cursor.onLineMappingChanged(eventsCollector);\n          this._decorations.onLineMappingChanged();\n        }\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n      // Update the configuration and reset the centered view line\n      const viewportStartWasValid = this._viewportStart.isValid;\n      this._viewportStart.invalidate();\n      this._configuration.setModelLineCount(this.model.getLineCount());\n      this._updateConfigurationViewLineCountNow();\n      // Recover viewport\n      if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n        const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n        if (modelRange) {\n          const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n          const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n          this.viewLayout.setScrollPosition({\n            scrollTop: viewPositionTop + this._viewportStart.startLineDelta\n          }, 1 /* ScrollType.Immediate */);\n        }\n      }\n\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n          eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n        }\n        this._cursor.onModelContentChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n      this._tokenizeViewportSoon.schedule();\n    }));\n    this._register(this.model.onDidChangeTokens(e => {\n      const viewRanges = [];\n      for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n        const modelRange = e.ranges[j];\n        const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n        const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n        viewRanges[j] = {\n          fromLineNumber: viewStartLineNumber,\n          toLineNumber: viewEndLineNumber\n        };\n      }\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n      if (e.tokenizationSupportChanged) {\n        this._tokenizeViewportSoon.schedule();\n      }\n      this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n    }));\n    this._register(this.model.onDidChangeLanguageConfiguration(e => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n      this._cursor.updateConfiguration(this.cursorConfig);\n      this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n    }));\n    this._register(this.model.onDidChangeLanguage(e => {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n      this._cursor.updateConfiguration(this.cursorConfig);\n      this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n    }));\n    this._register(this.model.onDidChangeOptions(e => {\n      // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n        try {\n          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n          eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n          this._cursor.onLineMappingChanged(eventsCollector);\n          this._decorations.onLineMappingChanged();\n          this.viewLayout.onFlushed(this.getLineCount());\n        } finally {\n          this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n      }\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n      this._cursor.updateConfiguration(this.cursorConfig);\n      this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n    }));\n    this._register(this.model.onDidChangeDecorations(e => {\n      this._decorations.onModelDecorationsChanged();\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n      this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n    }));\n  }\n  setHiddenAreas(ranges) {\n    let lineMappingChanged = false;\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n      lineMappingChanged = this._lines.setHiddenAreas(ranges);\n      if (lineMappingChanged) {\n        eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        this._cursor.onLineMappingChanged(eventsCollector);\n        this._decorations.onLineMappingChanged();\n        this.viewLayout.onFlushed(this.getLineCount());\n        this.viewLayout.onHeightMaybeChanged();\n      }\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n    this._updateConfigurationViewLineCount.schedule();\n    if (lineMappingChanged) {\n      this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n    }\n  }\n  getVisibleRangesPlusViewportAboveBelow() {\n    const layoutInfo = this._configuration.options.get(133 /* EditorOption.layoutInfo */);\n    const lineHeight = this._configuration.options.get(61 /* EditorOption.lineHeight */);\n    const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n    const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n    return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n  }\n  getVisibleRanges() {\n    const visibleViewRange = this.getCompletelyVisibleViewRange();\n    return this._toModelVisibleRanges(visibleViewRange);\n  }\n  getHiddenAreas() {\n    return this._lines.getHiddenAreas();\n  }\n  _toModelVisibleRanges(visibleViewRange) {\n    const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n    const hiddenAreas = this._lines.getHiddenAreas();\n    if (hiddenAreas.length === 0) {\n      return [visibleRange];\n    }\n    const result = [];\n    let resultLen = 0;\n    let startLineNumber = visibleRange.startLineNumber;\n    let startColumn = visibleRange.startColumn;\n    const endLineNumber = visibleRange.endLineNumber;\n    const endColumn = visibleRange.endColumn;\n    for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n      const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n      const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n      if (hiddenEndLineNumber < startLineNumber) {\n        continue;\n      }\n      if (hiddenStartLineNumber > endLineNumber) {\n        continue;\n      }\n      if (startLineNumber < hiddenStartLineNumber) {\n        result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n      }\n      startLineNumber = hiddenEndLineNumber + 1;\n      startColumn = 1;\n    }\n    if (startLineNumber < endLineNumber || startLineNumber === endLineNumber && startColumn < endColumn) {\n      result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    return result;\n  }\n  getCompletelyVisibleViewRange() {\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n  getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n    const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n  saveState() {\n    const compatViewState = this.viewLayout.saveState();\n    const scrollTop = compatViewState.scrollTop;\n    const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n    const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n    const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n    return {\n      scrollLeft: compatViewState.scrollLeft,\n      firstPosition: firstPosition,\n      firstPositionDeltaTop: firstPositionDeltaTop\n    };\n  }\n  reduceRestoreState(state) {\n    if (typeof state.firstPosition === 'undefined') {\n      // This is a view state serialized by an older version\n      return this._reduceRestoreStateCompatibility(state);\n    }\n    const modelPosition = this.model.validatePosition(state.firstPosition);\n    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n    const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  _reduceRestoreStateCompatibility(state) {\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: state.scrollTopWithoutViewZones\n    };\n  }\n  getTabSize() {\n    return this.model.getOptions().tabSize;\n  }\n  getLineCount() {\n    return this._lines.getViewLineCount();\n  }\n  /**\n   * Gives a hint that a lot of requests are about to come in for these line numbers.\n   */\n  setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n    this._viewportStart.update(this, startLineNumber);\n  }\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n  }\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n  }\n  getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n    return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n  }\n  getLineContent(lineNumber) {\n    return this._lines.getViewLineContent(lineNumber);\n  }\n  getLineLength(lineNumber) {\n    return this._lines.getViewLineLength(lineNumber);\n  }\n  getLineMinColumn(lineNumber) {\n    return this._lines.getViewLineMinColumn(lineNumber);\n  }\n  getLineMaxColumn(lineNumber) {\n    return this._lines.getViewLineMaxColumn(lineNumber);\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 1;\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 2;\n  }\n  getDecorationsInViewport(visibleRange) {\n    return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n  }\n  getInjectedTextAt(viewPosition) {\n    return this._lines.getInjectedTextAt(viewPosition);\n  }\n  getViewportViewLineRenderingData(visibleRange, lineNumber) {\n    const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n    const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n    return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n  }\n  getViewLineRenderingData(lineNumber) {\n    const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n    return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n  }\n  _getViewLineRenderingData(lineNumber, inlineDecorations) {\n    const mightContainRTL = this.model.mightContainRTL();\n    const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n    const tabSize = this.getTabSize();\n    const lineData = this._lines.getViewLineData(lineNumber);\n    if (lineData.inlineDecorations) {\n      inlineDecorations = [...inlineDecorations, ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))];\n    }\n    return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n  }\n  getViewLineData(lineNumber) {\n    return this._lines.getViewLineData(lineNumber);\n  }\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n    return new MinimapLinesRenderingData(this.getTabSize(), result);\n  }\n  getAllOverviewRulerDecorations(theme) {\n    const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n    const result = new OverviewRulerDecorations();\n    for (const decoration of decorations) {\n      const decorationOptions = decoration.options;\n      const opts = decorationOptions.overviewRuler;\n      if (!opts) {\n        continue;\n      }\n      const lane = opts.position;\n      if (lane === 0) {\n        continue;\n      }\n      const color = opts.getColor(theme.value);\n      const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n      const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n      result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n    }\n    return result.asArray;\n  }\n  _invalidateDecorationsColorCache() {\n    const decorations = this.model.getOverviewRulerDecorations();\n    for (const decoration of decorations) {\n      const opts1 = decoration.options.overviewRuler;\n      if (opts1) {\n        opts1.invalidateCachedColor();\n      }\n      const opts2 = decoration.options.minimap;\n      if (opts2) {\n        opts2.invalidateCachedColor();\n      }\n    }\n  }\n  getValueInRange(range, eol) {\n    const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n    return this.model.getValueInRange(modelRange, eol);\n  }\n  deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n    const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n    if (this.model.getEOL().length === 2) {\n      // This model uses CRLF, so the delta must take that into account\n      if (deltaOffset < 0) {\n        deltaOffset -= lineFeedCnt;\n      } else {\n        deltaOffset += lineFeedCnt;\n      }\n    }\n    const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n    const resultOffset = modelAnchorOffset + deltaOffset;\n    return this.model.getPositionAt(resultOffset);\n  }\n  getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n    const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n    modelRanges = modelRanges.slice(0);\n    modelRanges.sort(Range.compareRangesUsingStarts);\n    let hasEmptyRange = false;\n    let hasNonEmptyRange = false;\n    for (const range of modelRanges) {\n      if (range.isEmpty()) {\n        hasEmptyRange = true;\n      } else {\n        hasNonEmptyRange = true;\n      }\n    }\n    if (!hasNonEmptyRange) {\n      // all ranges are empty\n      if (!emptySelectionClipboard) {\n        return '';\n      }\n      const modelLineNumbers = modelRanges.map(r => r.startLineNumber);\n      let result = '';\n      for (let i = 0; i < modelLineNumbers.length; i++) {\n        if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n          continue;\n        }\n        result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n      }\n      return result;\n    }\n    if (hasEmptyRange && emptySelectionClipboard) {\n      // mixed empty selections and non-empty selections\n      const result = [];\n      let prevModelLineNumber = 0;\n      for (const modelRange of modelRanges) {\n        const modelLineNumber = modelRange.startLineNumber;\n        if (modelRange.isEmpty()) {\n          if (modelLineNumber !== prevModelLineNumber) {\n            result.push(this.model.getLineContent(modelLineNumber));\n          }\n        } else {\n          result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n        }\n\n        prevModelLineNumber = modelLineNumber;\n      }\n      return result.length === 1 ? result[0] : result;\n    }\n    const result = [];\n    for (const modelRange of modelRanges) {\n      if (!modelRange.isEmpty()) {\n        result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n      }\n    }\n\n    return result.length === 1 ? result[0] : result;\n  }\n  getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n    const languageId = this.model.getLanguageId();\n    if (languageId === PLAINTEXT_LANGUAGE_ID) {\n      return null;\n    }\n    if (modelRanges.length !== 1) {\n      // no multiple selection support at this time\n      return null;\n    }\n    let range = modelRanges[0];\n    if (range.isEmpty()) {\n      if (!emptySelectionClipboard) {\n        // nothing to copy\n        return null;\n      }\n      const lineNumber = range.startLineNumber;\n      range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n    }\n    const fontInfo = this._configuration.options.get(46 /* EditorOption.fontInfo */);\n    const colorMap = this._getColorMap();\n    const hasBadChars = /[:;\\\\\\/<>]/.test(fontInfo.fontFamily);\n    const useDefaultFontFamily = hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily;\n    let fontFamily;\n    if (useDefaultFontFamily) {\n      fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n    } else {\n      fontFamily = fontInfo.fontFamily;\n      fontFamily = fontFamily.replace(/\"/g, '\\'');\n      const hasQuotesOrIsList = /[,']/.test(fontFamily);\n      if (!hasQuotesOrIsList) {\n        const needsQuotes = /[+ ]/.test(fontFamily);\n        if (needsQuotes) {\n          fontFamily = `'${fontFamily}'`;\n        }\n      }\n      fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n    }\n    return {\n      mode: languageId,\n      html: `<div style=\"` + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};` + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};` + `font-family: ${fontFamily};` + `font-weight: ${fontInfo.fontWeight};` + `font-size: ${fontInfo.fontSize}px;` + `line-height: ${fontInfo.lineHeight}px;` + `white-space: pre;` + `\">` + this._getHTMLToCopy(range, colorMap) + '</div>'\n    };\n  }\n  _getHTMLToCopy(modelRange, colorMap) {\n    const startLineNumber = modelRange.startLineNumber;\n    const startColumn = modelRange.startColumn;\n    const endLineNumber = modelRange.endLineNumber;\n    const endColumn = modelRange.endColumn;\n    const tabSize = this.getTabSize();\n    let result = '';\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n      const lineContent = lineTokens.getLineContent();\n      const startOffset = lineNumber === startLineNumber ? startColumn - 1 : 0;\n      const endOffset = lineNumber === endLineNumber ? endColumn - 1 : lineContent.length;\n      if (lineContent === '') {\n        result += '<br>';\n      } else {\n        result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n      }\n    }\n    return result;\n  }\n  _getColorMap() {\n    const colorMap = TokenizationRegistry.getColorMap();\n    const result = ['#000000'];\n    if (colorMap) {\n      for (let i = 1, len = colorMap.length; i < len; i++) {\n        result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n      }\n    }\n    return result;\n  }\n  //#region cursor operations\n  getPrimaryCursorState() {\n    return this._cursor.getPrimaryCursorState();\n  }\n  getLastAddedCursorIndex() {\n    return this._cursor.getLastAddedCursorIndex();\n  }\n  getCursorStates() {\n    return this._cursor.getCursorStates();\n  }\n  setCursorStates(source, reason, states) {\n    return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n  }\n  getCursorColumnSelectData() {\n    return this._cursor.getCursorColumnSelectData();\n  }\n  getCursorAutoClosedCharacters() {\n    return this._cursor.getAutoClosedCharacters();\n  }\n  setCursorColumnSelectData(columnSelectData) {\n    this._cursor.setCursorColumnSelectData(columnSelectData);\n  }\n  getPrevEditOperationType() {\n    return this._cursor.getPrevEditOperationType();\n  }\n  setPrevEditOperationType(type) {\n    this._cursor.setPrevEditOperationType(type);\n  }\n  getSelection() {\n    return this._cursor.getSelection();\n  }\n  getSelections() {\n    return this._cursor.getSelections();\n  }\n  getPosition() {\n    return this._cursor.getPrimaryCursorState().modelState.position;\n  }\n  setSelections(source, selections) {\n    let reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n  }\n  saveCursorState() {\n    return this._cursor.saveState();\n  }\n  restoreCursorState(states) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n  }\n  _executeCursorEdit(callback) {\n    if (this._cursor.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n      return;\n    }\n    this._withViewEventsCollector(callback);\n  }\n  executeEdits(source, edits, cursorStateComputer) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n  }\n  startComposition() {\n    this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n  }\n  endComposition(source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n  }\n  type(text, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n  }\n  compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n  }\n  paste(text, pasteOnNewLine, multicursorText, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n  }\n  cut(source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n  }\n  executeCommand(command, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n  }\n  executeCommands(commands, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n  }\n  revealPrimaryCursor(source, revealHorizontal) {\n    let minimalReveal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n  }\n\n  revealTopMostCursor(source) {\n    const viewPosition = this._cursor.getTopMostViewPosition();\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n  }\n\n  revealBottomMostCursor(source) {\n    const viewPosition = this._cursor.getBottomMostViewPosition();\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n  }\n\n  revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n  }\n  //#endregion\n  //#region viewLayout\n  changeWhitespace(callback) {\n    const hadAChange = this.viewLayout.changeWhitespace(callback);\n    if (hadAChange) {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n      this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n    }\n  }\n  //#endregion\n  _withViewEventsCollector(callback) {\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n      return callback(eventsCollector);\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n  }\n  normalizePosition(position, affinity) {\n    return this._lines.normalizePosition(position, affinity);\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n  getLineIndentColumn(lineNumber) {\n    return this._lines.getLineIndentColumn(lineNumber);\n  }\n}\nclass ViewportStart {\n  constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n    this._model = _model;\n    this._viewLineNumber = _viewLineNumber;\n    this._isValid = _isValid;\n    this._modelTrackedRange = _modelTrackedRange;\n    this._startLineDelta = _startLineDelta;\n  }\n  static create(model) {\n    const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n  }\n  get viewLineNumber() {\n    return this._viewLineNumber;\n  }\n  get isValid() {\n    return this._isValid;\n  }\n  get modelTrackedRange() {\n    return this._modelTrackedRange;\n  }\n  get startLineDelta() {\n    return this._startLineDelta;\n  }\n  dispose() {\n    this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n  }\n\n  update(viewModel, startLineNumber) {\n    const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n    const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n    const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n    this._viewLineNumber = startLineNumber;\n    this._isValid = true;\n    this._modelTrackedRange = viewportStartLineTrackedRange;\n    this._startLineDelta = scrollTop - viewportStartLineTop;\n  }\n  invalidate() {\n    this._isValid = false;\n  }\n}\nclass OverviewRulerDecorations {\n  constructor() {\n    this._asMap = Object.create(null);\n    this.asArray = [];\n  }\n  accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n    const prevGroup = this._asMap[color];\n    if (prevGroup) {\n      const prevData = prevGroup.data;\n      const prevLane = prevData[prevData.length - 3];\n      const prevEndLineNumber = prevData[prevData.length - 1];\n      if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n        // merge into prev\n        if (endLineNumber > prevEndLineNumber) {\n          prevData[prevData.length - 1] = endLineNumber;\n        }\n        return;\n      }\n      // push\n      prevData.push(lane, startLineNumber, endLineNumber);\n    } else {\n      const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n      this._asMap[color] = group;\n      this.asArray.push(group);\n    }\n  }\n}","map":{"version":3,"names":["ArrayQueue","RunOnceScheduler","Color","Disposable","platform","strings","EDITOR_FONT_DEFAULTS","filterValidationDecorations","CursorsController","CursorConfiguration","Position","Range","textModelEvents","TokenizationRegistry","PLAINTEXT_LANGUAGE_ID","tokenizeLineToHTML","viewEvents","ViewLayout","MinimapTokensColorTracker","MinimapLinesRenderingData","OverviewRulerDecorationsGroup","ViewLineRenderingData","ViewModelDecorations","FocusChangedEvent","HiddenAreasChangedEvent","ModelContentChangedEvent","ModelDecorationsChangedEvent","ModelLanguageChangedEvent","ModelLanguageConfigurationChangedEvent","ModelOptionsChangedEvent","ModelTokensChangedEvent","ReadOnlyEditAttemptEvent","ScrollChangedEvent","ViewModelEventDispatcher","ViewZonesChangedEvent","ViewModelLinesFromModelAsIs","ViewModelLinesFromProjectedModel","USE_IDENTITY_LINES_COLLECTION","ViewModel","constructor","editorId","configuration","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","scheduleAtNextAnimationFrame","languageConfigurationService","_themeService","_editorId","_configuration","_eventDispatcher","onEvent","cursorConfig","getLanguageId","getOptions","_tokenizeViewportSoon","_register","tokenizeViewport","_updateConfigurationViewLineCount","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStart","ViewportStart","create","isTooLargeForTokenization","_lines","options","fontInfo","get","wrappingStrategy","wrappingInfo","wrappingIndent","tabSize","wrappingColumn","coordinatesConverter","createCoordinatesConverter","_cursor","viewLayout","getLineCount","onDidScroll","e","scrollTopChanged","schedule","invalidate","emitSingleViewEvent","ViewScrollChangedEvent","emitOutgoingEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","scrollWidth","scrollLeft","scrollHeight","scrollTop","onDidContentSizeChange","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","getInstance","onDidChange","ViewTokensColorsChangedEvent","onDidColorThemeChange","theme","_invalidateDecorationsColorCache","ViewThemeChangedEvent","dispose","createLineBreaksComputer","addViewEventHandler","eventHandler","removeViewEventHandler","setViewLineCount","getViewLineCount","linesViewportData","getLinesViewportData","viewVisibleRange","startLineNumber","getLineMinColumn","endLineNumber","getLineMaxColumn","modelVisibleRanges","_toModelVisibleRanges","modelVisibleRange","tokenization","setHasFocus","hasFocus","ViewFocusChangedEvent","onCompositionStart","ViewCompositionStartEvent","onCompositionEnd","ViewCompositionEndEvent","previousViewportStartModelPosition","isValid","previousViewportStartViewPosition","viewLineNumber","convertViewPositionToModelPosition","restorePreviousViewportStart","setWrappingSettings","emitViewEvent","ViewFlushedEvent","ViewLineMappingChangedEvent","ViewDecorationsChangedEvent","onLineMappingChanged","onFlushed","getCurrentScrollTop","hasChanged","reset","ViewConfigurationChangedEvent","onConfigurationChanged","viewPosition","convertModelPositionToViewPosition","viewPositionTop","getVerticalOffsetForLineNumber","lineNumber","setScrollPosition","startLineDelta","shouldRecreate","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","changes","InternalModelContentChangeEvent","rawContentChangedEvent","versionId","lineBreaksComputer","change","changeType","lineIdx","detail","length","line","injectedText","injectedTexts","filter","element","ownerId","addRequest","lineBreaks","finalize","lineBreakQueue","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","fromLineNumber","toLineNumber","onLinesDeleted","insertedLineBreaks","takeCount","linesInsertedEvent","onModelLinesInserted","onLinesInserted","changedLineBreakData","dequeue","lineMappingChanged","linesChangedEvent","onModelLineChanged","acceptVersionId","onHeightMaybeChanged","viewportStartWasValid","setModelLineCount","getAttachedEditorCount","modelRange","_getTrackedRange","modelTrackedRange","getStartPosition","contentChangedEvent","onModelContentChanged","onDidChangeTokens","viewRanges","j","lenJ","ranges","viewStartLineNumber","viewEndLineNumber","ViewTokensChangedEvent","tokenizationSupportChanged","onDidChangeLanguageConfiguration","ViewLanguageConfigurationEvent","onDidChangeLanguage","onDidChangeOptions","setTabSize","onDidChangeDecorations","onModelDecorationsChanged","setHiddenAreas","getVisibleRangesPlusViewportAboveBelow","layoutInfo","lineHeight","linesAround","Math","max","round","height","partialData","startViewLineNumber","completelyVisibleStartLineNumber","endViewLineNumber","min","completelyVisibleEndLineNumber","getVisibleRanges","visibleViewRange","getCompletelyVisibleViewRange","getHiddenAreas","visibleRange","convertViewRangeToModelRange","hiddenAreas","result","resultLen","startColumn","endColumn","i","len","hiddenStartLineNumber","hiddenEndLineNumber","getCompletelyVisibleViewRangeAtScrollTop","getLinesViewportDataAtScrollTop","saveState","compatViewState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","reduceRestoreState","state","_reduceRestoreStateCompatibility","modelPosition","validatePosition","scrollTopWithoutViewZones","getTabSize","setViewport","centeredLineNumber","update","getActiveIndentGuide","minLineNumber","maxLineNumber","getLinesIndentGuides","getViewLinesIndentGuides","getBracketGuidesInRangeByLine","activePosition","getViewLinesBracketGuides","getLineContent","getViewLineContent","getLineLength","getViewLineLength","getViewLineMinColumn","getViewLineMaxColumn","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","getDecorationsInViewport","getDecorationsViewportData","decorations","getInjectedTextAt","getViewportViewLineRenderingData","allInlineDecorations","inlineDecorations","_getViewLineRenderingData","getViewLineRenderingData","getInlineDecorationsOnLine","mightContainRTL","mightContainNonBasicASCII","lineData","getViewLineData","map","d","toInlineDecoration","minColumn","maxColumn","content","continuesWithWrappedLine","tokens","startVisibleColumn","getMinimapLinesRenderingData","needed","getViewLinesData","getAllOverviewRulerDecorations","getOverviewRulerDecorations","OverviewRulerDecorations","decoration","decorationOptions","opts","overviewRuler","lane","position","color","getColor","value","getViewLineNumberOfModelPosition","range","accept","zIndex","asArray","opts1","invalidateCachedColor","opts2","minimap","getValueInRange","eol","deduceModelPositionRelativeToViewPosition","viewAnchorPosition","deltaOffset","lineFeedCnt","modelAnchor","getEOL","modelAnchorOffset","getOffsetAt","resultOffset","getPositionAt","getPlainTextToCopy","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","slice","sort","compareRangesUsingStarts","hasEmptyRange","hasNonEmptyRange","isEmpty","modelLineNumbers","r","prevModelLineNumber","modelLineNumber","push","getRichTextToCopy","languageId","colorMap","_getColorMap","hasBadChars","test","fontFamily","useDefaultFontFamily","replace","hasQuotesOrIsList","needsQuotes","mode","html","fontWeight","fontSize","_getHTMLToCopy","lineTokens","getLineTokens","lineContent","startOffset","endOffset","inflate","isWindows","getColorMap","Format","CSS","formatHex","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","setCursorStates","source","reason","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getCursorAutoClosedCharacters","getAutoClosedCharacters","setCursorColumnSelectData","columnSelectData","getPrevEditOperationType","setPrevEditOperationType","type","getSelection","getSelections","getPosition","modelState","setSelections","selections","saveCursorState","restoreCursorState","restoreState","_executeCursorEdit","callback","context","readOnly","executeEdits","edits","cursorStateComputer","startComposition","endComposition","text","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","paste","pasteOnNewLine","multicursorText","cut","executeCommand","command","executeCommands","commands","revealPrimaryCursor","revealHorizontal","minimalReveal","revealPrimary","revealTopMostCursor","getTopMostViewPosition","viewRange","column","ViewRevealRangeRequestEvent","revealBottomMostCursor","getBottomMostViewPosition","revealRange","verticalType","scrollType","changeWhitespace","hadAChange","normalizePosition","affinity","getLineIndentColumn","_model","_viewLineNumber","_isValid","_modelTrackedRange","_startLineDelta","viewportStartLineTrackedRange","_setTrackedRange","viewModel","viewportStartLineTop","_asMap","Object","prevGroup","prevData","data","prevLane","prevEndLineNumber","group"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(127 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(126 /* EditorOption.wrappingIndent */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    tokenizeViewport() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        for (const modelVisibleRange of modelVisibleRanges) {\n            this.model.tokenization.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n        }\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        // We might need to restore the current centered view range, so save it (if available)\n        let previousViewportStartModelPosition = null;\n        if (this._viewportStart.isValid) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n        }\n        let restorePreviousViewportStart = false;\n        const options = this._configuration.options;\n        const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(127 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(126 /* EditorOption.wrappingIndent */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                // Never change the scroll position from 0 to something else...\n                restorePreviousViewportStart = true;\n            }\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(83 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n        }\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._tokenizeViewportSoon.schedule();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            if (e.tokenizationSupportChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges) {\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(ranges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(133 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(61 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            if (opts1) {\n                opts1.invalidateCachedColor();\n            }\n            const opts2 = decoration.options.minimap;\n            if (opts2) {\n                opts2.invalidateCachedColor();\n            }\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(46 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}