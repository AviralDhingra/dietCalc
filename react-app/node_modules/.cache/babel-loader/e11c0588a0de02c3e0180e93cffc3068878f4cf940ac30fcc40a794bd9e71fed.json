{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n  const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n  return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n  constructor(tokenizer, edits, oldNode, createImmutableLists) {\n    this.tokenizer = tokenizer;\n    this.createImmutableLists = createImmutableLists;\n    this._itemsConstructed = 0;\n    this._itemsFromCache = 0;\n    if (oldNode && createImmutableLists) {\n      throw new Error('Not supported');\n    }\n    this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n    this.positionMapper = new BeforeEditPositionMapper(edits, tokenizer.length);\n  }\n  parseDocument() {\n    this._itemsConstructed = 0;\n    this._itemsFromCache = 0;\n    let result = this.parseList(SmallImmutableSet.getEmpty());\n    if (!result) {\n      result = ListAstNode.getEmpty();\n    }\n    return result;\n  }\n  parseList(openedBracketIds) {\n    const items = new Array();\n    while (true) {\n      const token = this.tokenizer.peek();\n      if (!token || token.kind === 2 /* TokenKind.ClosingBracket */ && token.bracketIds.intersects(openedBracketIds)) {\n        break;\n      }\n      const child = this.parseChild(openedBracketIds);\n      if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n        continue;\n      }\n      items.push(child);\n    }\n    // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n    const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n    return result;\n  }\n  parseChild(openedBracketIds) {\n    if (this.oldNodeReader) {\n      const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n      if (!lengthIsZero(maxCacheableLength)) {\n        const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n          if (!lengthLessThan(curNode.length, maxCacheableLength)) {\n            // Either the node contains edited text or touches edited text.\n            // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n            return false;\n          }\n          const canBeReused = curNode.canBeReused(openedBracketIds);\n          return canBeReused;\n        });\n        if (cachedNode) {\n          this._itemsFromCache++;\n          this.tokenizer.skip(cachedNode.length);\n          return cachedNode;\n        }\n      }\n    }\n    this._itemsConstructed++;\n    const token = this.tokenizer.read();\n    switch (token.kind) {\n      case 2 /* TokenKind.ClosingBracket */:\n        return new InvalidBracketAstNode(token.bracketIds, token.length);\n      case 0 /* TokenKind.Text */:\n        return token.astNode;\n      case 1 /* TokenKind.OpeningBracket */:\n        {\n          const set = openedBracketIds.merge(token.bracketIds);\n          const child = this.parseList(set);\n          const nextToken = this.tokenizer.peek();\n          if (nextToken && nextToken.kind === 2 /* TokenKind.ClosingBracket */ && (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n            this.tokenizer.read();\n            return PairAstNode.create(token.astNode, child, nextToken.astNode);\n          } else {\n            return PairAstNode.create(token.astNode, child, null);\n          }\n        }\n      default:\n        throw new Error('unexpected');\n    }\n  }\n}","map":{"version":3,"names":["InvalidBracketAstNode","ListAstNode","PairAstNode","BeforeEditPositionMapper","SmallImmutableSet","lengthIsZero","lengthLessThan","concat23Trees","concat23TreesOfSameHeight","NodeReader","parseDocument","tokenizer","edits","oldNode","createImmutableLists","parser","Parser","constructor","_itemsConstructed","_itemsFromCache","Error","oldNodeReader","undefined","positionMapper","length","result","parseList","getEmpty","openedBracketIds","items","Array","token","peek","kind","bracketIds","intersects","child","parseChild","childrenLength","push","maxCacheableLength","getDistanceToNextChange","offset","cachedNode","readLongestNodeAt","getOffsetBeforeChange","curNode","canBeReused","skip","read","astNode","set","merge","nextToken","bracketId","create"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits, tokenizer.length);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty());\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds) {\n        const items = new Array();\n        while (true) {\n            const token = this.tokenizer.peek();\n            if (!token ||\n                (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    token.bracketIds.intersects(openedBracketIds))) {\n                break;\n            }\n            const child = this.parseChild(openedBracketIds);\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    parseChild(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (!lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    if (!lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}