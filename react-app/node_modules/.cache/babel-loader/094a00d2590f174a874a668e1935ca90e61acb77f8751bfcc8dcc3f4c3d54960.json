{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n  constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n    super();\n    this._onDidChangeContent = this._register(new Emitter());\n    this._BOM = BOM;\n    this._mightContainNonBasicASCII = !isBasicASCII;\n    this._mightContainRTL = containsRTL;\n    this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n  }\n  mightContainRTL() {\n    return this._mightContainRTL;\n  }\n  mightContainUnusualLineTerminators() {\n    return this._mightContainUnusualLineTerminators;\n  }\n  resetMightContainUnusualLineTerminators() {\n    this._mightContainUnusualLineTerminators = false;\n  }\n  mightContainNonBasicASCII() {\n    return this._mightContainNonBasicASCII;\n  }\n  getBOM() {\n    return this._BOM;\n  }\n  getEOL() {\n    return this._pieceTree.getEOL();\n  }\n  createSnapshot(preserveBOM) {\n    return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n  }\n  getOffsetAt(lineNumber, column) {\n    return this._pieceTree.getOffsetAt(lineNumber, column);\n  }\n  getPositionAt(offset) {\n    return this._pieceTree.getPositionAt(offset);\n  }\n  getRangeAt(start, length) {\n    const end = start + length;\n    const startPosition = this.getPositionAt(start);\n    const endPosition = this.getPositionAt(end);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  }\n  getValueInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (range.isEmpty()) {\n      return '';\n    }\n    const lineEnding = this._getEndOfLine(eol);\n    return this._pieceTree.getValueInRange(range, lineEnding);\n  }\n  getValueLengthInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (range.isEmpty()) {\n      return 0;\n    }\n    if (range.startLineNumber === range.endLineNumber) {\n      return range.endColumn - range.startColumn;\n    }\n    const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n    return endOffset - startOffset;\n  }\n  getCharacterCountInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this._mightContainNonBasicASCII) {\n      // we must count by iterating\n      let result = 0;\n      const fromLineNumber = range.startLineNumber;\n      const toLineNumber = range.endLineNumber;\n      for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n        const lineContent = this.getLineContent(lineNumber);\n        const fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n        const toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;\n        for (let offset = fromOffset; offset < toOffset; offset++) {\n          if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n            result = result + 1;\n            offset = offset + 1;\n          } else {\n            result = result + 1;\n          }\n        }\n      }\n      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n      return result;\n    }\n    return this.getValueLengthInRange(range, eol);\n  }\n  getLength() {\n    return this._pieceTree.getLength();\n  }\n  getLineCount() {\n    return this._pieceTree.getLineCount();\n  }\n  getLinesContent() {\n    return this._pieceTree.getLinesContent();\n  }\n  getLineContent(lineNumber) {\n    return this._pieceTree.getLineContent(lineNumber);\n  }\n  getLineCharCode(lineNumber, index) {\n    return this._pieceTree.getLineCharCode(lineNumber, index);\n  }\n  getLineLength(lineNumber) {\n    return this._pieceTree.getLineLength(lineNumber);\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 1;\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 2;\n  }\n  _getEndOfLine(eol) {\n    switch (eol) {\n      case 1 /* EndOfLinePreference.LF */:\n        return '\\n';\n      case 2 /* EndOfLinePreference.CRLF */:\n        return '\\r\\n';\n      case 0 /* EndOfLinePreference.TextDefined */:\n        return this.getEOL();\n      default:\n        throw new Error('Unknown EOL preference');\n    }\n  }\n  setEOL(newEOL) {\n    this._pieceTree.setEOL(newEOL);\n  }\n  applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n    let mightContainRTL = this._mightContainRTL;\n    let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n    let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n    let canReduceOperations = true;\n    let operations = [];\n    for (let i = 0; i < rawOperations.length; i++) {\n      const op = rawOperations[i];\n      if (canReduceOperations && op._isTracked) {\n        canReduceOperations = false;\n      }\n      const validatedRange = op.range;\n      if (op.text) {\n        let textMightContainNonBasicASCII = true;\n        if (!mightContainNonBasicASCII) {\n          textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n          mightContainNonBasicASCII = textMightContainNonBasicASCII;\n        }\n        if (!mightContainRTL && textMightContainNonBasicASCII) {\n          // check if the new inserted text contains RTL\n          mightContainRTL = strings.containsRTL(op.text);\n        }\n        if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n          // check if the new inserted text contains unusual line terminators\n          mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n        }\n      }\n      let validText = '';\n      let eolCount = 0;\n      let firstLineLength = 0;\n      let lastLineLength = 0;\n      if (op.text) {\n        let strEOL;\n        [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n        const bufferEOL = this.getEOL();\n        const expectedStrEOL = bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */;\n        if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n          validText = op.text;\n        } else {\n          validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n        }\n      }\n      operations[i] = {\n        sortIndex: i,\n        identifier: op.identifier || null,\n        range: validatedRange,\n        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n        rangeLength: this.getValueLengthInRange(validatedRange),\n        text: validText,\n        eolCount: eolCount,\n        firstLineLength: firstLineLength,\n        lastLineLength: lastLineLength,\n        forceMoveMarkers: Boolean(op.forceMoveMarkers),\n        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n      };\n    }\n    // Sort operations ascending\n    operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n    let hasTouchingRanges = false;\n    for (let i = 0, count = operations.length - 1; i < count; i++) {\n      const rangeEnd = operations[i].range.getEndPosition();\n      const nextRangeStart = operations[i + 1].range.getStartPosition();\n      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n        if (nextRangeStart.isBefore(rangeEnd)) {\n          // overlapping ranges\n          throw new Error('Overlapping ranges are not allowed!');\n        }\n        hasTouchingRanges = true;\n      }\n    }\n    if (canReduceOperations) {\n      operations = this._reduceOperations(operations);\n    }\n    // Delta encode operations\n    const reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : [];\n    const newTrimAutoWhitespaceCandidates = [];\n    if (recordTrimAutoWhitespace) {\n      for (let i = 0; i < operations.length; i++) {\n        const op = operations[i];\n        const reverseRange = reverseRanges[i];\n        if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n          // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n          for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n            let currentLineContent = '';\n            if (lineNumber === reverseRange.startLineNumber) {\n              currentLineContent = this.getLineContent(op.range.startLineNumber);\n              if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                continue;\n              }\n            }\n            newTrimAutoWhitespaceCandidates.push({\n              lineNumber: lineNumber,\n              oldContent: currentLineContent\n            });\n          }\n        }\n      }\n    }\n    let reverseOperations = null;\n    if (computeUndoEdits) {\n      let reverseRangeDeltaOffset = 0;\n      reverseOperations = [];\n      for (let i = 0; i < operations.length; i++) {\n        const op = operations[i];\n        const reverseRange = reverseRanges[i];\n        const bufferText = this.getValueInRange(op.range);\n        const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n        reverseRangeDeltaOffset += op.text.length - bufferText.length;\n        reverseOperations[i] = {\n          sortIndex: op.sortIndex,\n          identifier: op.identifier,\n          range: reverseRange,\n          text: bufferText,\n          textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n        };\n      }\n      // Can only sort reverse operations when the order is not significant\n      if (!hasTouchingRanges) {\n        reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n      }\n    }\n    this._mightContainRTL = mightContainRTL;\n    this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n    this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n    const contentChanges = this._doApplyEdits(operations);\n    let trimAutoWhitespaceLineNumbers = null;\n    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n      // sort line numbers auto whitespace removal candidates for next edit descending\n      newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n      trimAutoWhitespaceLineNumbers = [];\n      for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n        const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n          // Do not have the same line number twice\n          continue;\n        }\n        const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n        const lineContent = this.getLineContent(lineNumber);\n        if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n          continue;\n        }\n        trimAutoWhitespaceLineNumbers.push(lineNumber);\n      }\n    }\n    this._onDidChangeContent.fire();\n    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n  }\n  /**\n   * Transform operations such that they represent the same logic edit,\n   * but that they also do not cause OOM crashes.\n   */\n  _reduceOperations(operations) {\n    if (operations.length < 1000) {\n      // We know from empirical testing that a thousand edits work fine regardless of their shape.\n      return operations;\n    }\n    // At one point, due to how events are emitted and how each operation is handled,\n    // some operations can trigger a high amount of temporary string allocations,\n    // that will immediately get edited again.\n    // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n    // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n    return [this._toSingleEditOperation(operations)];\n  }\n  _toSingleEditOperation(operations) {\n    let forceMoveMarkers = false;\n    const firstEditRange = operations[0].range;\n    const lastEditRange = operations[operations.length - 1].range;\n    const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n    let lastEndLineNumber = firstEditRange.startLineNumber;\n    let lastEndColumn = firstEditRange.startColumn;\n    const result = [];\n    for (let i = 0, len = operations.length; i < len; i++) {\n      const operation = operations[i];\n      const range = operation.range;\n      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n      // (1) -- Push old text\n      result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n      // (2) -- Push new text\n      if (operation.text.length > 0) {\n        result.push(operation.text);\n      }\n      lastEndLineNumber = range.endLineNumber;\n      lastEndColumn = range.endColumn;\n    }\n    const text = result.join('');\n    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n    return {\n      sortIndex: 0,\n      identifier: operations[0].identifier,\n      range: entireEditRange,\n      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n      rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n      text: text,\n      eolCount: eolCount,\n      firstLineLength: firstLineLength,\n      lastLineLength: lastLineLength,\n      forceMoveMarkers: forceMoveMarkers,\n      isAutoWhitespaceEdit: false\n    };\n  }\n  _doApplyEdits(operations) {\n    operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n    const contentChanges = [];\n    // operations are from bottom to top\n    for (let i = 0; i < operations.length; i++) {\n      const op = operations[i];\n      const startLineNumber = op.range.startLineNumber;\n      const startColumn = op.range.startColumn;\n      const endLineNumber = op.range.endLineNumber;\n      const endColumn = op.range.endColumn;\n      if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n        // no-op\n        continue;\n      }\n      if (op.text) {\n        // replacement\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n        this._pieceTree.insert(op.rangeOffset, op.text, true);\n      } else {\n        // deletion\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n      }\n      const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      contentChanges.push({\n        range: contentChangeRange,\n        rangeLength: op.rangeLength,\n        text: op.text,\n        rangeOffset: op.rangeOffset,\n        forceMoveMarkers: op.forceMoveMarkers\n      });\n    }\n    return contentChanges;\n  }\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  /**\n   * Assumes `operations` are validated and sorted ascending\n   */\n  static _getInverseEditRanges(operations) {\n    const result = [];\n    let prevOpEndLineNumber = 0;\n    let prevOpEndColumn = 0;\n    let prevOp = null;\n    for (let i = 0, len = operations.length; i < len; i++) {\n      const op = operations[i];\n      let startLineNumber;\n      let startColumn;\n      if (prevOp) {\n        if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n          startLineNumber = prevOpEndLineNumber;\n          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n        } else {\n          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n          startColumn = op.range.startColumn;\n        }\n      } else {\n        startLineNumber = op.range.startLineNumber;\n        startColumn = op.range.startColumn;\n      }\n      let resultRange;\n      if (op.text.length > 0) {\n        // the operation inserts something\n        const lineCount = op.eolCount + 1;\n        if (lineCount === 1) {\n          // single line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n        } else {\n          // multi line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n        }\n      } else {\n        // There is nothing to insert\n        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n      }\n      prevOpEndLineNumber = resultRange.endLineNumber;\n      prevOpEndColumn = resultRange.endColumn;\n      result.push(resultRange);\n      prevOp = op;\n    }\n    return result;\n  }\n  static _sortOpsAscending(a, b) {\n    const r = Range.compareRangesUsingEnds(a.range, b.range);\n    if (r === 0) {\n      return a.sortIndex - b.sortIndex;\n    }\n    return r;\n  }\n  static _sortOpsDescending(a, b) {\n    const r = Range.compareRangesUsingEnds(a.range, b.range);\n    if (r === 0) {\n      return b.sortIndex - a.sortIndex;\n    }\n    return -r;\n  }\n}","map":{"version":3,"names":["Emitter","strings","Range","ApplyEditsResult","PieceTreeBase","countEOL","TextChange","Disposable","PieceTreeTextBuffer","constructor","chunks","BOM","eol","containsRTL","containsUnusualLineTerminators","isBasicASCII","eolNormalized","_onDidChangeContent","_register","_BOM","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","getEOL","createSnapshot","preserveBOM","getOffsetAt","lineNumber","column","getPositionAt","offset","getRangeAt","start","length","end","startPosition","endPosition","getValueInRange","range","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","startLineNumber","endLineNumber","endColumn","startColumn","startOffset","endOffset","getCharacterCountInRange","result","fromLineNumber","toLineNumber","lineContent","getLineContent","fromOffset","toOffset","isHighSurrogate","charCodeAt","getLength","getLineCount","getLinesContent","getLineCharCode","index","getLineLength","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","Error","setEOL","newEOL","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","i","op","_isTracked","validatedRange","text","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","bufferEOL","expectedStrEOL","replace","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","count","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","push","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","len","prevContent","fire","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","join","_sortOpsDescending","delete","insert","contentChangeRange","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","r","compareRangesUsingEnds"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        return endOffset - startOffset;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}