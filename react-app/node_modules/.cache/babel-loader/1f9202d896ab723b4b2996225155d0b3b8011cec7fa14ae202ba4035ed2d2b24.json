{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CSSIcon } from './codicons.js';\nimport { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nexport const iconStartMarker = '$(';\nconst iconsRegex = new RegExp(`\\\\$\\\\(${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\nconst iconNameCharacterRegexp = new RegExp(CSSIcon.iconNameCharacter);\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text) {\n  return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text) {\n  // Need to add an extra \\ for escaping in markdown\n  return text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\nexport function stripIcons(text) {\n  if (text.indexOf(iconStartMarker) === -1) {\n    return text;\n  }\n  return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\nexport function parseLabelWithIcons(text) {\n  const firstIconIndex = text.indexOf(iconStartMarker);\n  if (firstIconIndex === -1) {\n    return {\n      text\n    }; // return early if the word does not include an icon\n  }\n\n  return doParseLabelWithIcons(text, firstIconIndex);\n}\nfunction doParseLabelWithIcons(text, firstIconIndex) {\n  const iconOffsets = [];\n  let textWithoutIcons = '';\n  function appendChars(chars) {\n    if (chars) {\n      textWithoutIcons += chars;\n      for (const _ of chars) {\n        iconOffsets.push(iconsOffset); // make sure to fill in icon offsets\n      }\n    }\n  }\n\n  let currentIconStart = -1;\n  let currentIconValue = '';\n  let iconsOffset = 0;\n  let char;\n  let nextChar;\n  let offset = firstIconIndex;\n  const length = text.length;\n  // Append all characters until the first icon\n  appendChars(text.substr(0, firstIconIndex));\n  // example: $(file-symlink-file) my cool $(other-icon) entry\n  while (offset < length) {\n    char = text[offset];\n    nextChar = text[offset + 1];\n    // beginning of icon: some value $( <--\n    if (char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {\n      currentIconStart = offset;\n      // if we had a previous potential icon value without\n      // the closing ')', it was actually not an icon and\n      // so we have to add it to the actual value\n      appendChars(currentIconValue);\n      currentIconValue = iconStartMarker;\n      offset++; // jump over '('\n    }\n    // end of icon: some value $(some-icon) <--\n    else if (char === ')' && currentIconStart !== -1) {\n      const currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'\n      iconsOffset += currentIconLength;\n      currentIconStart = -1;\n      currentIconValue = '';\n    }\n    // within icon\n    else if (currentIconStart !== -1) {\n      // Make sure this is a real icon name\n      if (iconNameCharacterRegexp.test(char)) {\n        currentIconValue += char;\n      } else {\n        // This is not a real icon, treat it as text\n        appendChars(currentIconValue);\n        currentIconStart = -1;\n        currentIconValue = '';\n      }\n    }\n    // any value outside of icon\n    else {\n      appendChars(char);\n    }\n    offset++;\n  }\n  // if we had a previous potential icon value without\n  // the closing ')', it was actually not an icon and\n  // so we have to add it to the actual value\n  appendChars(currentIconValue);\n  return {\n    text: textWithoutIcons,\n    iconOffsets\n  };\n}\nexport function matchesFuzzyIconAware(query, target) {\n  let enableSeparateSubstringMatching = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const {\n    text,\n    iconOffsets\n  } = target;\n  // Return early if there are no icon markers in the word to match against\n  if (!iconOffsets || iconOffsets.length === 0) {\n    return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n  }\n  // Trim the word to match against because it could have leading\n  // whitespace now if the word started with an icon\n  const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n  const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n  // match on value without icon\n  const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n  // Map matches back to offsets with icon and trimming\n  if (matches) {\n    for (const match of matches) {\n      const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n      match.start += iconOffset;\n      match.end += iconOffset;\n    }\n  }\n  return matches;\n}","map":{"version":3,"names":["CSSIcon","matchesFuzzy","ltrim","iconStartMarker","iconsRegex","RegExp","iconNameExpression","iconModifierExpression","iconNameCharacterRegexp","iconNameCharacter","escapeIconsRegex","source","escapeIcons","text","replace","match","escaped","markdownEscapedIconsRegex","markdownEscapeEscapedIcons","stripIconsRegex","stripIcons","indexOf","preWhitespace","postWhitespace","parseLabelWithIcons","firstIconIndex","doParseLabelWithIcons","iconOffsets","textWithoutIcons","appendChars","chars","_","push","iconsOffset","currentIconStart","currentIconValue","char","nextChar","offset","length","substr","currentIconLength","test","matchesFuzzyIconAware","query","target","enableSeparateSubstringMatching","wordToMatchAgainstWithoutIconsTrimmed","leadingWhitespaceOffset","matches","iconOffset","start","end"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/base/common/iconLabels.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CSSIcon } from './codicons.js';\nimport { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nexport const iconStartMarker = '$(';\nconst iconsRegex = new RegExp(`\\\\$\\\\(${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\nconst iconNameCharacterRegexp = new RegExp(CSSIcon.iconNameCharacter);\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text) {\n    return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text) {\n    // Need to add an extra \\ for escaping in markdown\n    return text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\nexport function stripIcons(text) {\n    if (text.indexOf(iconStartMarker) === -1) {\n        return text;\n    }\n    return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\nexport function parseLabelWithIcons(text) {\n    const firstIconIndex = text.indexOf(iconStartMarker);\n    if (firstIconIndex === -1) {\n        return { text }; // return early if the word does not include an icon\n    }\n    return doParseLabelWithIcons(text, firstIconIndex);\n}\nfunction doParseLabelWithIcons(text, firstIconIndex) {\n    const iconOffsets = [];\n    let textWithoutIcons = '';\n    function appendChars(chars) {\n        if (chars) {\n            textWithoutIcons += chars;\n            for (const _ of chars) {\n                iconOffsets.push(iconsOffset); // make sure to fill in icon offsets\n            }\n        }\n    }\n    let currentIconStart = -1;\n    let currentIconValue = '';\n    let iconsOffset = 0;\n    let char;\n    let nextChar;\n    let offset = firstIconIndex;\n    const length = text.length;\n    // Append all characters until the first icon\n    appendChars(text.substr(0, firstIconIndex));\n    // example: $(file-symlink-file) my cool $(other-icon) entry\n    while (offset < length) {\n        char = text[offset];\n        nextChar = text[offset + 1];\n        // beginning of icon: some value $( <--\n        if (char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {\n            currentIconStart = offset;\n            // if we had a previous potential icon value without\n            // the closing ')', it was actually not an icon and\n            // so we have to add it to the actual value\n            appendChars(currentIconValue);\n            currentIconValue = iconStartMarker;\n            offset++; // jump over '('\n        }\n        // end of icon: some value $(some-icon) <--\n        else if (char === ')' && currentIconStart !== -1) {\n            const currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'\n            iconsOffset += currentIconLength;\n            currentIconStart = -1;\n            currentIconValue = '';\n        }\n        // within icon\n        else if (currentIconStart !== -1) {\n            // Make sure this is a real icon name\n            if (iconNameCharacterRegexp.test(char)) {\n                currentIconValue += char;\n            }\n            else {\n                // This is not a real icon, treat it as text\n                appendChars(currentIconValue);\n                currentIconStart = -1;\n                currentIconValue = '';\n            }\n        }\n        // any value outside of icon\n        else {\n            appendChars(char);\n        }\n        offset++;\n    }\n    // if we had a previous potential icon value without\n    // the closing ')', it was actually not an icon and\n    // so we have to add it to the actual value\n    appendChars(currentIconValue);\n    return { text: textWithoutIcons, iconOffsets };\n}\nexport function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {\n    const { text, iconOffsets } = target;\n    // Return early if there are no icon markers in the word to match against\n    if (!iconOffsets || iconOffsets.length === 0) {\n        return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n    }\n    // Trim the word to match against because it could have leading\n    // whitespace now if the word started with an icon\n    const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n    // match on value without icon\n    const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n    // Map matches back to offsets with icon and trimming\n    if (matches) {\n        for (const match of matches) {\n            const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n            match.start += iconOffset;\n            match.end += iconOffset;\n        }\n    }\n    return matches;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,eAAe;AACvC,SAASC,YAAY,QAAQ,cAAc;AAC3C,SAASC,KAAK,QAAQ,cAAc;AACpC,OAAO,MAAMC,eAAe,GAAG,IAAI;AACnC,MAAMC,UAAU,GAAG,IAAIC,MAAM,CAAE,SAAQL,OAAO,CAACM,kBAAmB,MAAKN,OAAO,CAACO,sBAAuB,OAAM,EAAE,GAAG,CAAC,CAAC,CAAC;AACpH,MAAMC,uBAAuB,GAAG,IAAIH,MAAM,CAACL,OAAO,CAACS,iBAAiB,CAAC;AACrE,MAAMC,gBAAgB,GAAG,IAAIL,MAAM,CAAE,UAASD,UAAU,CAACO,MAAO,EAAC,EAAE,GAAG,CAAC;AACvE,OAAO,SAASC,WAAW,CAACC,IAAI,EAAE;EAC9B,OAAOA,IAAI,CAACC,OAAO,CAACJ,gBAAgB,EAAE,CAACK,KAAK,EAAEC,OAAO,KAAKA,OAAO,GAAGD,KAAK,GAAI,KAAIA,KAAM,EAAC,CAAC;AAC7F;AACA,MAAME,yBAAyB,GAAG,IAAIZ,MAAM,CAAE,OAAMD,UAAU,CAACO,MAAO,EAAC,EAAE,GAAG,CAAC;AAC7E,OAAO,SAASO,0BAA0B,CAACL,IAAI,EAAE;EAC7C;EACA,OAAOA,IAAI,CAACC,OAAO,CAACG,yBAAyB,EAAEF,KAAK,IAAK,KAAIA,KAAM,EAAC,CAAC;AACzE;AACA,MAAMI,eAAe,GAAG,IAAId,MAAM,CAAE,gBAAeD,UAAU,CAACO,MAAO,QAAO,EAAE,GAAG,CAAC;AAClF,OAAO,SAASS,UAAU,CAACP,IAAI,EAAE;EAC7B,IAAIA,IAAI,CAACQ,OAAO,CAAClB,eAAe,CAAC,KAAK,CAAC,CAAC,EAAE;IACtC,OAAOU,IAAI;EACf;EACA,OAAOA,IAAI,CAACC,OAAO,CAACK,eAAe,EAAE,CAACJ,KAAK,EAAEO,aAAa,EAAEN,OAAO,EAAEO,cAAc,KAAKP,OAAO,GAAGD,KAAK,GAAGO,aAAa,IAAIC,cAAc,IAAI,EAAE,CAAC;AACpJ;AACA,OAAO,SAASC,mBAAmB,CAACX,IAAI,EAAE;EACtC,MAAMY,cAAc,GAAGZ,IAAI,CAACQ,OAAO,CAAClB,eAAe,CAAC;EACpD,IAAIsB,cAAc,KAAK,CAAC,CAAC,EAAE;IACvB,OAAO;MAAEZ;IAAK,CAAC,CAAC,CAAC;EACrB;;EACA,OAAOa,qBAAqB,CAACb,IAAI,EAAEY,cAAc,CAAC;AACtD;AACA,SAASC,qBAAqB,CAACb,IAAI,EAAEY,cAAc,EAAE;EACjD,MAAME,WAAW,GAAG,EAAE;EACtB,IAAIC,gBAAgB,GAAG,EAAE;EACzB,SAASC,WAAW,CAACC,KAAK,EAAE;IACxB,IAAIA,KAAK,EAAE;MACPF,gBAAgB,IAAIE,KAAK;MACzB,KAAK,MAAMC,CAAC,IAAID,KAAK,EAAE;QACnBH,WAAW,CAACK,IAAI,CAACC,WAAW,CAAC,CAAC,CAAC;MACnC;IACJ;EACJ;;EACA,IAAIC,gBAAgB,GAAG,CAAC,CAAC;EACzB,IAAIC,gBAAgB,GAAG,EAAE;EACzB,IAAIF,WAAW,GAAG,CAAC;EACnB,IAAIG,IAAI;EACR,IAAIC,QAAQ;EACZ,IAAIC,MAAM,GAAGb,cAAc;EAC3B,MAAMc,MAAM,GAAG1B,IAAI,CAAC0B,MAAM;EAC1B;EACAV,WAAW,CAAChB,IAAI,CAAC2B,MAAM,CAAC,CAAC,EAAEf,cAAc,CAAC,CAAC;EAC3C;EACA,OAAOa,MAAM,GAAGC,MAAM,EAAE;IACpBH,IAAI,GAAGvB,IAAI,CAACyB,MAAM,CAAC;IACnBD,QAAQ,GAAGxB,IAAI,CAACyB,MAAM,GAAG,CAAC,CAAC;IAC3B;IACA,IAAIF,IAAI,KAAKjC,eAAe,CAAC,CAAC,CAAC,IAAIkC,QAAQ,KAAKlC,eAAe,CAAC,CAAC,CAAC,EAAE;MAChE+B,gBAAgB,GAAGI,MAAM;MACzB;MACA;MACA;MACAT,WAAW,CAACM,gBAAgB,CAAC;MAC7BA,gBAAgB,GAAGhC,eAAe;MAClCmC,MAAM,EAAE,CAAC,CAAC;IACd;IACA;IAAA,KACK,IAAIF,IAAI,KAAK,GAAG,IAAIF,gBAAgB,KAAK,CAAC,CAAC,EAAE;MAC9C,MAAMO,iBAAiB,GAAGH,MAAM,GAAGJ,gBAAgB,GAAG,CAAC,CAAC,CAAC;MACzDD,WAAW,IAAIQ,iBAAiB;MAChCP,gBAAgB,GAAG,CAAC,CAAC;MACrBC,gBAAgB,GAAG,EAAE;IACzB;IACA;IAAA,KACK,IAAID,gBAAgB,KAAK,CAAC,CAAC,EAAE;MAC9B;MACA,IAAI1B,uBAAuB,CAACkC,IAAI,CAACN,IAAI,CAAC,EAAE;QACpCD,gBAAgB,IAAIC,IAAI;MAC5B,CAAC,MACI;QACD;QACAP,WAAW,CAACM,gBAAgB,CAAC;QAC7BD,gBAAgB,GAAG,CAAC,CAAC;QACrBC,gBAAgB,GAAG,EAAE;MACzB;IACJ;IACA;IAAA,KACK;MACDN,WAAW,CAACO,IAAI,CAAC;IACrB;IACAE,MAAM,EAAE;EACZ;EACA;EACA;EACA;EACAT,WAAW,CAACM,gBAAgB,CAAC;EAC7B,OAAO;IAAEtB,IAAI,EAAEe,gBAAgB;IAAED;EAAY,CAAC;AAClD;AACA,OAAO,SAASgB,qBAAqB,CAACC,KAAK,EAAEC,MAAM,EAA2C;EAAA,IAAzCC,+BAA+B,uEAAG,KAAK;EACxF,MAAM;IAAEjC,IAAI;IAAEc;EAAY,CAAC,GAAGkB,MAAM;EACpC;EACA,IAAI,CAAClB,WAAW,IAAIA,WAAW,CAACY,MAAM,KAAK,CAAC,EAAE;IAC1C,OAAOtC,YAAY,CAAC2C,KAAK,EAAE/B,IAAI,EAAEiC,+BAA+B,CAAC;EACrE;EACA;EACA;EACA,MAAMC,qCAAqC,GAAG7C,KAAK,CAACW,IAAI,EAAE,GAAG,CAAC;EAC9D,MAAMmC,uBAAuB,GAAGnC,IAAI,CAAC0B,MAAM,GAAGQ,qCAAqC,CAACR,MAAM;EAC1F;EACA,MAAMU,OAAO,GAAGhD,YAAY,CAAC2C,KAAK,EAAEG,qCAAqC,EAAED,+BAA+B,CAAC;EAC3G;EACA,IAAIG,OAAO,EAAE;IACT,KAAK,MAAMlC,KAAK,IAAIkC,OAAO,EAAE;MACzB,MAAMC,UAAU,GAAGvB,WAAW,CAACZ,KAAK,CAACoC,KAAK,GAAGH,uBAAuB,CAAC,CAAC,8BAA8BA,uBAAuB,CAAC;MAC5HjC,KAAK,CAACoC,KAAK,IAAID,UAAU;MACzBnC,KAAK,CAACqC,GAAG,IAAIF,UAAU;IAC3B;EACJ;EACA,OAAOD,OAAO;AAClB"},"metadata":{},"sourceType":"module","externalDependencies":[]}