{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n  constructor(length) {\n    this._length = length;\n  }\n  /**\n   * The length of the entire node, which should equal the sum of lengths of all children.\n  */\n  get length() {\n    return this._length;\n  }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n  constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n    super(length);\n    this.openingBracket = openingBracket;\n    this.child = child;\n    this.closingBracket = closingBracket;\n    this.missingOpeningBracketIds = missingOpeningBracketIds;\n  }\n  static create(openingBracket, child, closingBracket) {\n    let length = openingBracket.length;\n    if (child) {\n      length = lengthAdd(length, child.length);\n    }\n    if (closingBracket) {\n      length = lengthAdd(length, closingBracket.length);\n    }\n    return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n  }\n  get kind() {\n    return 2 /* AstNodeKind.Pair */;\n  }\n\n  get listHeight() {\n    return 0;\n  }\n  get childrenLength() {\n    return 3;\n  }\n  getChild(idx) {\n    switch (idx) {\n      case 0:\n        return this.openingBracket;\n      case 1:\n        return this.child;\n      case 2:\n        return this.closingBracket;\n    }\n    throw new Error('Invalid child index');\n  }\n  /**\n   * Avoid using this property, it allocates an array!\n  */\n  get children() {\n    const result = new Array();\n    result.push(this.openingBracket);\n    if (this.child) {\n      result.push(this.child);\n    }\n    if (this.closingBracket) {\n      result.push(this.closingBracket);\n    }\n    return result;\n  }\n  canBeReused(openBracketIds) {\n    if (this.closingBracket === null) {\n      // Unclosed pair ast nodes only\n      // end at the end of the document\n      // or when a parent node is closed.\n      // This could be improved:\n      // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n      return false;\n    }\n    if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n      return false;\n    }\n    return true;\n  }\n  deepClone() {\n    return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n  }\n  computeMinIndentation(offset, textModel) {\n    return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n  }\n}\nexport class ListAstNode extends BaseAstNode {\n  /**\n   * Use ListAstNode.create.\n  */\n  constructor(length, listHeight, _missingOpeningBracketIds) {\n    super(length);\n    this.listHeight = listHeight;\n    this._missingOpeningBracketIds = _missingOpeningBracketIds;\n    this.cachedMinIndentation = -1;\n  }\n  /**\n   * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n  */\n  static create23(item1, item2, item3) {\n    let immutable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let length = item1.length;\n    let missingBracketIds = item1.missingOpeningBracketIds;\n    if (item1.listHeight !== item2.listHeight) {\n      throw new Error('Invalid list heights');\n    }\n    length = lengthAdd(length, item2.length);\n    missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n    if (item3) {\n      if (item1.listHeight !== item3.listHeight) {\n        throw new Error('Invalid list heights');\n      }\n      length = lengthAdd(length, item3.length);\n      missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n    }\n    return immutable ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds) : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n  }\n  static getEmpty() {\n    return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n  }\n  get kind() {\n    return 4 /* AstNodeKind.List */;\n  }\n\n  get missingOpeningBracketIds() {\n    return this._missingOpeningBracketIds;\n  }\n  throwIfImmutable() {\n    // NOOP\n  }\n  makeLastElementMutable() {\n    this.throwIfImmutable();\n    const childCount = this.childrenLength;\n    if (childCount === 0) {\n      return undefined;\n    }\n    const lastChild = this.getChild(childCount - 1);\n    const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n    if (lastChild !== mutable) {\n      this.setChild(childCount - 1, mutable);\n    }\n    return mutable;\n  }\n  makeFirstElementMutable() {\n    this.throwIfImmutable();\n    const childCount = this.childrenLength;\n    if (childCount === 0) {\n      return undefined;\n    }\n    const firstChild = this.getChild(0);\n    const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n    if (firstChild !== mutable) {\n      this.setChild(0, mutable);\n    }\n    return mutable;\n  }\n  canBeReused(openBracketIds) {\n    if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n      return false;\n    }\n    let lastChild = this;\n    let lastLength;\n    while (lastChild.kind === 4 /* AstNodeKind.List */ && (lastLength = lastChild.childrenLength) > 0) {\n      lastChild = lastChild.getChild(lastLength - 1);\n    }\n    return lastChild.canBeReused(openBracketIds);\n  }\n  handleChildrenChanged() {\n    this.throwIfImmutable();\n    const count = this.childrenLength;\n    let length = this.getChild(0).length;\n    let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n    for (let i = 1; i < count; i++) {\n      const child = this.getChild(i);\n      length = lengthAdd(length, child.length);\n      unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n    }\n    this._length = length;\n    this._missingOpeningBracketIds = unopenedBrackets;\n    this.cachedMinIndentation = -1;\n  }\n  computeMinIndentation(offset, textModel) {\n    if (this.cachedMinIndentation !== -1) {\n      return this.cachedMinIndentation;\n    }\n    let minIndentation = Number.MAX_SAFE_INTEGER;\n    let childOffset = offset;\n    for (let i = 0; i < this.childrenLength; i++) {\n      const child = this.getChild(i);\n      if (child) {\n        minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n        childOffset = lengthAdd(childOffset, child.length);\n      }\n    }\n    this.cachedMinIndentation = minIndentation;\n    return minIndentation;\n  }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n  constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n    super(length, listHeight, missingOpeningBracketIds);\n    this._item1 = _item1;\n    this._item2 = _item2;\n    this._item3 = _item3;\n  }\n  get childrenLength() {\n    return this._item3 !== null ? 3 : 2;\n  }\n  getChild(idx) {\n    switch (idx) {\n      case 0:\n        return this._item1;\n      case 1:\n        return this._item2;\n      case 2:\n        return this._item3;\n    }\n    throw new Error('Invalid child index');\n  }\n  setChild(idx, node) {\n    switch (idx) {\n      case 0:\n        this._item1 = node;\n        return;\n      case 1:\n        this._item2 = node;\n        return;\n      case 2:\n        this._item3 = node;\n        return;\n    }\n    throw new Error('Invalid child index');\n  }\n  get children() {\n    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n  }\n  get item1() {\n    return this._item1;\n  }\n  get item2() {\n    return this._item2;\n  }\n  get item3() {\n    return this._item3;\n  }\n  deepClone() {\n    return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n  }\n  appendChildOfSameHeight(node) {\n    if (this._item3) {\n      throw new Error('Cannot append to a full (2,3) tree node');\n    }\n    this.throwIfImmutable();\n    this._item3 = node;\n    this.handleChildrenChanged();\n  }\n  unappendChild() {\n    if (!this._item3) {\n      throw new Error('Cannot remove from a non-full (2,3) tree node');\n    }\n    this.throwIfImmutable();\n    const result = this._item3;\n    this._item3 = null;\n    this.handleChildrenChanged();\n    return result;\n  }\n  prependChildOfSameHeight(node) {\n    if (this._item3) {\n      throw new Error('Cannot prepend to a full (2,3) tree node');\n    }\n    this.throwIfImmutable();\n    this._item3 = this._item2;\n    this._item2 = this._item1;\n    this._item1 = node;\n    this.handleChildrenChanged();\n  }\n  unprependChild() {\n    if (!this._item3) {\n      throw new Error('Cannot remove from a non-full (2,3) tree node');\n    }\n    this.throwIfImmutable();\n    const result = this._item1;\n    this._item1 = this._item2;\n    this._item2 = this._item3;\n    this._item3 = null;\n    this.handleChildrenChanged();\n    return result;\n  }\n  toMutable() {\n    return this;\n  }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n  toMutable() {\n    return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n  }\n  throwIfImmutable() {\n    throw new Error('this instance is immutable');\n  }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n  constructor(length, listHeight, _children, missingOpeningBracketIds) {\n    super(length, listHeight, missingOpeningBracketIds);\n    this._children = _children;\n  }\n  get childrenLength() {\n    return this._children.length;\n  }\n  getChild(idx) {\n    return this._children[idx];\n  }\n  setChild(idx, child) {\n    this._children[idx] = child;\n  }\n  get children() {\n    return this._children;\n  }\n  deepClone() {\n    const children = new Array(this._children.length);\n    for (let i = 0; i < this._children.length; i++) {\n      children[i] = this._children[i].deepClone();\n    }\n    return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n  }\n  appendChildOfSameHeight(node) {\n    this.throwIfImmutable();\n    this._children.push(node);\n    this.handleChildrenChanged();\n  }\n  unappendChild() {\n    this.throwIfImmutable();\n    const item = this._children.pop();\n    this.handleChildrenChanged();\n    return item;\n  }\n  prependChildOfSameHeight(node) {\n    this.throwIfImmutable();\n    this._children.unshift(node);\n    this.handleChildrenChanged();\n  }\n  unprependChild() {\n    this.throwIfImmutable();\n    const item = this._children.shift();\n    this.handleChildrenChanged();\n    return item;\n  }\n  toMutable() {\n    return this;\n  }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n  toMutable() {\n    return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n  }\n  throwIfImmutable() {\n    throw new Error('this instance is immutable');\n  }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n  get listHeight() {\n    return 0;\n  }\n  get childrenLength() {\n    return 0;\n  }\n  getChild(idx) {\n    return null;\n  }\n  get children() {\n    return emptyArray;\n  }\n  deepClone() {\n    return this;\n  }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n  get kind() {\n    return 0 /* AstNodeKind.Text */;\n  }\n\n  get missingOpeningBracketIds() {\n    return SmallImmutableSet.getEmpty();\n  }\n  canBeReused(_openedBracketIds) {\n    return true;\n  }\n  computeMinIndentation(offset, textModel) {\n    const start = lengthToObj(offset);\n    // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n    // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n    const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n    const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n    let result = Number.MAX_SAFE_INTEGER;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n      const lineContent = textModel.getLineContent(lineNumber);\n      if (firstNonWsColumn === 0) {\n        continue;\n      }\n      const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n      result = Math.min(result, visibleColumn);\n    }\n    return result;\n  }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n  constructor(length, bracketInfo,\n  /**\n   * In case of a opening bracket, this is the id of the opening bracket.\n   * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n  */\n  bracketIds) {\n    super(length);\n    this.bracketInfo = bracketInfo;\n    this.bracketIds = bracketIds;\n  }\n  static create(length, bracketInfo, bracketIds) {\n    const node = new BracketAstNode(length, bracketInfo, bracketIds);\n    return node;\n  }\n  get kind() {\n    return 1 /* AstNodeKind.Bracket */;\n  }\n\n  get missingOpeningBracketIds() {\n    return SmallImmutableSet.getEmpty();\n  }\n  get text() {\n    return this.bracketInfo.bracketText;\n  }\n  get languageId() {\n    return this.bracketInfo.languageId;\n  }\n  canBeReused(_openedBracketIds) {\n    // These nodes could be reused,\n    // but not in a general way.\n    // Their parent may be reused.\n    return false;\n  }\n  computeMinIndentation(offset, textModel) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n  constructor(closingBrackets, length) {\n    super(length);\n    this.missingOpeningBracketIds = closingBrackets;\n  }\n  get kind() {\n    return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n  }\n\n  canBeReused(openedBracketIds) {\n    return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n  }\n  computeMinIndentation(offset, textModel) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n}","map":{"version":3,"names":["CursorColumns","lengthAdd","lengthGetLineCount","lengthToObj","lengthZero","SmallImmutableSet","BaseAstNode","constructor","length","_length","PairAstNode","openingBracket","child","closingBracket","missingOpeningBracketIds","create","getEmpty","kind","listHeight","childrenLength","getChild","idx","Error","children","result","Array","push","canBeReused","openBracketIds","intersects","deepClone","computeMinIndentation","offset","textModel","Number","MAX_SAFE_INTEGER","ListAstNode","_missingOpeningBracketIds","cachedMinIndentation","create23","item1","item2","item3","immutable","missingBracketIds","merge","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","throwIfImmutable","makeLastElementMutable","childCount","undefined","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","handleChildrenChanged","count","unopenedBrackets","i","minIndentation","childOffset","Math","min","_item1","_item2","_item3","node","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","item","pop","unshift","shift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","startLineNumber","columnCount","lineCount","endLineNumber","lineNumber","firstNonWsColumn","getLineFirstNonWhitespaceColumn","lineContent","getLineContent","visibleColumn","visibleColumnFromColumn","getOptions","tabSize","BracketAstNode","bracketInfo","bracketIds","text","bracketText","languageId","InvalidBracketAstNode","closingBrackets","openedBracketIds"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    constructor(length) {\n        this._length = length;\n    }\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = new Array();\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        let lastChild = this;\n        let lastLength;\n        while (lastChild.kind === 4 /* AstNodeKind.List */ && (lastLength = lastChild.childrenLength) > 0) {\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}