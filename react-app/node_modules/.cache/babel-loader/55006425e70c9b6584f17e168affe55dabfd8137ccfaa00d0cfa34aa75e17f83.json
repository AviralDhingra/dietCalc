{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n  TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n  constructor() {\n    this._lastState = null;\n  }\n  set(lastCopiedValue, data) {\n    this._lastState = {\n      lastCopiedValue,\n      data\n    };\n  }\n  get(pastedText) {\n    if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n      // match!\n      return this._lastState.data;\n    }\n    this._lastState = null;\n    return null;\n  }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n  constructor() {\n    this._lastTypeTextLength = 0;\n  }\n  handleCompositionUpdate(text) {\n    text = text || '';\n    const typeInput = {\n      text: text,\n      replacePrevCharCnt: this._lastTypeTextLength,\n      replaceNextCharCnt: 0,\n      positionDelta: 0\n    };\n    this._lastTypeTextLength = text.length;\n    return typeInput;\n  }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n  constructor(_host, _textArea, _OS, _browser) {\n    super();\n    this._host = _host;\n    this._textArea = _textArea;\n    this._OS = _OS;\n    this._browser = _browser;\n    this._onFocus = this._register(new Emitter());\n    this.onFocus = this._onFocus.event;\n    this._onBlur = this._register(new Emitter());\n    this.onBlur = this._onBlur.event;\n    this._onKeyDown = this._register(new Emitter());\n    this.onKeyDown = this._onKeyDown.event;\n    this._onKeyUp = this._register(new Emitter());\n    this.onKeyUp = this._onKeyUp.event;\n    this._onCut = this._register(new Emitter());\n    this.onCut = this._onCut.event;\n    this._onPaste = this._register(new Emitter());\n    this.onPaste = this._onPaste.event;\n    this._onType = this._register(new Emitter());\n    this.onType = this._onType.event;\n    this._onCompositionStart = this._register(new Emitter());\n    this.onCompositionStart = this._onCompositionStart.event;\n    this._onCompositionUpdate = this._register(new Emitter());\n    this.onCompositionUpdate = this._onCompositionUpdate.event;\n    this._onCompositionEnd = this._register(new Emitter());\n    this.onCompositionEnd = this._onCompositionEnd.event;\n    this._onSelectionChangeRequest = this._register(new Emitter());\n    this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n    this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n    this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n    this._textAreaState = TextAreaState.EMPTY;\n    this._selectionChangeListener = null;\n    this.writeScreenReaderContent('ctor');\n    this._hasFocus = false;\n    this._currentComposition = null;\n    let lastKeyDown = null;\n    this._register(this._textArea.onKeyDown(_e => {\n      const e = new StandardKeyboardEvent(_e);\n      if (e.keyCode === 109 /* KeyCode.KEY_IN_COMPOSITION */ || this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n      if (e.equals(9 /* KeyCode.Escape */)) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n      lastKeyDown = e;\n      this._onKeyDown.fire(e);\n    }));\n    this._register(this._textArea.onKeyUp(_e => {\n      const e = new StandardKeyboardEvent(_e);\n      this._onKeyUp.fire(e);\n    }));\n    this._register(this._textArea.onCompositionStart(e => {\n      if (_debugComposition) {\n        console.log(`[compositionstart]`, e);\n      }\n      const currentComposition = new CompositionContext();\n      if (this._currentComposition) {\n        // simply reset the composition context\n        this._currentComposition = currentComposition;\n        return;\n      }\n      this._currentComposition = currentComposition;\n      if (this._OS === 2 /* OperatingSystem.Macintosh */ && lastKeyDown && lastKeyDown.equals(109 /* KeyCode.KEY_IN_COMPOSITION */) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n        // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n        if (_debugComposition) {\n          console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n        }\n        // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n        currentComposition.handleCompositionUpdate('x');\n        this._onCompositionStart.fire({\n          data: e.data\n        });\n        return;\n      }\n      if (this._browser.isAndroid) {\n        // when tapping on the editor, Android enters composition mode to edit the current word\n        // so we cannot clear the textarea on Android and we must pretend the current word was selected\n        this._onCompositionStart.fire({\n          data: e.data\n        });\n        return;\n      }\n      this._onCompositionStart.fire({\n        data: e.data\n      });\n    }));\n    this._register(this._textArea.onCompositionUpdate(e => {\n      if (_debugComposition) {\n        console.log(`[compositionupdate]`, e);\n      }\n      const currentComposition = this._currentComposition;\n      if (!currentComposition) {\n        // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n        return;\n      }\n      if (this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const newState = TextAreaState.readFromTextArea(this._textArea);\n        const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n        this._textAreaState = newState;\n        this._onType.fire(typeInput);\n        this._onCompositionUpdate.fire(e);\n        return;\n      }\n      const typeInput = currentComposition.handleCompositionUpdate(e.data);\n      this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n      this._onType.fire(typeInput);\n      this._onCompositionUpdate.fire(e);\n    }));\n    this._register(this._textArea.onCompositionEnd(e => {\n      if (_debugComposition) {\n        console.log(`[compositionend]`, e);\n      }\n      const currentComposition = this._currentComposition;\n      if (!currentComposition) {\n        // https://github.com/microsoft/monaco-editor/issues/1663\n        // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n        return;\n      }\n      this._currentComposition = null;\n      if (this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const newState = TextAreaState.readFromTextArea(this._textArea);\n        const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n        this._textAreaState = newState;\n        this._onType.fire(typeInput);\n        this._onCompositionEnd.fire();\n        return;\n      }\n      const typeInput = currentComposition.handleCompositionUpdate(e.data);\n      this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n      this._onType.fire(typeInput);\n      this._onCompositionEnd.fire();\n    }));\n    this._register(this._textArea.onInput(e => {\n      if (_debugComposition) {\n        console.log(`[input]`, e);\n      }\n      // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received input event');\n      if (this._currentComposition) {\n        return;\n      }\n      const newState = TextAreaState.readFromTextArea(this._textArea);\n      const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/this._OS === 2 /* OperatingSystem.Macintosh */);\n      if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n        // Ignore invalid input but keep it around for next time\n        return;\n      }\n      this._textAreaState = newState;\n      if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0 || typeInput.replaceNextCharCnt !== 0 || typeInput.positionDelta !== 0) {\n        this._onType.fire(typeInput);\n      }\n    }));\n    // --- Clipboard operations\n    this._register(this._textArea.onCut(e => {\n      // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received cut event');\n      this._ensureClipboardGetsEditorSelection(e);\n      this._asyncTriggerCut.schedule();\n    }));\n    this._register(this._textArea.onCopy(e => {\n      this._ensureClipboardGetsEditorSelection(e);\n    }));\n    this._register(this._textArea.onPaste(e => {\n      // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received paste event');\n      e.preventDefault();\n      if (!e.clipboardData) {\n        return;\n      }\n      let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n      if (!text) {\n        return;\n      }\n      // try the in-memory store\n      metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n      this._onPaste.fire({\n        text: text,\n        metadata: metadata\n      });\n    }));\n    this._register(this._textArea.onFocus(() => {\n      const hadFocus = this._hasFocus;\n      this._setHasFocus(true);\n      if (this._browser.isSafari && !hadFocus && this._hasFocus) {\n        // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n        // Safari will always move the selection at offset 0 in the textarea\n        this._asyncFocusGainWriteScreenReaderContent.schedule();\n      }\n    }));\n    this._register(this._textArea.onBlur(() => {\n      if (this._currentComposition) {\n        // See https://github.com/microsoft/vscode/issues/112621\n        // where compositionend is not triggered when the editor\n        // is taken off-dom during a composition\n        // Clear the flag to be able to write to the textarea\n        this._currentComposition = null;\n        // Clear the textarea to avoid an unwanted cursor type\n        this.writeScreenReaderContent('blurWithoutCompositionEnd');\n        // Fire artificial composition end\n        this._onCompositionEnd.fire();\n      }\n      this._setHasFocus(false);\n    }));\n    this._register(this._textArea.onSyntheticTap(() => {\n      if (this._browser.isAndroid && this._currentComposition) {\n        // on Android, tapping does not cancel the current composition, so the\n        // textarea is stuck showing the old composition\n        // Clear the flag to be able to write to the textarea\n        this._currentComposition = null;\n        // Clear the textarea to avoid an unwanted cursor type\n        this.writeScreenReaderContent('tapWithoutCompositionEnd');\n        // Fire artificial composition end\n        this._onCompositionEnd.fire();\n      }\n    }));\n  }\n  _installSelectionChangeListener() {\n    // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n    // When using a Braille display, it is possible for users to reposition the\n    // system caret. This is reflected in Chrome as a `selectionchange` event.\n    //\n    // The `selectionchange` event appears to be emitted under numerous other circumstances,\n    // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n    // using a Braille display from all the other cases.\n    //\n    // The problems with the `selectionchange` event are:\n    //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n    //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n    //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n    //  * the event is emitted when tabbing into the textarea\n    //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n    //  * the event sometimes comes in bursts for a single logical textarea operation\n    // `selectionchange` events often come multiple times for a single logical change\n    // so throttle multiple `selectionchange` events that burst in a short period of time.\n    let previousSelectionChangeEventTime = 0;\n    return dom.addDisposableListener(document, 'selectionchange', e => {\n      if (!this._hasFocus) {\n        return;\n      }\n      if (this._currentComposition) {\n        return;\n      }\n      if (!this._browser.isChrome) {\n        // Support only for Chrome until testing happens on other browsers\n        return;\n      }\n      const now = Date.now();\n      const delta1 = now - previousSelectionChangeEventTime;\n      previousSelectionChangeEventTime = now;\n      if (delta1 < 5) {\n        // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n        // => ignore it\n        return;\n      }\n      const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n      this._textArea.resetSelectionChangeTime();\n      if (delta2 < 100) {\n        // received a `selectionchange` event within 100ms since we touched the textarea\n        // => ignore it, since we caused it\n        return;\n      }\n      if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n      const newValue = this._textArea.getValue();\n      if (this._textAreaState.value !== newValue) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n      const newSelectionStart = this._textArea.getSelectionStart();\n      const newSelectionEnd = this._textArea.getSelectionEnd();\n      if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n        // Nothing to do...\n        return;\n      }\n      const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n      const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n      const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n      const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n      const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n      this._onSelectionChangeRequest.fire(newSelection);\n    });\n  }\n  dispose() {\n    super.dispose();\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n      this._selectionChangeListener = null;\n    }\n  }\n  focusTextArea() {\n    // Setting this._hasFocus and writing the screen reader content\n    // will result in a focus() and setSelectionRange() in the textarea\n    this._setHasFocus(true);\n    // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n    this.refreshFocusState();\n  }\n  isFocused() {\n    return this._hasFocus;\n  }\n  refreshFocusState() {\n    this._setHasFocus(this._textArea.hasFocus());\n  }\n  _setHasFocus(newHasFocus) {\n    if (this._hasFocus === newHasFocus) {\n      // no change\n      return;\n    }\n    this._hasFocus = newHasFocus;\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n      this._selectionChangeListener = null;\n    }\n    if (this._hasFocus) {\n      this._selectionChangeListener = this._installSelectionChangeListener();\n    }\n    if (this._hasFocus) {\n      this.writeScreenReaderContent('focusgain');\n    }\n    if (this._hasFocus) {\n      this._onFocus.fire();\n    } else {\n      this._onBlur.fire();\n    }\n  }\n  _setAndWriteTextAreaState(reason, textAreaState) {\n    if (!this._hasFocus) {\n      textAreaState = textAreaState.collapseSelection();\n    }\n    textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n    this._textAreaState = textAreaState;\n  }\n  writeScreenReaderContent(reason) {\n    if (this._currentComposition) {\n      // Do not write to the text area when doing composition\n      return;\n    }\n    this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n  }\n  _ensureClipboardGetsEditorSelection(e) {\n    const dataToCopy = this._host.getDataToCopy();\n    const storedMetadata = {\n      version: 1,\n      isFromEmptySelection: dataToCopy.isFromEmptySelection,\n      multicursorText: dataToCopy.multicursorText,\n      mode: dataToCopy.mode\n    };\n    InMemoryClipboardMetadataManager.INSTANCE.set(\n    // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n    // Firefox pastes \"LINE\\n\", so let's work around this quirk\n    this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text, storedMetadata);\n    e.preventDefault();\n    if (e.clipboardData) {\n      ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n    }\n  }\n}\nclass ClipboardEventUtils {\n  static getTextData(clipboardData) {\n    const text = clipboardData.getData(Mimes.text);\n    let metadata = null;\n    const rawmetadata = clipboardData.getData('vscode-editor-data');\n    if (typeof rawmetadata === 'string') {\n      try {\n        metadata = JSON.parse(rawmetadata);\n        if (metadata.version !== 1) {\n          metadata = null;\n        }\n      } catch (err) {\n        // no problem!\n      }\n    }\n    if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n      // no textual data pasted, generate text from file names\n      const files = Array.prototype.slice.call(clipboardData.files, 0);\n      return [files.map(file => file.name).join('\\n'), null];\n    }\n    return [text, metadata];\n  }\n  static setTextData(clipboardData, text, html, metadata) {\n    clipboardData.setData(Mimes.text, text);\n    if (typeof html === 'string') {\n      clipboardData.setData('text/html', html);\n    }\n    clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n  }\n}\nexport class TextAreaWrapper extends Disposable {\n  constructor(_actual) {\n    super();\n    this._actual = _actual;\n    this.onKeyDown = this._register(dom.createEventEmitter(this._actual, 'keydown')).event;\n    this.onKeyUp = this._register(dom.createEventEmitter(this._actual, 'keyup')).event;\n    this.onCompositionStart = this._register(dom.createEventEmitter(this._actual, 'compositionstart')).event;\n    this.onCompositionUpdate = this._register(dom.createEventEmitter(this._actual, 'compositionupdate')).event;\n    this.onCompositionEnd = this._register(dom.createEventEmitter(this._actual, 'compositionend')).event;\n    this.onInput = this._register(dom.createEventEmitter(this._actual, 'input')).event;\n    this.onCut = this._register(dom.createEventEmitter(this._actual, 'cut')).event;\n    this.onCopy = this._register(dom.createEventEmitter(this._actual, 'copy')).event;\n    this.onPaste = this._register(dom.createEventEmitter(this._actual, 'paste')).event;\n    this.onFocus = this._register(dom.createEventEmitter(this._actual, 'focus')).event;\n    this.onBlur = this._register(dom.createEventEmitter(this._actual, 'blur')).event;\n    this._onSyntheticTap = this._register(new Emitter());\n    this.onSyntheticTap = this._onSyntheticTap.event;\n    this._ignoreSelectionChangeTime = 0;\n    this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n  }\n  hasFocus() {\n    const shadowRoot = dom.getShadowRoot(this._actual);\n    if (shadowRoot) {\n      return shadowRoot.activeElement === this._actual;\n    } else if (dom.isInDOM(this._actual)) {\n      return document.activeElement === this._actual;\n    } else {\n      return false;\n    }\n  }\n  setIgnoreSelectionChangeTime(reason) {\n    this._ignoreSelectionChangeTime = Date.now();\n  }\n  getIgnoreSelectionChangeTime() {\n    return this._ignoreSelectionChangeTime;\n  }\n  resetSelectionChangeTime() {\n    this._ignoreSelectionChangeTime = 0;\n  }\n  getValue() {\n    // console.log('current value: ' + this._textArea.value);\n    return this._actual.value;\n  }\n  setValue(reason, value) {\n    const textArea = this._actual;\n    if (textArea.value === value) {\n      // No change\n      return;\n    }\n    // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n    this.setIgnoreSelectionChangeTime('setValue');\n    textArea.value = value;\n  }\n  getSelectionStart() {\n    return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n  }\n  getSelectionEnd() {\n    return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n  }\n  setSelectionRange(reason, selectionStart, selectionEnd) {\n    const textArea = this._actual;\n    let activeElement = null;\n    const shadowRoot = dom.getShadowRoot(textArea);\n    if (shadowRoot) {\n      activeElement = shadowRoot.activeElement;\n    } else {\n      activeElement = document.activeElement;\n    }\n    const currentIsFocused = activeElement === textArea;\n    const currentSelectionStart = textArea.selectionStart;\n    const currentSelectionEnd = textArea.selectionEnd;\n    if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n      // No change\n      // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n      return;\n    }\n    // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n    if (currentIsFocused) {\n      // No need to focus, only need to change the selection range\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n      return;\n    }\n    // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n    // Here, we try to undo the browser's desperate reveal.\n    try {\n      const scrollState = dom.saveParentsScrollTop(textArea);\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.focus();\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      dom.restoreParentsScrollTop(textArea, scrollState);\n    } catch (e) {\n      // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n    }\n  }\n}","map":{"version":3,"names":["browser","dom","StandardKeyboardEvent","RunOnceScheduler","Emitter","Disposable","Mimes","strings","TextAreaState","_debugComposition","Selection","TextAreaSyntethicEvents","Tap","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","constructor","_lastState","set","lastCopiedValue","data","get","pastedText","INSTANCE","CompositionContext","_lastTypeTextLength","handleCompositionUpdate","text","typeInput","replacePrevCharCnt","replaceNextCharCnt","positionDelta","length","TextAreaInput","_host","_textArea","_OS","_browser","_onFocus","_register","onFocus","event","_onBlur","onBlur","_onKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_asyncTriggerCut","fire","_asyncFocusGainWriteScreenReaderContent","writeScreenReaderContent","_textAreaState","EMPTY","_selectionChangeListener","_hasFocus","_currentComposition","lastKeyDown","_e","e","keyCode","stopPropagation","equals","preventDefault","console","log","currentComposition","selectionStart","selectionEnd","value","substr","code","isAndroid","newState","readFromTextArea","deduceAndroidCompositionInput","onInput","setIgnoreSelectionChangeTime","deduceInput","isHighSurrogate","charCodeAt","_ensureClipboardGetsEditorSelection","schedule","onCopy","clipboardData","metadata","ClipboardEventUtils","getTextData","hadFocus","_setHasFocus","isSafari","onSyntheticTap","_installSelectionChangeListener","previousSelectionChangeEventTime","addDisposableListener","document","isChrome","now","Date","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","selectionStartPosition","selectionEndPosition","newValue","getValue","newSelectionStart","getSelectionStart","newSelectionEnd","getSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","newSelection","lineNumber","column","dispose","focusTextArea","refreshFocusState","isFocused","hasFocus","newHasFocus","_setAndWriteTextAreaState","reason","textAreaState","collapseSelection","writeToTextArea","getScreenReaderContent","dataToCopy","getDataToCopy","storedMetadata","version","isFromEmptySelection","multicursorText","mode","isFirefox","replace","setTextData","html","getData","rawmetadata","JSON","parse","err","files","Array","prototype","slice","call","map","file","name","join","setData","stringify","TextAreaWrapper","_actual","createEventEmitter","_onSyntheticTap","_ignoreSelectionChangeTime","shadowRoot","getShadowRoot","activeElement","isInDOM","setValue","textArea","selectionDirection","setSelectionRange","currentIsFocused","currentSelectionStart","currentSelectionEnd","window","parent","focus","scrollState","saveParentsScrollTop","restoreParentsScrollTop"],"sources":["/home/deathblade287/Desktop/AI-MODELS-TESTING/react-app/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n    constructor() {\n        this._lastTypeTextLength = 0;\n    }\n    handleCompositionUpdate(text) {\n        text = text || '';\n        const typeInput = {\n            text: text,\n            replacePrevCharCnt: this._lastTypeTextLength,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n        this._lastTypeTextLength = text.length;\n        return typeInput;\n    }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n    constructor(_host, _textArea, _OS, _browser) {\n        super();\n        this._host = _host;\n        this._textArea = _textArea;\n        this._OS = _OS;\n        this._browser = _browser;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        this.writeScreenReaderContent('ctor');\n        this._hasFocus = false;\n        this._currentComposition = null;\n        let lastKeyDown = null;\n        this._register(this._textArea.onKeyDown((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            if (e.keyCode === 109 /* KeyCode.KEY_IN_COMPOSITION */\n                || (this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* KeyCode.Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(this._textArea.onKeyUp((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            this._onKeyUp.fire(e);\n        }));\n        this._register(this._textArea.onCompositionStart((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            const currentComposition = new CompositionContext();\n            if (this._currentComposition) {\n                // simply reset the composition context\n                this._currentComposition = currentComposition;\n                return;\n            }\n            this._currentComposition = currentComposition;\n            if (this._OS === 2 /* OperatingSystem.Macintosh */\n                && lastKeyDown\n                && lastKeyDown.equals(109 /* KeyCode.KEY_IN_COMPOSITION */)\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data\n                && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n                // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                if (_debugComposition) {\n                    console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n                }\n                // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n                currentComposition.handleCompositionUpdate('x');\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            this._onCompositionStart.fire({ data: e.data });\n        }));\n        this._register(this._textArea.onCompositionUpdate((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(this._textArea.onCompositionEnd((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // https://github.com/microsoft/monaco-editor/issues/1663\n                // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n                return;\n            }\n            this._currentComposition = null;\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n            this._onType.fire(typeInput);\n            this._onCompositionEnd.fire();\n        }));\n        this._register(this._textArea.onInput((e) => {\n            if (_debugComposition) {\n                console.log(`[input]`, e);\n            }\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._currentComposition) {\n                return;\n            }\n            const newState = TextAreaState.readFromTextArea(this._textArea);\n            const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/ this._OS === 2 /* OperatingSystem.Macintosh */);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n                // Ignore invalid input but keep it around for next time\n                return;\n            }\n            this._textAreaState = newState;\n            if (typeInput.text !== ''\n                || typeInput.replacePrevCharCnt !== 0\n                || typeInput.replaceNextCharCnt !== 0\n                || typeInput.positionDelta !== 0) {\n                this._onType.fire(typeInput);\n            }\n        }));\n        // --- Clipboard operations\n        this._register(this._textArea.onCut((e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(this._textArea.onCopy((e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(this._textArea.onPaste((e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            e.preventDefault();\n            if (!e.clipboardData) {\n                return;\n            }\n            let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n            if (!text) {\n                return;\n            }\n            // try the in-memory store\n            metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n            this._onPaste.fire({\n                text: text,\n                metadata: metadata\n            });\n        }));\n        this._register(this._textArea.onFocus(() => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (this._browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                this._asyncFocusGainWriteScreenReaderContent.schedule();\n            }\n        }));\n        this._register(this._textArea.onBlur(() => {\n            if (this._currentComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(this._textArea.onSyntheticTap(() => {\n            if (this._browser.isAndroid && this._currentComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(document, 'selectionchange', (e) => {\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._currentComposition) {\n                return;\n            }\n            if (!this._browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        this._setHasFocus(this._textArea.hasFocus());\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeScreenReaderContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeScreenReaderContent(reason) {\n        if (this._currentComposition) {\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy();\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        e.preventDefault();\n        if (e.clipboardData) {\n            ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n        }\n    }\n}\nclass ClipboardEventUtils {\n    static getTextData(clipboardData) {\n        const text = clipboardData.getData(Mimes.text);\n        let metadata = null;\n        const rawmetadata = clipboardData.getData('vscode-editor-data');\n        if (typeof rawmetadata === 'string') {\n            try {\n                metadata = JSON.parse(rawmetadata);\n                if (metadata.version !== 1) {\n                    metadata = null;\n                }\n            }\n            catch (err) {\n                // no problem!\n            }\n        }\n        if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n            // no textual data pasted, generate text from file names\n            const files = Array.prototype.slice.call(clipboardData.files, 0);\n            return [files.map(file => file.name).join('\\n'), null];\n        }\n        return [text, metadata];\n    }\n    static setTextData(clipboardData, text, html, metadata) {\n        clipboardData.setData(Mimes.text, text);\n        if (typeof html === 'string') {\n            clipboardData.setData('text/html', html);\n        }\n        clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n    }\n}\nexport class TextAreaWrapper extends Disposable {\n    constructor(_actual) {\n        super();\n        this._actual = _actual;\n        this.onKeyDown = this._register(dom.createEventEmitter(this._actual, 'keydown')).event;\n        this.onKeyUp = this._register(dom.createEventEmitter(this._actual, 'keyup')).event;\n        this.onCompositionStart = this._register(dom.createEventEmitter(this._actual, 'compositionstart')).event;\n        this.onCompositionUpdate = this._register(dom.createEventEmitter(this._actual, 'compositionupdate')).event;\n        this.onCompositionEnd = this._register(dom.createEventEmitter(this._actual, 'compositionend')).event;\n        this.onInput = this._register(dom.createEventEmitter(this._actual, 'input')).event;\n        this.onCut = this._register(dom.createEventEmitter(this._actual, 'cut')).event;\n        this.onCopy = this._register(dom.createEventEmitter(this._actual, 'copy')).event;\n        this.onPaste = this._register(dom.createEventEmitter(this._actual, 'paste')).event;\n        this.onFocus = this._register(dom.createEventEmitter(this._actual, 'focus')).event;\n        this.onBlur = this._register(dom.createEventEmitter(this._actual, 'blur')).event;\n        this._onSyntheticTap = this._register(new Emitter());\n        this.onSyntheticTap = this._onSyntheticTap.event;\n        this._ignoreSelectionChangeTime = 0;\n        this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n    }\n    hasFocus() {\n        const shadowRoot = dom.getShadowRoot(this._actual);\n        if (shadowRoot) {\n            return shadowRoot.activeElement === this._actual;\n        }\n        else if (dom.isInDOM(this._actual)) {\n            return document.activeElement === this._actual;\n        }\n        else {\n            return false;\n        }\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = document.activeElement;\n        }\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAO,MAAM,kCAAkC;AAC3D,OAAO,KAAKC,GAAG,MAAM,8BAA8B;AACnD,SAASC,qBAAqB,QAAQ,wCAAwC;AAC9E,SAASC,gBAAgB,QAAQ,+BAA+B;AAChE,SAASC,OAAO,QAAQ,+BAA+B;AACvD,SAASC,UAAU,QAAQ,mCAAmC;AAC9D,SAASC,KAAK,QAAQ,8BAA8B;AACpD,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,SAASC,aAAa,EAAEC,iBAAiB,QAAQ,oBAAoB;AACrE,SAASC,SAAS,QAAQ,gCAAgC;AAC1D,OAAO,IAAIC,uBAAuB;AAClC,CAAC,UAAUA,uBAAuB,EAAE;EAChCA,uBAAuB,CAACC,GAAG,GAAG,gCAAgC;AAClE,CAAC,EAAED,uBAAuB,KAAKA,uBAAuB,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7D,OAAO,MAAME,WAAW,GAAG;EACvBC,+BAA+B,EAAE;AACrC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gCAAgC,CAAC;EAC1CC,WAAW,GAAG;IACV,IAAI,CAACC,UAAU,GAAG,IAAI;EAC1B;EACAC,GAAG,CAACC,eAAe,EAAEC,IAAI,EAAE;IACvB,IAAI,CAACH,UAAU,GAAG;MAAEE,eAAe;MAAEC;IAAK,CAAC;EAC/C;EACAC,GAAG,CAACC,UAAU,EAAE;IACZ,IAAI,IAAI,CAACL,UAAU,IAAI,IAAI,CAACA,UAAU,CAACE,eAAe,KAAKG,UAAU,EAAE;MACnE;MACA,OAAO,IAAI,CAACL,UAAU,CAACG,IAAI;IAC/B;IACA,IAAI,CAACH,UAAU,GAAG,IAAI;IACtB,OAAO,IAAI;EACf;AACJ;AACAF,gCAAgC,CAACQ,QAAQ,GAAG,IAAIR,gCAAgC,EAAE;AAClF,MAAMS,kBAAkB,CAAC;EACrBR,WAAW,GAAG;IACV,IAAI,CAACS,mBAAmB,GAAG,CAAC;EAChC;EACAC,uBAAuB,CAACC,IAAI,EAAE;IAC1BA,IAAI,GAAGA,IAAI,IAAI,EAAE;IACjB,MAAMC,SAAS,GAAG;MACdD,IAAI,EAAEA,IAAI;MACVE,kBAAkB,EAAE,IAAI,CAACJ,mBAAmB;MAC5CK,kBAAkB,EAAE,CAAC;MACrBC,aAAa,EAAE;IACnB,CAAC;IACD,IAAI,CAACN,mBAAmB,GAAGE,IAAI,CAACK,MAAM;IACtC,OAAOJ,SAAS;EACpB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,aAAa,SAAS5B,UAAU,CAAC;EAC1CW,WAAW,CAACkB,KAAK,EAAEC,SAAS,EAAEC,GAAG,EAAEC,QAAQ,EAAE;IACzC,KAAK,EAAE;IACP,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACC,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IAC7C,IAAI,CAACoC,OAAO,GAAG,IAAI,CAACF,QAAQ,CAACG,KAAK;IAClC,IAAI,CAACC,OAAO,GAAG,IAAI,CAACH,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IAC5C,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACD,OAAO,CAACD,KAAK;IAChC,IAAI,CAACG,UAAU,GAAG,IAAI,CAACL,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IAC/C,IAAI,CAACyC,SAAS,GAAG,IAAI,CAACD,UAAU,CAACH,KAAK;IACtC,IAAI,CAACK,QAAQ,GAAG,IAAI,CAACP,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IAC7C,IAAI,CAAC2C,OAAO,GAAG,IAAI,CAACD,QAAQ,CAACL,KAAK;IAClC,IAAI,CAACO,MAAM,GAAG,IAAI,CAACT,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IAC3C,IAAI,CAAC6C,KAAK,GAAG,IAAI,CAACD,MAAM,CAACP,KAAK;IAC9B,IAAI,CAACS,QAAQ,GAAG,IAAI,CAACX,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IAC7C,IAAI,CAAC+C,OAAO,GAAG,IAAI,CAACD,QAAQ,CAACT,KAAK;IAClC,IAAI,CAACW,OAAO,GAAG,IAAI,CAACb,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IAC5C,IAAI,CAACiD,MAAM,GAAG,IAAI,CAACD,OAAO,CAACX,KAAK;IAChC,IAAI,CAACa,mBAAmB,GAAG,IAAI,CAACf,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IACxD,IAAI,CAACmD,kBAAkB,GAAG,IAAI,CAACD,mBAAmB,CAACb,KAAK;IACxD,IAAI,CAACe,oBAAoB,GAAG,IAAI,CAACjB,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IACzD,IAAI,CAACqD,mBAAmB,GAAG,IAAI,CAACD,oBAAoB,CAACf,KAAK;IAC1D,IAAI,CAACiB,iBAAiB,GAAG,IAAI,CAACnB,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IACtD,IAAI,CAACuD,gBAAgB,GAAG,IAAI,CAACD,iBAAiB,CAACjB,KAAK;IACpD,IAAI,CAACmB,yBAAyB,GAAG,IAAI,CAACrB,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IAC9D,IAAI,CAACyD,wBAAwB,GAAG,IAAI,CAACD,yBAAyB,CAACnB,KAAK;IACpE,IAAI,CAACqB,gBAAgB,GAAG,IAAI,CAACvB,SAAS,CAAC,IAAIpC,gBAAgB,CAAC,MAAM,IAAI,CAAC6C,MAAM,CAACe,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC;IACzF,IAAI,CAACC,uCAAuC,GAAG,IAAI,CAACzB,SAAS,CAAC,IAAIpC,gBAAgB,CAAC,MAAM,IAAI,CAAC8D,wBAAwB,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7I,IAAI,CAACC,cAAc,GAAG1D,aAAa,CAAC2D,KAAK;IACzC,IAAI,CAACC,wBAAwB,GAAG,IAAI;IACpC,IAAI,CAACH,wBAAwB,CAAC,MAAM,CAAC;IACrC,IAAI,CAACI,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAC/B,IAAIC,WAAW,GAAG,IAAI;IACtB,IAAI,CAAChC,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACU,SAAS,CAAE2B,EAAE,IAAK;MAC5C,MAAMC,CAAC,GAAG,IAAIvE,qBAAqB,CAACsE,EAAE,CAAC;MACvC,IAAIC,CAAC,CAACC,OAAO,KAAK,GAAG,CAAC,oCACd,IAAI,CAACJ,mBAAmB,IAAIG,CAAC,CAACC,OAAO,KAAK,CAAC,CAAC,uBAAwB,EAAE;QAC1E;QACAD,CAAC,CAACE,eAAe,EAAE;MACvB;MACA,IAAIF,CAAC,CAACG,MAAM,CAAC,CAAC,CAAC,qBAAqB,EAAE;QAClC;QACA;QACAH,CAAC,CAACI,cAAc,EAAE;MACtB;MACAN,WAAW,GAAGE,CAAC;MACf,IAAI,CAAC7B,UAAU,CAACmB,IAAI,CAACU,CAAC,CAAC;IAC3B,CAAC,CAAC,CAAC;IACH,IAAI,CAAClC,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACY,OAAO,CAAEyB,EAAE,IAAK;MAC1C,MAAMC,CAAC,GAAG,IAAIvE,qBAAqB,CAACsE,EAAE,CAAC;MACvC,IAAI,CAAC1B,QAAQ,CAACiB,IAAI,CAACU,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IACH,IAAI,CAAClC,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACoB,kBAAkB,CAAEkB,CAAC,IAAK;MACpD,IAAIhE,iBAAiB,EAAE;QACnBqE,OAAO,CAACC,GAAG,CAAE,oBAAmB,EAAEN,CAAC,CAAC;MACxC;MACA,MAAMO,kBAAkB,GAAG,IAAIxD,kBAAkB,EAAE;MACnD,IAAI,IAAI,CAAC8C,mBAAmB,EAAE;QAC1B;QACA,IAAI,CAACA,mBAAmB,GAAGU,kBAAkB;QAC7C;MACJ;MACA,IAAI,CAACV,mBAAmB,GAAGU,kBAAkB;MAC7C,IAAI,IAAI,CAAC5C,GAAG,KAAK,CAAC,CAAC,mCACZmC,WAAW,IACXA,WAAW,CAACK,MAAM,CAAC,GAAG,CAAC,iCAAiC,IACxD,IAAI,CAACV,cAAc,CAACe,cAAc,KAAK,IAAI,CAACf,cAAc,CAACgB,YAAY,IACvE,IAAI,CAAChB,cAAc,CAACe,cAAc,GAAG,CAAC,IACtC,IAAI,CAACf,cAAc,CAACiB,KAAK,CAACC,MAAM,CAAC,IAAI,CAAClB,cAAc,CAACe,cAAc,GAAG,CAAC,EAAE,CAAC,CAAC,KAAKR,CAAC,CAACrD,IAAI,KACrFmD,WAAW,CAACc,IAAI,KAAK,YAAY,IAAId,WAAW,CAACc,IAAI,KAAK,WAAW,CAAC,EAAE;QAC5E;QACA,IAAI5E,iBAAiB,EAAE;UACnBqE,OAAO,CAACC,GAAG,CAAE,kEAAiE,EAAEN,CAAC,CAAC;QACtF;QACA;QACAO,kBAAkB,CAACtD,uBAAuB,CAAC,GAAG,CAAC;QAC/C,IAAI,CAAC4B,mBAAmB,CAACS,IAAI,CAAC;UAAE3C,IAAI,EAAEqD,CAAC,CAACrD;QAAK,CAAC,CAAC;QAC/C;MACJ;MACA,IAAI,IAAI,CAACiB,QAAQ,CAACiD,SAAS,EAAE;QACzB;QACA;QACA,IAAI,CAAChC,mBAAmB,CAACS,IAAI,CAAC;UAAE3C,IAAI,EAAEqD,CAAC,CAACrD;QAAK,CAAC,CAAC;QAC/C;MACJ;MACA,IAAI,CAACkC,mBAAmB,CAACS,IAAI,CAAC;QAAE3C,IAAI,EAAEqD,CAAC,CAACrD;MAAK,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC;IACH,IAAI,CAACmB,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACsB,mBAAmB,CAAEgB,CAAC,IAAK;MACrD,IAAIhE,iBAAiB,EAAE;QACnBqE,OAAO,CAACC,GAAG,CAAE,qBAAoB,EAAEN,CAAC,CAAC;MACzC;MACA,MAAMO,kBAAkB,GAAG,IAAI,CAACV,mBAAmB;MACnD,IAAI,CAACU,kBAAkB,EAAE;QACrB;QACA;MACJ;MACA,IAAI,IAAI,CAAC3C,QAAQ,CAACiD,SAAS,EAAE;QACzB;QACA;QACA;QACA;QACA,MAAMC,QAAQ,GAAG/E,aAAa,CAACgF,gBAAgB,CAAC,IAAI,CAACrD,SAAS,CAAC;QAC/D,MAAMP,SAAS,GAAGpB,aAAa,CAACiF,6BAA6B,CAAC,IAAI,CAACvB,cAAc,EAAEqB,QAAQ,CAAC;QAC5F,IAAI,CAACrB,cAAc,GAAGqB,QAAQ;QAC9B,IAAI,CAACnC,OAAO,CAACW,IAAI,CAACnC,SAAS,CAAC;QAC5B,IAAI,CAAC4B,oBAAoB,CAACO,IAAI,CAACU,CAAC,CAAC;QACjC;MACJ;MACA,MAAM7C,SAAS,GAAGoD,kBAAkB,CAACtD,uBAAuB,CAAC+C,CAAC,CAACrD,IAAI,CAAC;MACpE,IAAI,CAAC8C,cAAc,GAAG1D,aAAa,CAACgF,gBAAgB,CAAC,IAAI,CAACrD,SAAS,CAAC;MACpE,IAAI,CAACiB,OAAO,CAACW,IAAI,CAACnC,SAAS,CAAC;MAC5B,IAAI,CAAC4B,oBAAoB,CAACO,IAAI,CAACU,CAAC,CAAC;IACrC,CAAC,CAAC,CAAC;IACH,IAAI,CAAClC,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACwB,gBAAgB,CAAEc,CAAC,IAAK;MAClD,IAAIhE,iBAAiB,EAAE;QACnBqE,OAAO,CAACC,GAAG,CAAE,kBAAiB,EAAEN,CAAC,CAAC;MACtC;MACA,MAAMO,kBAAkB,GAAG,IAAI,CAACV,mBAAmB;MACnD,IAAI,CAACU,kBAAkB,EAAE;QACrB;QACA;QACA;MACJ;MACA,IAAI,CAACV,mBAAmB,GAAG,IAAI;MAC/B,IAAI,IAAI,CAACjC,QAAQ,CAACiD,SAAS,EAAE;QACzB;QACA;QACA;QACA;QACA,MAAMC,QAAQ,GAAG/E,aAAa,CAACgF,gBAAgB,CAAC,IAAI,CAACrD,SAAS,CAAC;QAC/D,MAAMP,SAAS,GAAGpB,aAAa,CAACiF,6BAA6B,CAAC,IAAI,CAACvB,cAAc,EAAEqB,QAAQ,CAAC;QAC5F,IAAI,CAACrB,cAAc,GAAGqB,QAAQ;QAC9B,IAAI,CAACnC,OAAO,CAACW,IAAI,CAACnC,SAAS,CAAC;QAC5B,IAAI,CAAC8B,iBAAiB,CAACK,IAAI,EAAE;QAC7B;MACJ;MACA,MAAMnC,SAAS,GAAGoD,kBAAkB,CAACtD,uBAAuB,CAAC+C,CAAC,CAACrD,IAAI,CAAC;MACpE,IAAI,CAAC8C,cAAc,GAAG1D,aAAa,CAACgF,gBAAgB,CAAC,IAAI,CAACrD,SAAS,CAAC;MACpE,IAAI,CAACiB,OAAO,CAACW,IAAI,CAACnC,SAAS,CAAC;MAC5B,IAAI,CAAC8B,iBAAiB,CAACK,IAAI,EAAE;IACjC,CAAC,CAAC,CAAC;IACH,IAAI,CAACxB,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACuD,OAAO,CAAEjB,CAAC,IAAK;MACzC,IAAIhE,iBAAiB,EAAE;QACnBqE,OAAO,CAACC,GAAG,CAAE,SAAQ,EAAEN,CAAC,CAAC;MAC7B;MACA;MACA;MACA,IAAI,CAACtC,SAAS,CAACwD,4BAA4B,CAAC,sBAAsB,CAAC;MACnE,IAAI,IAAI,CAACrB,mBAAmB,EAAE;QAC1B;MACJ;MACA,MAAMiB,QAAQ,GAAG/E,aAAa,CAACgF,gBAAgB,CAAC,IAAI,CAACrD,SAAS,CAAC;MAC/D,MAAMP,SAAS,GAAGpB,aAAa,CAACoF,WAAW,CAAC,IAAI,CAAC1B,cAAc,EAAEqB,QAAQ,EAAE,qBAAsB,IAAI,CAACnD,GAAG,KAAK,CAAC,CAAC,gCAAgC;MAChJ,IAAIR,SAAS,CAACC,kBAAkB,KAAK,CAAC,IAAID,SAAS,CAACD,IAAI,CAACK,MAAM,KAAK,CAAC,IAAIzB,OAAO,CAACsF,eAAe,CAACjE,SAAS,CAACD,IAAI,CAACmE,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;QAC5H;QACA;MACJ;MACA,IAAI,CAAC5B,cAAc,GAAGqB,QAAQ;MAC9B,IAAI3D,SAAS,CAACD,IAAI,KAAK,EAAE,IAClBC,SAAS,CAACC,kBAAkB,KAAK,CAAC,IAClCD,SAAS,CAACE,kBAAkB,KAAK,CAAC,IAClCF,SAAS,CAACG,aAAa,KAAK,CAAC,EAAE;QAClC,IAAI,CAACqB,OAAO,CAACW,IAAI,CAACnC,SAAS,CAAC;MAChC;IACJ,CAAC,CAAC,CAAC;IACH;IACA,IAAI,CAACW,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACc,KAAK,CAAEwB,CAAC,IAAK;MACvC;MACA;MACA,IAAI,CAACtC,SAAS,CAACwD,4BAA4B,CAAC,oBAAoB,CAAC;MACjE,IAAI,CAACI,mCAAmC,CAACtB,CAAC,CAAC;MAC3C,IAAI,CAACX,gBAAgB,CAACkC,QAAQ,EAAE;IACpC,CAAC,CAAC,CAAC;IACH,IAAI,CAACzD,SAAS,CAAC,IAAI,CAACJ,SAAS,CAAC8D,MAAM,CAAExB,CAAC,IAAK;MACxC,IAAI,CAACsB,mCAAmC,CAACtB,CAAC,CAAC;IAC/C,CAAC,CAAC,CAAC;IACH,IAAI,CAAClC,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACgB,OAAO,CAAEsB,CAAC,IAAK;MACzC;MACA;MACA,IAAI,CAACtC,SAAS,CAACwD,4BAA4B,CAAC,sBAAsB,CAAC;MACnElB,CAAC,CAACI,cAAc,EAAE;MAClB,IAAI,CAACJ,CAAC,CAACyB,aAAa,EAAE;QAClB;MACJ;MACA,IAAI,CAACvE,IAAI,EAAEwE,QAAQ,CAAC,GAAGC,mBAAmB,CAACC,WAAW,CAAC5B,CAAC,CAACyB,aAAa,CAAC;MACvE,IAAI,CAACvE,IAAI,EAAE;QACP;MACJ;MACA;MACAwE,QAAQ,GAAGA,QAAQ,IAAIpF,gCAAgC,CAACQ,QAAQ,CAACF,GAAG,CAACM,IAAI,CAAC;MAC1E,IAAI,CAACuB,QAAQ,CAACa,IAAI,CAAC;QACfpC,IAAI,EAAEA,IAAI;QACVwE,QAAQ,EAAEA;MACd,CAAC,CAAC;IACN,CAAC,CAAC,CAAC;IACH,IAAI,CAAC5D,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACK,OAAO,CAAC,MAAM;MACxC,MAAM8D,QAAQ,GAAG,IAAI,CAACjC,SAAS;MAC/B,IAAI,CAACkC,YAAY,CAAC,IAAI,CAAC;MACvB,IAAI,IAAI,CAAClE,QAAQ,CAACmE,QAAQ,IAAI,CAACF,QAAQ,IAAI,IAAI,CAACjC,SAAS,EAAE;QACvD;QACA;QACA,IAAI,CAACL,uCAAuC,CAACgC,QAAQ,EAAE;MAC3D;IACJ,CAAC,CAAC,CAAC;IACH,IAAI,CAACzD,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACQ,MAAM,CAAC,MAAM;MACvC,IAAI,IAAI,CAAC2B,mBAAmB,EAAE;QAC1B;QACA;QACA;QACA;QACA,IAAI,CAACA,mBAAmB,GAAG,IAAI;QAC/B;QACA,IAAI,CAACL,wBAAwB,CAAC,2BAA2B,CAAC;QAC1D;QACA,IAAI,CAACP,iBAAiB,CAACK,IAAI,EAAE;MACjC;MACA,IAAI,CAACwC,YAAY,CAAC,KAAK,CAAC;IAC5B,CAAC,CAAC,CAAC;IACH,IAAI,CAAChE,SAAS,CAAC,IAAI,CAACJ,SAAS,CAACsE,cAAc,CAAC,MAAM;MAC/C,IAAI,IAAI,CAACpE,QAAQ,CAACiD,SAAS,IAAI,IAAI,CAAChB,mBAAmB,EAAE;QACrD;QACA;QACA;QACA,IAAI,CAACA,mBAAmB,GAAG,IAAI;QAC/B;QACA,IAAI,CAACL,wBAAwB,CAAC,0BAA0B,CAAC;QACzD;QACA,IAAI,CAACP,iBAAiB,CAACK,IAAI,EAAE;MACjC;IACJ,CAAC,CAAC,CAAC;EACP;EACA2C,+BAA+B,GAAG;IAC9B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIC,gCAAgC,GAAG,CAAC;IACxC,OAAO1G,GAAG,CAAC2G,qBAAqB,CAACC,QAAQ,EAAE,iBAAiB,EAAGpC,CAAC,IAAK;MACjE,IAAI,CAAC,IAAI,CAACJ,SAAS,EAAE;QACjB;MACJ;MACA,IAAI,IAAI,CAACC,mBAAmB,EAAE;QAC1B;MACJ;MACA,IAAI,CAAC,IAAI,CAACjC,QAAQ,CAACyE,QAAQ,EAAE;QACzB;QACA;MACJ;MACA,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAG,EAAE;MACtB,MAAME,MAAM,GAAGF,GAAG,GAAGJ,gCAAgC;MACrDA,gCAAgC,GAAGI,GAAG;MACtC,IAAIE,MAAM,GAAG,CAAC,EAAE;QACZ;QACA;QACA;MACJ;MACA,MAAMC,MAAM,GAAGH,GAAG,GAAG,IAAI,CAAC5E,SAAS,CAACgF,4BAA4B,EAAE;MAClE,IAAI,CAAChF,SAAS,CAACiF,wBAAwB,EAAE;MACzC,IAAIF,MAAM,GAAG,GAAG,EAAE;QACd;QACA;QACA;MACJ;MACA,IAAI,CAAC,IAAI,CAAChD,cAAc,CAACmD,sBAAsB,IAAI,CAAC,IAAI,CAACnD,cAAc,CAACoD,oBAAoB,EAAE;QAC1F;QACA;MACJ;MACA,MAAMC,QAAQ,GAAG,IAAI,CAACpF,SAAS,CAACqF,QAAQ,EAAE;MAC1C,IAAI,IAAI,CAACtD,cAAc,CAACiB,KAAK,KAAKoC,QAAQ,EAAE;QACxC;QACA;MACJ;MACA,MAAME,iBAAiB,GAAG,IAAI,CAACtF,SAAS,CAACuF,iBAAiB,EAAE;MAC5D,MAAMC,eAAe,GAAG,IAAI,CAACxF,SAAS,CAACyF,eAAe,EAAE;MACxD,IAAI,IAAI,CAAC1D,cAAc,CAACe,cAAc,KAAKwC,iBAAiB,IAAI,IAAI,CAACvD,cAAc,CAACgB,YAAY,KAAKyC,eAAe,EAAE;QAClH;QACA;MACJ;MACA,MAAME,0BAA0B,GAAG,IAAI,CAAC3D,cAAc,CAAC4D,oBAAoB,CAACL,iBAAiB,CAAC;MAC9F,MAAMM,yBAAyB,GAAG,IAAI,CAAC7F,KAAK,CAAC8F,mBAAmB,CAACH,0BAA0B,CAAC,CAAC,CAAC,EAAEA,0BAA0B,CAAC,CAAC,CAAC,EAAEA,0BAA0B,CAAC,CAAC,CAAC,CAAC;MAC7J,MAAMI,wBAAwB,GAAG,IAAI,CAAC/D,cAAc,CAAC4D,oBAAoB,CAACH,eAAe,CAAC;MAC1F,MAAMO,uBAAuB,GAAG,IAAI,CAAChG,KAAK,CAAC8F,mBAAmB,CAACC,wBAAwB,CAAC,CAAC,CAAC,EAAEA,wBAAwB,CAAC,CAAC,CAAC,EAAEA,wBAAwB,CAAC,CAAC,CAAC,CAAC;MACrJ,MAAME,YAAY,GAAG,IAAIzH,SAAS,CAACqH,yBAAyB,CAACK,UAAU,EAAEL,yBAAyB,CAACM,MAAM,EAAEH,uBAAuB,CAACE,UAAU,EAAEF,uBAAuB,CAACG,MAAM,CAAC;MAC9K,IAAI,CAACzE,yBAAyB,CAACG,IAAI,CAACoE,YAAY,CAAC;IACrD,CAAC,CAAC;EACN;EACAG,OAAO,GAAG;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,IAAI,CAAClE,wBAAwB,EAAE;MAC/B,IAAI,CAACA,wBAAwB,CAACkE,OAAO,EAAE;MACvC,IAAI,CAAClE,wBAAwB,GAAG,IAAI;IACxC;EACJ;EACAmE,aAAa,GAAG;IACZ;IACA;IACA,IAAI,CAAChC,YAAY,CAAC,IAAI,CAAC;IACvB;IACA,IAAI,CAACiC,iBAAiB,EAAE;EAC5B;EACAC,SAAS,GAAG;IACR,OAAO,IAAI,CAACpE,SAAS;EACzB;EACAmE,iBAAiB,GAAG;IAChB,IAAI,CAACjC,YAAY,CAAC,IAAI,CAACpE,SAAS,CAACuG,QAAQ,EAAE,CAAC;EAChD;EACAnC,YAAY,CAACoC,WAAW,EAAE;IACtB,IAAI,IAAI,CAACtE,SAAS,KAAKsE,WAAW,EAAE;MAChC;MACA;IACJ;IACA,IAAI,CAACtE,SAAS,GAAGsE,WAAW;IAC5B,IAAI,IAAI,CAACvE,wBAAwB,EAAE;MAC/B,IAAI,CAACA,wBAAwB,CAACkE,OAAO,EAAE;MACvC,IAAI,CAAClE,wBAAwB,GAAG,IAAI;IACxC;IACA,IAAI,IAAI,CAACC,SAAS,EAAE;MAChB,IAAI,CAACD,wBAAwB,GAAG,IAAI,CAACsC,+BAA+B,EAAE;IAC1E;IACA,IAAI,IAAI,CAACrC,SAAS,EAAE;MAChB,IAAI,CAACJ,wBAAwB,CAAC,WAAW,CAAC;IAC9C;IACA,IAAI,IAAI,CAACI,SAAS,EAAE;MAChB,IAAI,CAAC/B,QAAQ,CAACyB,IAAI,EAAE;IACxB,CAAC,MACI;MACD,IAAI,CAACrB,OAAO,CAACqB,IAAI,EAAE;IACvB;EACJ;EACA6E,yBAAyB,CAACC,MAAM,EAAEC,aAAa,EAAE;IAC7C,IAAI,CAAC,IAAI,CAACzE,SAAS,EAAE;MACjByE,aAAa,GAAGA,aAAa,CAACC,iBAAiB,EAAE;IACrD;IACAD,aAAa,CAACE,eAAe,CAACH,MAAM,EAAE,IAAI,CAAC1G,SAAS,EAAE,IAAI,CAACkC,SAAS,CAAC;IACrE,IAAI,CAACH,cAAc,GAAG4E,aAAa;EACvC;EACA7E,wBAAwB,CAAC4E,MAAM,EAAE;IAC7B,IAAI,IAAI,CAACvE,mBAAmB,EAAE;MAC1B;MACA;IACJ;IACA,IAAI,CAACsE,yBAAyB,CAACC,MAAM,EAAE,IAAI,CAAC3G,KAAK,CAAC+G,sBAAsB,CAAC,IAAI,CAAC/E,cAAc,CAAC,CAAC;EAClG;EACA6B,mCAAmC,CAACtB,CAAC,EAAE;IACnC,MAAMyE,UAAU,GAAG,IAAI,CAAChH,KAAK,CAACiH,aAAa,EAAE;IAC7C,MAAMC,cAAc,GAAG;MACnBC,OAAO,EAAE,CAAC;MACVC,oBAAoB,EAAEJ,UAAU,CAACI,oBAAoB;MACrDC,eAAe,EAAEL,UAAU,CAACK,eAAe;MAC3CC,IAAI,EAAEN,UAAU,CAACM;IACrB,CAAC;IACDzI,gCAAgC,CAACQ,QAAQ,CAACL,GAAG;IAC7C;IACA;IACC,IAAI,CAACmB,QAAQ,CAACoH,SAAS,GAAGP,UAAU,CAACvH,IAAI,CAAC+H,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,GAAGR,UAAU,CAACvH,IAAI,EAAGyH,cAAc,CAAC;IACrG3E,CAAC,CAACI,cAAc,EAAE;IAClB,IAAIJ,CAAC,CAACyB,aAAa,EAAE;MACjBE,mBAAmB,CAACuD,WAAW,CAAClF,CAAC,CAACyB,aAAa,EAAEgD,UAAU,CAACvH,IAAI,EAAEuH,UAAU,CAACU,IAAI,EAAER,cAAc,CAAC;IACtG;EACJ;AACJ;AACA,MAAMhD,mBAAmB,CAAC;EACtB,OAAOC,WAAW,CAACH,aAAa,EAAE;IAC9B,MAAMvE,IAAI,GAAGuE,aAAa,CAAC2D,OAAO,CAACvJ,KAAK,CAACqB,IAAI,CAAC;IAC9C,IAAIwE,QAAQ,GAAG,IAAI;IACnB,MAAM2D,WAAW,GAAG5D,aAAa,CAAC2D,OAAO,CAAC,oBAAoB,CAAC;IAC/D,IAAI,OAAOC,WAAW,KAAK,QAAQ,EAAE;MACjC,IAAI;QACA3D,QAAQ,GAAG4D,IAAI,CAACC,KAAK,CAACF,WAAW,CAAC;QAClC,IAAI3D,QAAQ,CAACkD,OAAO,KAAK,CAAC,EAAE;UACxBlD,QAAQ,GAAG,IAAI;QACnB;MACJ,CAAC,CACD,OAAO8D,GAAG,EAAE;QACR;MAAA;IAER;IACA,IAAItI,IAAI,CAACK,MAAM,KAAK,CAAC,IAAImE,QAAQ,KAAK,IAAI,IAAID,aAAa,CAACgE,KAAK,CAAClI,MAAM,GAAG,CAAC,EAAE;MAC1E;MACA,MAAMkI,KAAK,GAAGC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACpE,aAAa,CAACgE,KAAK,EAAE,CAAC,CAAC;MAChE,OAAO,CAACA,KAAK,CAACK,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC;IAC1D;IACA,OAAO,CAAC/I,IAAI,EAAEwE,QAAQ,CAAC;EAC3B;EACA,OAAOwD,WAAW,CAACzD,aAAa,EAAEvE,IAAI,EAAEiI,IAAI,EAAEzD,QAAQ,EAAE;IACpDD,aAAa,CAACyE,OAAO,CAACrK,KAAK,CAACqB,IAAI,EAAEA,IAAI,CAAC;IACvC,IAAI,OAAOiI,IAAI,KAAK,QAAQ,EAAE;MAC1B1D,aAAa,CAACyE,OAAO,CAAC,WAAW,EAAEf,IAAI,CAAC;IAC5C;IACA1D,aAAa,CAACyE,OAAO,CAAC,oBAAoB,EAAEZ,IAAI,CAACa,SAAS,CAACzE,QAAQ,CAAC,CAAC;EACzE;AACJ;AACA,OAAO,MAAM0E,eAAe,SAASxK,UAAU,CAAC;EAC5CW,WAAW,CAAC8J,OAAO,EAAE;IACjB,KAAK,EAAE;IACP,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACjI,SAAS,GAAG,IAAI,CAACN,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,SAAS,CAAC,CAAC,CAACrI,KAAK;IACtF,IAAI,CAACM,OAAO,GAAG,IAAI,CAACR,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,OAAO,CAAC,CAAC,CAACrI,KAAK;IAClF,IAAI,CAACc,kBAAkB,GAAG,IAAI,CAAChB,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,kBAAkB,CAAC,CAAC,CAACrI,KAAK;IACxG,IAAI,CAACgB,mBAAmB,GAAG,IAAI,CAAClB,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,mBAAmB,CAAC,CAAC,CAACrI,KAAK;IAC1G,IAAI,CAACkB,gBAAgB,GAAG,IAAI,CAACpB,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,gBAAgB,CAAC,CAAC,CAACrI,KAAK;IACpG,IAAI,CAACiD,OAAO,GAAG,IAAI,CAACnD,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,OAAO,CAAC,CAAC,CAACrI,KAAK;IAClF,IAAI,CAACQ,KAAK,GAAG,IAAI,CAACV,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,KAAK,CAAC,CAAC,CAACrI,KAAK;IAC9E,IAAI,CAACwD,MAAM,GAAG,IAAI,CAAC1D,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,MAAM,CAAC,CAAC,CAACrI,KAAK;IAChF,IAAI,CAACU,OAAO,GAAG,IAAI,CAACZ,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,OAAO,CAAC,CAAC,CAACrI,KAAK;IAClF,IAAI,CAACD,OAAO,GAAG,IAAI,CAACD,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,OAAO,CAAC,CAAC,CAACrI,KAAK;IAClF,IAAI,CAACE,MAAM,GAAG,IAAI,CAACJ,SAAS,CAACtC,GAAG,CAAC8K,kBAAkB,CAAC,IAAI,CAACD,OAAO,EAAE,MAAM,CAAC,CAAC,CAACrI,KAAK;IAChF,IAAI,CAACuI,eAAe,GAAG,IAAI,CAACzI,SAAS,CAAC,IAAInC,OAAO,EAAE,CAAC;IACpD,IAAI,CAACqG,cAAc,GAAG,IAAI,CAACuE,eAAe,CAACvI,KAAK;IAChD,IAAI,CAACwI,0BAA0B,GAAG,CAAC;IACnC,IAAI,CAAC1I,SAAS,CAACtC,GAAG,CAAC2G,qBAAqB,CAAC,IAAI,CAACkE,OAAO,EAAEnK,uBAAuB,CAACC,GAAG,EAAE,MAAM,IAAI,CAACoK,eAAe,CAACjH,IAAI,EAAE,CAAC,CAAC;EAC3H;EACA2E,QAAQ,GAAG;IACP,MAAMwC,UAAU,GAAGjL,GAAG,CAACkL,aAAa,CAAC,IAAI,CAACL,OAAO,CAAC;IAClD,IAAII,UAAU,EAAE;MACZ,OAAOA,UAAU,CAACE,aAAa,KAAK,IAAI,CAACN,OAAO;IACpD,CAAC,MACI,IAAI7K,GAAG,CAACoL,OAAO,CAAC,IAAI,CAACP,OAAO,CAAC,EAAE;MAChC,OAAOjE,QAAQ,CAACuE,aAAa,KAAK,IAAI,CAACN,OAAO;IAClD,CAAC,MACI;MACD,OAAO,KAAK;IAChB;EACJ;EACAnF,4BAA4B,CAACkD,MAAM,EAAE;IACjC,IAAI,CAACoC,0BAA0B,GAAGjE,IAAI,CAACD,GAAG,EAAE;EAChD;EACAI,4BAA4B,GAAG;IAC3B,OAAO,IAAI,CAAC8D,0BAA0B;EAC1C;EACA7D,wBAAwB,GAAG;IACvB,IAAI,CAAC6D,0BAA0B,GAAG,CAAC;EACvC;EACAzD,QAAQ,GAAG;IACP;IACA,OAAO,IAAI,CAACsD,OAAO,CAAC3F,KAAK;EAC7B;EACAmG,QAAQ,CAACzC,MAAM,EAAE1D,KAAK,EAAE;IACpB,MAAMoG,QAAQ,GAAG,IAAI,CAACT,OAAO;IAC7B,IAAIS,QAAQ,CAACpG,KAAK,KAAKA,KAAK,EAAE;MAC1B;MACA;IACJ;IACA;IACA,IAAI,CAACQ,4BAA4B,CAAC,UAAU,CAAC;IAC7C4F,QAAQ,CAACpG,KAAK,GAAGA,KAAK;EAC1B;EACAuC,iBAAiB,GAAG;IAChB,OAAO,IAAI,CAACoD,OAAO,CAACU,kBAAkB,KAAK,UAAU,GAAG,IAAI,CAACV,OAAO,CAAC5F,YAAY,GAAG,IAAI,CAAC4F,OAAO,CAAC7F,cAAc;EACnH;EACA2C,eAAe,GAAG;IACd,OAAO,IAAI,CAACkD,OAAO,CAACU,kBAAkB,KAAK,UAAU,GAAG,IAAI,CAACV,OAAO,CAAC7F,cAAc,GAAG,IAAI,CAAC6F,OAAO,CAAC5F,YAAY;EACnH;EACAuG,iBAAiB,CAAC5C,MAAM,EAAE5D,cAAc,EAAEC,YAAY,EAAE;IACpD,MAAMqG,QAAQ,GAAG,IAAI,CAACT,OAAO;IAC7B,IAAIM,aAAa,GAAG,IAAI;IACxB,MAAMF,UAAU,GAAGjL,GAAG,CAACkL,aAAa,CAACI,QAAQ,CAAC;IAC9C,IAAIL,UAAU,EAAE;MACZE,aAAa,GAAGF,UAAU,CAACE,aAAa;IAC5C,CAAC,MACI;MACDA,aAAa,GAAGvE,QAAQ,CAACuE,aAAa;IAC1C;IACA,MAAMM,gBAAgB,GAAIN,aAAa,KAAKG,QAAS;IACrD,MAAMI,qBAAqB,GAAGJ,QAAQ,CAACtG,cAAc;IACrD,MAAM2G,mBAAmB,GAAGL,QAAQ,CAACrG,YAAY;IACjD,IAAIwG,gBAAgB,IAAIC,qBAAqB,KAAK1G,cAAc,IAAI2G,mBAAmB,KAAK1G,YAAY,EAAE;MACtG;MACA;MACA,IAAIlF,OAAO,CAACyJ,SAAS,IAAIoC,MAAM,CAACC,MAAM,KAAKD,MAAM,EAAE;QAC/CN,QAAQ,CAACQ,KAAK,EAAE;MACpB;MACA;IACJ;IACA;IACA,IAAIL,gBAAgB,EAAE;MAClB;MACA,IAAI,CAAC/F,4BAA4B,CAAC,mBAAmB,CAAC;MACtD4F,QAAQ,CAACE,iBAAiB,CAACxG,cAAc,EAAEC,YAAY,CAAC;MACxD,IAAIlF,OAAO,CAACyJ,SAAS,IAAIoC,MAAM,CAACC,MAAM,KAAKD,MAAM,EAAE;QAC/CN,QAAQ,CAACQ,KAAK,EAAE;MACpB;MACA;IACJ;IACA;IACA;IACA,IAAI;MACA,MAAMC,WAAW,GAAG/L,GAAG,CAACgM,oBAAoB,CAACV,QAAQ,CAAC;MACtD,IAAI,CAAC5F,4BAA4B,CAAC,mBAAmB,CAAC;MACtD4F,QAAQ,CAACQ,KAAK,EAAE;MAChBR,QAAQ,CAACE,iBAAiB,CAACxG,cAAc,EAAEC,YAAY,CAAC;MACxDjF,GAAG,CAACiM,uBAAuB,CAACX,QAAQ,EAAES,WAAW,CAAC;IACtD,CAAC,CACD,OAAOvH,CAAC,EAAE;MACN;IAAA;EAER;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}